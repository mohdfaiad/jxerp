/******************************************************************************/
/***          Generated by IBExpert 2009.10.29 10/10/2013 12:37:46          ***/
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES NONE;

CREATE DATABASE '127.0.0.1:K:\Database\JXERP\JXERPDB-NEW.fdb'
USER 'SYSDBA' PASSWORD 'masterkey'
PAGE_SIZE 4096
DEFAULT CHARACTER SET NONE;



/******************************************************************************/
/***                         User Defined Functions                         ***/
/******************************************************************************/

DECLARE EXTERNAL FUNCTION "ABS"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_abs' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "ACOS"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_acos' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ADD_USER
    INTEGER,
    CSTRING(255),
    CSTRING(31),
    CSTRING(8),
    CSTRING(31),
    CSTRING(31),
    CSTRING(31),
    CSTRING(31),
    CSTRING(31),
    CSTRING(8)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_add_user' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "ASIN"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_asin' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "ATAN"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_atan' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "ATAN2"
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_atan2' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION BITAND
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_bitAnd' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION BITNOT
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_bitNot' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION BITOR
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_bitOr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION BITXOR
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_bitXor' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_LINE
    BLOB,
    INTEGER
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_b_line' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_LINE_COUNT
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_b_line_count' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_LONGLINE
    BLOB,
    INTEGER
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_b_longline' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_LONGSUBSTR
    BLOB,
    INTEGER,
    INTEGER
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_b_longsubstr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_MAX_SEGMENT
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_b_max_segment' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_NUMBER_SEGMENTS
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_b_number_segments' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_PUT_SEGMENT
    CSTRING(16383),
    BLOB
    RETURNS PARAMETER 2
    ENTRY_POINT 'fn_b_put_segment' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_STRCMP
    BLOB,
    BLOB
    RETURNS SMALLINT BY VALUE
    ENTRY_POINT 'fn_b_strcmp' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_STRPOS
    CSTRING(16383),
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_b_strpos' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_SUBSTR
    BLOB,
    INTEGER,
    INTEGER
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_b_substr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_TEXTPOS
    CSTRING(16383),
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_b_textpos' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION B_TOTAL_LENGTH
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_b_total_length' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION C
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_c' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION CALCEXPR
    CSTRING(16383),
    CSTRING(16383)
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_CalcExpr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "CEIL"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_ceil' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION CEQUAL
    CSTRING(16383),
    CSTRING(16383)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_cequal' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION CHR
    SMALLINT
    RETURNS CSTRING(1) FREE_IT
    ENTRY_POINT 'fn_chr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION CIF
    INTEGER,
    CSTRING(255),
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_cif' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION CONVERTSYMBOLS
    CSTRING(255),
    CSTRING(255),
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_convertsymbols' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "COS"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_cos' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "COSH"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_cosh' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION CREATEGUID

    RETURNS CSTRING(38) FREE_IT
    ENTRY_POINT 'fn_CreateGUID' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DATETODOUBLE
    DATE
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_datetodouble' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DATETOSTR
    DATE,
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_datetostr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DAYPERMONTH
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_daypermonth' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DAYSBETWEEN
    TIMESTAMP,
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_daysbetween' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DELETE_USER
    INTEGER,
    CSTRING(255),
    CSTRING(31),
    CSTRING(31),
    CSTRING(8)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_delete_user' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DIF
    INTEGER,
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_dif' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DIV
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_div' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DOUBLETODATE
    DOUBLE PRECISION
    RETURNS DATE FREE_IT
    ENTRY_POINT 'fn_doubletodate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DOUBLETOTIME
    DOUBLE PRECISION
    RETURNS DATE FREE_IT
    ENTRY_POINT 'fn_doubletotime' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DOW
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_dow' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DTEQUAL
    DATE,
    DATE
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_dtequal' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DTIF
    INTEGER,
    TIMESTAMP,
    TIMESTAMP
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_dtif' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION DZERO
    DOUBLE PRECISION,
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_dividezero' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION E

    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_e' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EAN13CS
    CSTRING(255)
    RETURNS SMALLINT BY VALUE
    ENTRY_POINT 'fn_ean13cs' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ENCODEDATE
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS DATE FREE_IT
    ENTRY_POINT 'fn_encodedate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ENCODEDATETIME
    INTEGER,
    INTEGER,
    INTEGER,
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS DATE FREE_IT
    ENTRY_POINT 'fn_encodedatetime' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXP
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_exp' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXPRISVALID
    CSTRING(16383),
    CSTRING(16383)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_ExprIsValid' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTDATE
    TIMESTAMP
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_extractdate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTDAY
    DATE
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_day' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTHOUR
    DATE
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_hour' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTMILLISECOND
    DATE
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_millisecond' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTMINUTE
    DATE
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_minute' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTMONTH
    DATE
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_month' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTSECOND
    DATE
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_second' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTTIME
    TIMESTAMP
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_extracttime' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTWEEKDAY
    DATE
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_weekday' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTYEAR
    DATE
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_year' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION EXTRACTYEARDAY
    DATE
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_yearday' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FCLOSE
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fclose' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FCREATE
    CSTRING(255),
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fcreate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FIRSTDAYMONTH
    TIMESTAMP
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_firstdaymonth' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FLOATTOSTR
    DOUBLE PRECISION,
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_floattostr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "FLOOR"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_floor' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FN_ROUND
    DOUBLE PRECISION,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_round' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FOPEN
    CSTRING(255),
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fopen' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_APPEND

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_append' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_CREAT

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_creat' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_EXCL

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_excl' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_RDONLY

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_rdonly' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_RDWR

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_rdwr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_TRUNC

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_trunc' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FO_WRONLY

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fo_wronly' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FREAD
    INTEGER,
    INTEGER
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_fread' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FREMOVE
    CSTRING(255)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fremove' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FSEEK
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fseek' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FSEEK_CUR

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fseek_cur' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FSEEK_END

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fseek_end' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FSEEK_SET

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fseek_set' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FSIZE
    CSTRING(255)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fsize' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FS_IEXEC

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fs_iexec' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FS_IREAD

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fs_iread' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FS_IWRITE

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fs_iwrite' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION FWRITE
    INTEGER,
    CSTRING(16383)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_fwrite' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION GETBIT
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_getBit' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION GETRANDOM
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_getRandom' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION IEQUAL
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_iequal' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "IIF"
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_iif' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION INCDATE
    TIMESTAMP,
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_incdate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION INCDATETIME
    DATE,
    INTEGER,
    INTEGER,
    INTEGER,
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS DATE
    ENTRY_POINT 'fn_incdatetime' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION INITRANDOM
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_initRandom' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION INTTOSTR
    INTEGER,
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_inttostr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ISLEAPYEAR
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_isleapyear' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LASTDAYMONTH
    TIMESTAMP
    RETURNS TIMESTAMP
    ENTRY_POINT 'fn_lastdaymonth' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LIBNAME

    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_libname' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LIBVERSION

    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_libversion' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "LN"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_ln' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "LOG"
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_log' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "LOG10"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_log10' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGC
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_c' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGCIF
    INTEGER,
    CSTRING(16383),
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_cif' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGCONVERTSYMBOLS
    CSTRING(16383),
    CSTRING(255),
    CSTRING(255)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_convertsymbols' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGFREAD
    INTEGER,
    INTEGER
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_fread' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGLTRIM
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_ltrim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGPADLEFT
    CSTRING(16383),
    SMALLINT,
    CSTRING(1)
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_longpadleft' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGPADRIGHT
    CSTRING(16383),
    SMALLINT,
    CSTRING(1)
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_longpadright' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGREPEATTRIM
    CSTRING(16383),
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_repeattrim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGRLATIN
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_rlatin' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGRLOWER
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_rlower' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGRTRANSLIT
    CSTRING(16383)
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_longrtranslit' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGRTRIM
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_rtrim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGRUPPER
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_rupper' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGSTRREPEAT
    CSTRING(16383),
    INTEGER
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_longstrrepeat' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGSTRREPLACE
    CSTRING(16383),
    CSTRING(16383),
    CSTRING(16383)
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_longstrreplace' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGSTRSTUFF
    CSTRING(16383),
    INTEGER,
    INTEGER,
    CSTRING(16383)
    RETURNS CSTRING(16383) FREE_IT
    ENTRY_POINT 'fn_longstrstuff' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGSUBSTR
    CSTRING(16383),
    INTEGER,
    INTEGER
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_substr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGTRIM
    CSTRING(16383)
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_trim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LONGWORDNUM
    CSTRING(16383),
    INTEGER,
    CSTRING(31),
    SMALLINT
    RETURNS CSTRING(16383)
    ENTRY_POINT 'fn_wordnum' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION LTRIM
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_ltrim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MAXDATE
    DATE,
    DATE
    RETURNS DATE
    ENTRY_POINT 'fn_maxdate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MAXNUM
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_maxnum' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MD5FINAL
    CSTRING(176)
    RETURNS CSTRING(32) FREE_IT
    ENTRY_POINT 'fn_md5final' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MD5INIT

    RETURNS CSTRING(176) FREE_IT
    ENTRY_POINT 'fn_md5init' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MD5SUM
    CSTRING(16383)
    RETURNS CSTRING(32) FREE_IT
    ENTRY_POINT 'fn_md5sum' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MD5UPDATE
    CSTRING(176),
    CSTRING(16383),
    INTEGER
    RETURNS CSTRING(176)
    ENTRY_POINT 'fn_md5update' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MINDATE
    DATE,
    DATE
    RETURNS DATE
    ENTRY_POINT 'fn_mindate' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MINNUM
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_minnum' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "MOD"
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_mod' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MODIFY_USER
    INTEGER,
    CSTRING(255),
    CSTRING(31),
    CSTRING(8),
    CSTRING(31),
    CSTRING(31),
    CSTRING(31),
    CSTRING(31),
    CSTRING(31),
    CSTRING(8)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_modify_user' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION MSGBOX
    CSTRING(16383),
    CSTRING(255),
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_msgbox' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION NUMINWORDS
    INTEGER,
    CSTRING(1)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_numinwords' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION ORD
    CSTRING(1)
    RETURNS SMALLINT BY VALUE
    ENTRY_POINT 'fn_ord' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION PADLEFT
    CSTRING(255),
    SMALLINT,
    CSTRING(1)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_padleft' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION PADRIGHT
    CSTRING(255),
    SMALLINT,
    CSTRING(1)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_padright' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "PI"

    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_pi' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "POWER"
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_power' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION QUARTER
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_quarter' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION REPEATTRIM
    CSTRING(255),
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_repeattrim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION RLATIN
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_rlatin' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION RLOWER
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_rlower' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "ROUND"
    DOUBLE PRECISION,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_round' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION RTRANSLIT
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_rtranslit' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION RTRIM
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_rtrim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION RUPPER
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_rupper' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION SETBIT
    INTEGER,
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_setBit' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "SIGN"
    DOUBLE PRECISION
    RETURNS SMALLINT BY VALUE
    ENTRY_POINT 'fn_sign' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "SIN"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_sin' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "SINH"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_sinh' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION SOFTROUND
    DOUBLE PRECISION,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_softround' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "SQRT"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_sqrt' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRCMP
    CSTRING(16383),
    CSTRING(16383)
    RETURNS SMALLINT BY VALUE
    ENTRY_POINT 'fn_strcmp' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRCOUNT
    CSTRING(255),
    CSTRING(16383)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_strcount' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRLEN
    CSTRING(16383)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_strlen' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRPOS
    CSTRING(16383),
    CSTRING(16383)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_strpos' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRREPEAT
    CSTRING(255),
    INTEGER
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_strrepeat' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRREPLACE
    CSTRING(255),
    CSTRING(255),
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_strreplace' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRSTUFF
    CSTRING(255),
    INTEGER,
    INTEGER,
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'fn_strstuff' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION STRTRIM
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_trim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION SUBSTR
    CSTRING(255),
    INTEGER,
    INTEGER
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_substr' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "TAN"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_tan' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "TANH"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_tanh' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION TIMETODOUBLE
    DATE
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_timetodouble' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION "TRIM"
    CSTRING(255)
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_trim' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION WORDCOUNT
    CSTRING(16383),
    CSTRING(31),
    SMALLINT
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'fn_wordcount' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION WORDNUM
    CSTRING(16383),
    INTEGER,
    CSTRING(31),
    SMALLINT
    RETURNS CSTRING(255)
    ENTRY_POINT 'fn_wordnum' MODULE_NAME 'rfunc';


DECLARE EXTERNAL FUNCTION Z
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'fn_z' MODULE_NAME 'rfunc';




/******************************************************************************/
/***                                Domains                                 ***/
/******************************************************************************/

CREATE DOMAIN DDATE AS
TIMESTAMP;

CREATE DOMAIN DOUBLES AS
DOUBLE PRECISION;

CREATE DOMAIN FFLOAT AS
FLOAT;

CREATE DOMAIN FLAG AS
VARCHAR(1);

CREATE DOMAIN MEMOS AS
VARCHAR(1500);

CREATE DOMAIN NUMERIC122 AS
NUMERIC(12,2)
DEFAULT 0.00;

CREATE DOMAIN SSMALLINT AS
SMALLINT;

CREATE DOMAIN TEXT AS
BLOB SUB_TYPE 1 SEGMENT SIZE 255;

CREATE DOMAIN VARCHAR10 AS
VARCHAR(10);

CREATE DOMAIN VARCHAR15 AS
VARCHAR(15);

CREATE DOMAIN VARCHAR150 AS
VARCHAR(150);

CREATE DOMAIN VARCHAR2 AS
VARCHAR(2);

CREATE DOMAIN VARCHAR255 AS
VARCHAR(800);

CREATE DOMAIN VARCHAR30 AS
VARCHAR(30);

CREATE DOMAIN VARCHAR4 AS
VARCHAR(4);

CREATE DOMAIN VARCHAR45 AS
VARCHAR(45);

CREATE DOMAIN VARCHAR60 AS
VARCHAR(60);



/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR DBGEN;
SET GENERATOR DBGEN TO 0;

CREATE GENERATOR GEN_AR_RECEIPT_DT_ID;
SET GENERATOR GEN_AR_RECEIPT_DT_ID TO 0;

CREATE GENERATOR GEN_AR_RECEIPT_HD_ID;
SET GENERATOR GEN_AR_RECEIPT_HD_ID TO 0;

CREATE GENERATOR GEN_DO_BATCH_NO;
SET GENERATOR GEN_DO_BATCH_NO TO 4;

CREATE GENERATOR LICENSEGEN;
SET GENERATOR LICENSEGEN TO 0;

CREATE GENERATOR MYGENERATOR;
SET GENERATOR MYGENERATOR TO 3267;

CREATE GENERATOR RELATIONGEN;
SET GENERATOR RELATIONGEN TO 0;

CREATE GENERATOR REPLGEN;
SET GENERATOR REPLGEN TO 0;

CREATE GENERATOR REPL_GENERATOR;
SET GENERATOR REPL_GENERATOR TO 808073;



/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION ERWIN_CHILD_DELETE_RESTRICT 'Cannot DELETE Child table because Parent table does not exist.';

CREATE EXCEPTION ERWIN_CHILD_INSERT_RESTRICT 'Cannot INSERT Child table because Parent table does not exist.';

CREATE EXCEPTION ERWIN_CHILD_UPDATE_RESTRICT 'Cannot UPDATE Child table because Parent table does not exist.';

CREATE EXCEPTION ERWIN_PARENT_DELETE_RESTRICT 'Cannot DELETE Parent table because Child table exists.';

CREATE EXCEPTION ERWIN_PARENT_INSERT_RESTRICT 'Cannot INSERT Parent table because Child table exists.';

CREATE EXCEPTION ERWIN_PARENT_UPDATE_RESTRICT 'Cannot UPDATE Parent table because Child table exists.';

CREATE EXCEPTION EX_GRN_DATE_CHECK 'Stock issue date could not be early than received date';

CREATE EXCEPTION EX_IC_ONHAND_ERROR 'Could not update onhand qty balance amount can not less than zero';

CREATE EXCEPTION EX_INS_STK_DT 'COULD NOT INSERT IC_MAT_STK_DT';

CREATE EXCEPTION EX_INS_STOCKCARD 'COULD NOT INSERT INTO IC STOCKCARD!!!!';

CREATE EXCEPTION EX_MELT_NO_POST_ERROR 'You must post previouse melt no before post this current melt no';

CREATE EXCEPTION EX_PO_ORDER_DT 'Could not delete Order Detail Coz this order refered to Goods receive';

CREATE EXCEPTION EX_SALES_STOCK 'Could not update sale Stock Onhand Qty might not be enough';

CREATE EXCEPTION EX_SO_LEDGER 'Could not insert into Sale Ledger Quantity Might not enouth';

CREATE EXCEPTION EX_SO_ORDER_DT 'COULD NOT INSERT SO_ORDE4R_DT FILE.';

CREATE EXCEPTION EX_SO_ORDER_HD 'COULD NOT INSERT INTO SO_ORDER_HD';

CREATE EXCEPTION E_AMT_ERROR 'Update value is error!!!';

CREATE EXCEPTION E_CLOSE_PLAN 'Could not Close plan when melt no are active !!!';

CREATE EXCEPTION E_DELETE_PO_SUPPLIER 'Could not delete supplie when  creditor account exists';

CREATE EXCEPTION E_DELETE_SO_CUSTOMER 'Could not delete customer when debtor account exists';

CREATE EXCEPTION E_DEL_STOCKCARD 'Could not delete stock card transaction because ic_mat_stk_hd exist';

CREATE EXCEPTION E_DEL_STOCK_DETAIL 'Could not delete Stock Detail When Stock card transaction exist';

CREATE EXCEPTION E_INSERT_DROSS_BALANCE 'Faile to insert dross balance';

CREATE EXCEPTION E_INSERT_DROSS_LEDGER 'Faile to insert dross ledger';

CREATE EXCEPTION E_MONTHLY_CLOSE 'Specify month and year already closed';

CREATE EXCEPTION E_NO_DEFAULT_ELEMEMENT 'NO DEFAULT ELEMENT FOUND PLAEASE SET UP';

CREATE EXCEPTION E_NO_ROW 'Detail Record Not Found !!!';

CREATE EXCEPTION E_PL_MELT_SUMMARY 'Invalid report parameter!! Checks input parameters';

CREATE EXCEPTION E_SALES_STOCK_EXIST 'Could not delete Sale item when Sale stock exists.';

CREATE EXCEPTION E_SALE_LEDGER_EXIST 'Could not delete from Sale Ledger transaction Exists.';

CREATE EXCEPTION E_SO_DELIVERY_EXIST 'รายการนี้ไม่สามารถยกเลิกได้เนื่องจามีการส่งของแล้วบางส่วน';

CREATE EXCEPTION E_SO_ORDER_DT_EXIST 'Could Not Delete When Sale order Detail transaction exists.';

CREATE EXCEPTION E_SO_ORDER_ITEM_STATUS 'สินค้าชิ้นนี้มีการส่งของไปบางส่วนแล้วไม่สามารถยกเลิกได้';

CREATE EXCEPTION E_SO_QUOTATION_DT_EXIST 'Could not delete When Quotation Detail Exist';

CREATE EXCEPTION E_UPD_QUOTATION_DT 'Could not update SO_QUOTATION_DT';

CREATE EXCEPTION REPL$LICENSE 'Evaluation licence cannot be deleted';

CREATE EXCEPTION REPL$TABLESEXIST 'Cannot delete published Dbs if tables attached';



SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE PROCEDURE CLONETARGET (
    REPLNO INTEGER,
    DBNO INTEGER,
    TGTDBNO INTEGER,
    NEWREPLNO INTEGER,
    NEWDBNO INTEGER,
    NEWTGTDBNO INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE NEW_PROCEDURE (
    AFLAG SMALLINT,
    AYEAR INTEGER,
    AMONTH INTEGER)
RETURNS (
    PURCHASETAX_AMOUNT INTEGER,
    PURCHASEBASE_AMOUNT FLOAT,
    SALETAX_AMOUNT FLOAT,
    SALEBASE_AMOUNT FLOAT,
    REVENUE_AMOUNT FLOAT,
    TAXDIFF_AMOUNT FLOAT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PO_SUPPLIER_UPDATE
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE POST_SODET_TOAR (
    VDOC_NO VARCHAR(15),
    VDOC_DATE TIMESTAMP,
    VCUST_CODE VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REPL$NOTIFY (
    THETYPE INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SALEORDER_REVISION (
    VDATE_FROM TIMESTAMP,
    VDATE_TO TIMESTAMP,
    VDOC_NO VARCHAR(15),
    VDOC_DATE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SO_CUSTOMERS_UPDATE
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SO_SALES_ITEM_REQ_SHEET_I
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_AP_POST_PAYMENT (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AUPDATE_USER VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_AR_POST_CREDIT_NOTE (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    ADEBTOR VARCHAR(10),
    AUPDATE_USER VARCHAR(10),
    AMODE VARCHAR(2))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_AR_POST_INVOICE (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    ADEBTOR VARCHAR(10),
    AUPDATE_USER VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_AR_POST_RECEIPT (
    ADEBTOR VARCHAR(10),
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AUPDATE_USER VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_AUTO_RESET_STOCK_RESERVED (
    AYEAR SMALLINT,
    AMONTH SMALLINT)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_CHECK_UNKNOW_LOT
RETURNS (
    STOCK_CODE VARCHAR(15),
    LOT_CD VARCHAR(15),
    PURCHASE_DATE TIMESTAMP,
    UNKNOW VARCHAR(1))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE X_CLEAN_ORDERREVISION (
    ADATE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_CLOSED_MELT (
    MELT_NO VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_GET_DISPATCH (
    AREVISE_NO VARCHAR(15),
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AFROM_DATE TIMESTAMP,
    ATO_DATE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_GET_LAST_PURCHASE_PRICE (
    ASTOCK_CD VARCHAR(25),
    ALOT_CD VARCHAR(15),
    APURCHASE_DATE TIMESTAMP,
    AREF_NO VARCHAR(15),
    AREF_DATE TIMESTAMP)
RETURNS (
    RET_PRICE FLOAT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE X_GET_MELT_SUMMARY (
    FROM_MELT VARCHAR(10),
    TO_MELT VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_GET_MELT_SUMMARY_REV2012 (
    ADOC_NO VARCHAR(15),
    FROM_MELT VARCHAR(10),
    TO_MELT VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_GET_RESULT_CHECK_PLATE (
    FROM_MELT_NO VARCHAR(10),
    TO_MELT_NO VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_GET_REVENUE (
    AYEAR INTEGER,
    AMONTH INTEGER,
    AFLAG SMALLINT)
RETURNS (
    PURCHASETAX_AMOUNT INTEGER,
    PURCHASEBASE_AMOUNT FLOAT,
    SALETAX_AMOUNT FLOAT,
    SALEBASE_AMOUNT FLOAT,
    REVENUE_AMOUNT FLOAT,
    TAXDIFF_AMOUNT FLOAT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE X_GET_SALEITEM_COMPONENTS (
    ACUST_CODE VARCHAR(10),
    AITEM_CODE VARCHAR(25))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_GET_STOCK
RETURNS (
    STOCK_CD VARCHAR(15),
    GROUP_ID VARCHAR(10),
    UOM_CD VARCHAR(4),
    LOT_CD VARCHAR(15),
    PURCHASE_DATE TIMESTAMP,
    REF_NO VARCHAR(15),
    REF_DATE TIMESTAMP,
    ADJ_QTY NUMERIC(12,2),
    ONHAND_QTY NUMERIC(12,2),
    ACCT_CD VARCHAR(10),
    UNIT_COST FLOAT,
    ADJUST_FLAG VARCHAR(1))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE X_GET_UNDUE_ONHAND_LOT (
    ADATE DATE)
RETURNS (
    PURCHASEYEAR SMALLINT,
    STOCK_CD VARCHAR(15),
    LOT_NO VARCHAR(15),
    PURCHASE_DATE DATE,
    REF_NO VARCHAR(15),
    REF_DATE DATE,
    ONHAND_QTY FLOAT,
    CARDQTY FLOAT,
    UPDATEQTY FLOAT,
    UNDUE VARCHAR(1))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE X_INS_AP_CREDITOR
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_INS_DISPATCH_DT (
    ADOC_NO VARCHAR(15),
    ADOC_DATE DATE,
    ADELIVERY_DATE DATE)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_INS_PL_REQ_DT (
    ADOC_NO VARCHAR(15),
    ADOC_DATE DATE,
    APLAN_DOC VARCHAR(15),
    AMELT_NO VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_INS_SALES_LEDGER (
    DOC_NO VARCHAR(15),
    DOC_DATE TIMESTAMP,
    MODULE VARCHAR(2),
    MODE VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_INS_SO_ORDER (
    CUST_CODE VARCHAR(10),
    ORDER_NO VARCHAR(15),
    ORDER_DATE TIMESTAMP,
    DOC_NO VARCHAR(15),
    DOC_DATE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_INS_STOCKCARD (
    ACCT_CD VARCHAR(10),
    DOC_NO VARCHAR(15),
    DOC_DATE TIMESTAMP,
    UPDATE_USER VARCHAR(10),
    MODULE VARCHAR(2),
    MODE VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_IS_PREV_MELT_POSTED (
    APLAN_DOC VARCHAR(15),
    APLAN_DATE TIMESTAMP,
    AMELT_NO VARCHAR(10))
RETURNS (
    RESULT VARCHAR(3))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE X_MONTHLY_CLOSE (
    AYEAR SMALLINT,
    AMONTH SMALLINT,
    AUSERID VARCHAR(15))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_PATCH_QA_INSPECT_DATA
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE "x_patch_zero_unitcost_card"
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_PL_GET_MELT (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AMELT_SUFFIX VARCHAR(4),
    ACAP FLOAT,
    ASTART_MELT SMALLINT,
    ATOTAL_MELT SMALLINT)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_PLAN_CLOSE (
    PLAN_DOC VARCHAR(15),
    PLAN_DATE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_PO_AUTOMATIC_CLOSE (
    ADAYS SMALLINT)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_PO_ORDER_STATUS (
    SUPP_CODE VARCHAR(10),
    ORDER_NO VARCHAR(15),
    ORDER_DATE TIMESTAMP,
    STATUS VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_PO_UPD_STOCK_EMPTY
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_PO_UPDATE_GRN_QTY (
    ASUPP_CODE VARCHAR(10),
    AORDER_NO VARCHAR(15),
    AORDER_DATE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_POST_DET (
    VDOC_NO VARCHAR(15),
    VDOC_DATE DATE,
    VCUST_CODE VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_POST_DROSS_RECEIVE (
    AMELT_NO VARCHAR(10),
    ARECEIVE_DOC VARCHAR(15),
    AUSERID VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_POST_FNG_ADJUST (
    DOC_NO VARCHAR(15),
    DOC_DATE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_POST_FNG_RECEIVE (
    DOC_NO VARCHAR(15),
    DOC_DATE DATE)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_POST_FNG_RETURN (
    DOC_NO VARCHAR(15),
    DOC_DATE DATE)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_POST_GRN (
    ACCT_CD VARCHAR(10),
    DOC_NO VARCHAR(15),
    DOC_DATE TIMESTAMP,
    UPDATE_USER VARCHAR(10),
    MODULE VARCHAR(2),
    MODE VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_POST_MAT_STOCK_ADJUST (
    DOC_NO VARCHAR(15),
    DOC_DATE DATE,
    MODULE VARCHAR(2))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_POST_MATERIAL (
    ACCT_CD VARCHAR(10),
    DOC_NO VARCHAR(15),
    DOC_DATE DATE,
    UPDATE_USER VARCHAR(10),
    MODULE VARCHAR(2),
    MODE VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_POST_PHYSICAL_COUNT (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_POST_STOCK_ADJUST (
    DOC_NO VARCHAR(15),
    DOC_DATE DATE,
    MODULE VARCHAR(2),
    ADJUST_FLAG VARCHAR(1),
    MODE VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_POST_STOCK_ADJUST_2 (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AMODE VARCHAR(1),
    AMODULE VARCHAR(2),
    AUSERID VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_QUALIFY_STOCK (
    ASTOCK_CODE VARCHAR(15),
    ALOT_CD VARCHAR(15),
    AREF_NO VARCHAR(15),
    AREF_DATE TIMESTAMP)
RETURNS (
    ONHAND_QTY FLOAT,
    RESERVED_QTY FLOAT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE X_RE_UPDATE_SO_HD_STATUS
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_RECAL_STOCK (
    AFROM_DATE DATE,
    ATO_DATE DATE)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_RECAL_STOCK_VALUE (
    LOT_NO VARCHAR(15),
    STOCK_CD VARCHAR(15))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_RESET_RESERVED (
    ADOC_NO VARCHAR(15))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_SO_CLONE_QUOTATION (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    NEWDOC_NO VARCHAR(15),
    NEWDOC_DATE TIMESTAMP,
    AUSERID VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_SO_DUPLICATE_SALE_ITEM (
    AOLDITEM VARCHAR(15),
    ANEWITEM VARCHAR(15),
    ACUSTCODE VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_SO_GEN_REVISION_DT (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AFROM_DATE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_SO_ORDER_STATUS (
    CUST_CODE VARCHAR(10),
    ORDER_NO VARCHAR(15),
    ORDER_DATE TIMESTAMP,
    STATUS VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_SO_QUO_STATUS (
    CUST_CODE VARCHAR(10),
    DOC_NO VARCHAR(15),
    DOC_DATE TIMESTAMP,
    STATUS VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_SO_QUOTATION_HD_VALIDATE (
    VNOW DATE)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_SO_UPD_ITEM_STATUS (
    AORDER_NO VARCHAR(15),
    AORDER_DATE DATE,
    ACUST_CODE VARCHAR(10),
    AITEM_CODE VARCHAR(15),
    ASTATUS VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_SO_UPD_RESERVED (
    AMELT_NO VARCHAR(10),
    AITEM_CODE VARCHAR(15),
    ADOC_NO VARCHAR(15),
    ADOC_DATE DATE)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_SYS_IMPORT_MENUS (
    AUSERID VARCHAR(10),
    AMODULEID VARCHAR(4))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_U_SALE_REQ_CUST_SHEET
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_UPD_PL_STIME (
    PLAN_DOC VARCHAR(15),
    PLAN_DATE TIMESTAMP,
    LINE_NO SMALLINT,
    UPD_TIME TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_UPD_PURCHASE_DATE
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_UPD_REMELT_COST
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_UPD_STOCK_RESERVED (
    STOCK_CODE VARCHAR(15),
    GROUP_ID VARCHAR(10),
    UOM_CD VARCHAR(4),
    LOT_CD VARCHAR(15),
    PURCHASE_DATE DATE,
    GRN_NO VARCHAR(15),
    GRN_DATE DATE,
    SUPP_CODE VARCHAR(10),
    QTY FLOAT)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_UPD_STOCKCARD_PURCHASE_DATE
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_UPD_STOCKRESERVE (
    ASTOCK_CD VARCHAR(15),
    ALOT_CD VARCHAR(15),
    APURCHAE_DATE TIMESTAMP,
    AREF_NO VARCHAR(15),
    AREF_DATE TIMESTAMP,
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AUSER_ID VARCHAR(10),
    AQTY FLOAT,
    AMODE VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_UPDATE_ELEMENT_LABEL (
    ACUSTCODE VARCHAR(10),
    AITEMCODE VARCHAR(15),
    ALABELONLY VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE X_UPDATE_OLD_PC_DATE
AS
BEGIN
  EXIT;
END^



SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE AP_CREDITOR (
    CREDITOR_ACCT    VARCHAR10 NOT NULL,
    NAME             VARCHAR60,
    CREDITOR_TYPE    VARCHAR2 NOT NULL,
    ADDRESS1         VARCHAR60,
    ADDRESS2         VARCHAR60,
    ADDRESS3         VARCHAR60,
    TELPHONE         VARCHAR30,
    FAX_NO           VARCHAR30,
    SHORT_NAME       VARCHAR45,
    CREDIT_TERM      SSMALLINT NOT NULL,
    TAX_REGISTED_NO  VARCHAR15,
    BALANCE_AMT      FFLOAT,
    CREDIT_LIMIT     FFLOAT,
    CURRENCY_CODE    VARCHAR4 NOT NULL,
    MAILADDR1        VARCHAR60,
    MAILADDR2        VARCHAR60,
    MAILADDR3        VARCHAR60,
    UPDATE_USER      VARCHAR10,
    UPDATE_DATE      TIMESTAMP,
    TAX_CD           VARCHAR2 NOT NULL,
    PROVINCE         VARCHAR30 NOT NULL,
    POSTCODE         VARCHAR(10) NOT NULL,
    TH_ADDR1         VARCHAR60,
    TH_ADDR2         VARCHAR60,
    TH_ADDR3         VARCHAR60,
    TH_NAME          VARCHAR(150)
);

CREATE TABLE AP_CREDITOR_TYPE (
    CREDITOR_TYPE  VARCHAR2 NOT NULL,
    DESCS          VARCHAR60 NOT NULL,
    UPDATE_USER    VARCHAR10,
    UPDATE_DATE    TIMESTAMP
);

CREATE TABLE AP_INVOICE_DT (
    CREDITOR_ACCT  VARCHAR10 NOT NULL,
    DOC_NO         VARCHAR15 NOT NULL,
    DOC_DATE       DDATE NOT NULL,
    TRX_TYPE       VARCHAR2 NOT NULL,
    DESCS          VARCHAR60,
    TAX_AMT        FFLOAT,
    DOC_AMT        FFLOAT NOT NULL,
    BASE_AMT       FFLOAT NOT NULL,
    REF_DATE       DDATE,
    REF_NO         DDATE,
    TAX_CD         VARCHAR(4) NOT NULL
);

CREATE TABLE AP_INVOICE_HD (
    CREDITOR_ACCT   VARCHAR10 NOT NULL,
    DOC_NO          VARCHAR15 NOT NULL,
    DOC_DATE        DDATE NOT NULL,
    TRX_TYPE        VARCHAR2 NOT NULL,
    TAX_INV_NO      VARCHAR15,
    TAX_INV_DATE    DDATE,
    DESCS           VARCHAR60,
    DEBT_NAME       VARCHAR60,
    DOC_AMT         FFLOAT NOT NULL,
    BASE_AMT        FFLOAT NOT NULL,
    UPDATE_USER     VARCHAR10,
    UPDATE_DATE     TIMESTAMP,
    REMARK          VARCHAR(255),
    BAHT_TEXT       VARCHAR(200),
    TAX_AMT         FLOAT,
    STATUS          VARCHAR(1) DEFAULT 'N',
    RECEIPT_STATUS  VARCHAR(1) DEFAULT 'N'
);

CREATE TABLE AP_LEDGER (
    DOC_NO         VARCHAR15 NOT NULL,
    DOC_DATE       DDATE NOT NULL,
    REF_NO         VARCHAR15 NOT NULL,
    FMONTH         SSMALLINT NOT NULL,
    CREDITOR_ACCT  VARCHAR10 NOT NULL,
    FYEAR          SSMALLINT NOT NULL,
    CURRENCY_CODE  VARCHAR4 NOT NULL,
    CREDITOR_TYPE  VARCHAR2 NOT NULL,
    CURRENCY_RATE  FFLOAT NOT NULL,
    MBASE_AMT      FFLOAT NOT NULL,
    MTAX_AMT       FFLOAT NOT NULL,
    MDOC_AMT       FFLOAT NOT NULL,
    FBASE_AMT      FFLOAT NOT NULL,
    FTAX_AMT       FFLOAT NOT NULL,
    FDOC_AMT       FFLOAT NOT NULL,
    MALLOC_AMT     FFLOAT NOT NULL,
    FALLOC_AMT     FFLOAT NOT NULL,
    MBAL_AMT       FFLOAT NOT NULL,
    TAX_INV_NO     VARCHAR15 NOT NULL,
    TRX_TYPE       VARCHAR2 NOT NULL,
    DR_CR_MODE     FLAG NOT NULL,
    FBAL_AMT       FFLOAT,
    CLASS          FLAG,
    BANK_CD        VARCHAR4,
    UPDATE_USER    VARCHAR10,
    UPDATE_DATE    TIMESTAMP,
    REF_DATE       TIMESTAMP NOT NULL,
    DESCS          VARCHAR(150)
);

CREATE TABLE AP_PAY_DT (
    CREDITOR_ACCT  VARCHAR10 NOT NULL,
    DOC_NO         VARCHAR15 NOT NULL,
    DOC_DATE       DDATE NOT NULL,
    TRX_TYPE       VARCHAR2 NOT NULL,
    TAX_INV_NO     VARCHAR15,
    TAX_INV_DATE   DDATE,
    REF_NO         VARCHAR15,
    REF_DATE       DDATE,
    DESCS          VARCHAR60,
    DEBT_NAME      VARCHAR60,
    DOC_AMT        FFLOAT NOT NULL,
    BASE_AMT       FFLOAT NOT NULL,
    INV_NO         VARCHAR15 NOT NULL,
    INV_DATE       DDATE NOT NULL
);

CREATE TABLE AP_PAY_HD (
    CREDITOR_ACCT  VARCHAR10 NOT NULL,
    DOC_NO         VARCHAR15 NOT NULL,
    DOC_DATE       DDATE NOT NULL,
    TRX_TYPE       VARCHAR2 NOT NULL,
    TAX_INV_NO     VARCHAR15,
    TAX_INV_DATE   DDATE,
    REF_NO         VARCHAR15,
    REF_DATE       DDATE,
    DESCS          VARCHAR60,
    DEBT_NAME      VARCHAR60,
    DOC_AMT        FFLOAT NOT NULL,
    BANK_CD        VARCHAR4 NOT NULL,
    BASE_AMT       FFLOAT NOT NULL,
    UPDATE_USER    VARCHAR10,
    UPDATE_DATE    TIMESTAMP
);

CREATE TABLE AP_PAYMENT_DT (
    DOC_NO         VARCHAR(15) NOT NULL,
    DOC_DATE       TIMESTAMP NOT NULL,
    TRX_TYPE       VARCHAR(2) NOT NULL,
    CREDITOR_ACCT  VARCHAR(10) NOT NULL,
    LINE_NO        SMALLINT NOT NULL,
    INVOICE_NO     VARCHAR(15),
    INVOICE_DATE   TIMESTAMP,
    LINE_DESCS     VARCHAR(60),
    LINE_REMARK    VARCHAR(255),
    TAX_CODE       VARCHAR(2),
    TAX_RATE       FLOAT,
    TAX_AMOUNT     FLOAT,
    WHTAX_CODE     VARCHAR(2),
    WHTAX_RATE     FLOAT,
    WHTAX_AMOUNT   FLOAT,
    BASE_AMOUNT    FLOAT,
    TOTAL_AMOUNT   FLOAT
);

CREATE TABLE AP_PAYMENT_HD (
    DOC_NO         VARCHAR(15) NOT NULL,
    DOC_DATE       TIMESTAMP NOT NULL,
    TRX_TYPE       VARCHAR(2) NOT NULL,
    CREDITOR_ACCT  VARCHAR(10) NOT NULL,
    REF_NO         VARCHAR(15),
    REF_DATE       TIMESTAMP,
    DESCS          VARCHAR(60),
    REMARK         VARCHAR(150),
    BANK_CODE      VARCHAR(4),
    CURRENCY_CODE  VARCHAR(4),
    BATHTEXT       VARCHAR(255),
    STATUS         VARCHAR(1),
    UPDATE_USER    VARCHAR(10),
    UPDATE_DATE    TIMESTAMP
);

CREATE TABLE AR_CREDIT_NOTE_DT (
    DEBTOR_ACCT     VARCHAR10 NOT NULL,
    DOC_NO          VARCHAR15 NOT NULL,
    DOC_DATE        DDATE NOT NULL,
    TRX_TYPE        VARCHAR2 NOT NULL,
    LINE_NO         SMALLINT NOT NULL,
    INVOICE_NO      VARCHAR(15) NOT NULL,
    INVOICE_DATE    TIMESTAMP NOT NULL,
    ITEM_CODE       VARCHAR(15) NOT NULL,
    ITEM_DESCS      VARCHAR(60),
    UOM_CD          VARCHAR(4),
    UNIT_COST       FLOAT,
    INVOICE_AMOUNT  FLOAT,
    TAX_AMOUNT      FLOAT,
    VARIANT_AMOUNT  FLOAT,
    BASE_AMOUNT     FLOAT,
    TOTAL_AMOUNT    FLOAT,
    QTY             FLOAT
);

CREATE TABLE AR_CREDIT_NOTE_HD (
    DOC_NO         VARCHAR15 NOT NULL,
    DOC_DATE       TIMESTAMP NOT NULL,
    DEBTOR_ACCT    VARCHAR10 NOT NULL,
    TRX_TYPE       VARCHAR2 NOT NULL,
    DESCS          VARCHAR(60),
    DEBT_NAME      VARCHAR60,
    REMARK         VARCHAR(255),
    NO_OF_PRINT    SMALLINT DEFAULT 0,
    BATHTEXT       VARCHAR(255),
    CURRENCY_CODE  VARCHAR(4),
    CURRENCY_RATE  FLOAT,
    STATUS         VARCHAR(1) DEFAULT 'N',
    MODE           VARCHAR(1) DEFAULT '',
    UPDATE_USER    VARCHAR(10),
    UPDATE_DATE    TIMESTAMP
);

CREATE TABLE AR_DEBTOR (
    DEBTOR_ACCT      VARCHAR10 NOT NULL,
    NAME             VARCHAR60,
    ADDRESS1         VARCHAR60,
    ADDRESS2         VARCHAR60,
    ADDRESS3         VARCHAR60,
    TELPHONE         VARCHAR30,
    FAX_NO           VARCHAR30,
    DEBTOR_TYPE      VARCHAR2 NOT NULL,
    SHORT_NAME       VARCHAR45,
    CREDIT_TERM      SSMALLINT NOT NULL,
    TAX_REGISTED_NO  VARCHAR15,
    BALANCE_AMT      FFLOAT,
    CREDIT_LIMIT     FFLOAT,
    CURRENCY_CODE    VARCHAR4 NOT NULL,
    MAILADDR1        VARCHAR60,
    MAILADDR2        VARCHAR60,
    MAILADDR3        VARCHAR60,
    UPDATE_USER      VARCHAR10,
    UPDATE_DATE      TIMESTAMP,
    TAX_CD           VARCHAR2 NOT NULL,
    POSTCODE         VARCHAR10 NOT NULL,
    PROVINCE         VARCHAR30 NOT NULL,
    TH_ADDR1         VARCHAR60,
    TH_ADDR2         VARCHAR60,
    TH_ADDR3         VARCHAR60,
    TH_NAME          VARCHAR(150)
);

CREATE TABLE AR_DEBTOR_TYPE (
    DEBTOR_TYPE  VARCHAR2 NOT NULL,
    DESCS        VARCHAR60 NOT NULL,
    UPDATE_USER  VARCHAR10,
    UPDATE_DATE  TIMESTAMP
);

CREATE TABLE AR_INVOICE_DT (
    DEBTOR_ACCT    VARCHAR10 NOT NULL,
    DOC_NO         VARCHAR15 NOT NULL,
    DOC_DATE       DDATE NOT NULL,
    TRX_TYPE       VARCHAR2 NOT NULL,
    DESCS          VARCHAR60,
    TAX_AMT        DOUBLES,
    DOC_AMT        DOUBLES NOT NULL,
    BASE_AMT       DOUBLES NOT NULL,
    ITEM_CODE      VARCHAR(15) NOT NULL,
    ITEM_DESCS     VARCHAR(60),
    QTY            FFLOAT,
    UNIT_COST      FFLOAT,
    UNIT_DESCS     VARCHAR(45),
    ORDER_NO       VARCHAR(15) NOT NULL,
    ORDER_DATE     TIMESTAMP NOT NULL,
    TAX_RATE       FFLOAT,
    PURCHASE_NO    VARCHAR(15) NOT NULL,
    PURCHASE_DATE  TIMESTAMP NOT NULL,
    DELIVERY_NO    VARCHAR(30) NOT NULL,
    DELIVERY_DATE  TIMESTAMP NOT NULL,
    TH_BAHT        VARCHAR(500),
    UPDATE_USER    VARCHAR(30),
    UPDATE_DATE    TIMESTAMP,
    LINE_NO        SMALLINT NOT NULL
);

CREATE TABLE AR_INVOICE_HD (
    DEBTOR_ACCT        VARCHAR10 NOT NULL,
    DOC_NO             VARCHAR15 NOT NULL,
    DOC_DATE           DDATE NOT NULL,
    TRX_TYPE           VARCHAR2 NOT NULL,
    TAX_INV_NO         VARCHAR15,
    TAX_INV_DATE       DDATE,
    DEBT_NAME          VARCHAR60,
    REMARK             VARCHAR(255),
    STATUS             VARCHAR(1) DEFAULT 'N',
    RECEIPT_STATUS     VARCHAR(1) DEFAULT 'N',
    DUE_DATE           TIMESTAMP,
    CREDIT_TERM        SMALLINT,
    NO_OF_PRINT        SMALLINT DEFAULT 0,
    UPDATE_USER        VARCHAR(30),
    UPDATE_DATE        TIMESTAMP,
    DESCS              VARCHAR(60),
    BATHTEXT           VARCHAR(255),
    CURRENCY_CODE      VARCHAR(4),
    CURRENCY_RATE      FLOAT,
    REQUIRE_REFERENCE  VARCHAR(1)
);

CREATE TABLE AR_LEDGER (
    DEBT_ACCT      VARCHAR10 NOT NULL,
    DOC_NO         VARCHAR15 NOT NULL,
    DOC_DATE       DDATE NOT NULL,
    DEBTOR_ACCT    VARCHAR10 NOT NULL,
    REF_NO         VARCHAR15 NOT NULL,
    REF_DATE       TIMESTAMP NOT NULL,
    FMONTH         SSMALLINT NOT NULL,
    DEBTOR_TYPE    VARCHAR2 NOT NULL,
    TRX_TYPE       VARCHAR2 NOT NULL,
    FYEAR          SSMALLINT NOT NULL,
    CURRENCY_CODE  VARCHAR4 NOT NULL,
    CURRENCY_RATE  FFLOAT NOT NULL,
    MBASE_AMT      DOUBLES NOT NULL,
    MTAX_AMT       DOUBLES NOT NULL,
    MDOC_AMT       DOUBLES NOT NULL,
    FBASE_AMT      DOUBLES NOT NULL,
    FTAX_AMT       DOUBLES NOT NULL,
    FDOC_AMT       DOUBLES NOT NULL,
    MALLOC_AMT     DOUBLES NOT NULL,
    FALLOC_AMT     DOUBLES NOT NULL,
    MBAL_AMT       DOUBLES NOT NULL,
    TAX_INV_NO     VARCHAR15 NOT NULL,
    CLASS          FLAG NOT NULL,
    DR_CR_MODE     FLAG NOT NULL,
    FBAL_AMT       DOUBLES,
    BANK_CD        VARCHAR4,
    UPDATE_USER    VARCHAR10,
    UPDATE_DATE    TIMESTAMP,
    DESCS          VARCHAR60,
    TAX_RATE       FLOAT
);

CREATE TABLE AR_PAY_DT (
    DEBTOR_ACCT   VARCHAR10 NOT NULL,
    DOC_NO        VARCHAR15 NOT NULL,
    DOC_DATE      DDATE NOT NULL,
    TRX_TYPE      VARCHAR2 NOT NULL,
    TAX_INV_NO    VARCHAR15,
    TAX_INV_DATE  DDATE,
    REF_NO        VARCHAR15,
    REF_DATE      DDATE,
    DESCS         VARCHAR60,
    DEBT_NAME     VARCHAR60,
    DOC_AMT       FFLOAT NOT NULL,
    BASE_AMT      FFLOAT NOT NULL,
    INV_NO        VARCHAR15 NOT NULL,
    INV_DATE      DDATE NOT NULL
);

CREATE TABLE AR_PAY_HD (
    DEBTOR_ACCT   VARCHAR10 NOT NULL,
    DOC_NO        VARCHAR15 NOT NULL,
    DOC_DATE      DDATE NOT NULL,
    TRX_TYPE      VARCHAR2 NOT NULL,
    TAX_INV_NO    VARCHAR15,
    TAX_INV_DATE  DDATE,
    REF_NO        VARCHAR15,
    REF_DATE      DDATE,
    DESCS         VARCHAR60,
    DEBT_NAME     VARCHAR60,
    DOC_AMT       FFLOAT NOT NULL,
    BANK_CD       VARCHAR4 NOT NULL,
    BASE_AMT      FFLOAT NOT NULL,
    UPDATE_USER   VARCHAR10,
    UPDATE_DATE   TIMESTAMP
);

CREATE TABLE AR_RECEIPT_DT (
    DOC_NO       VARCHAR(15) NOT NULL,
    DOC_DATE     DATE NOT NULL,
    DEBTOR_ACCT  VARCHAR(10) NOT NULL,
    LINE_NO      SMALLINT NOT NULL,
    INV_NO       VARCHAR(15) NOT NULL,
    INV_DATE     DATE NOT NULL,
    LINE_REMARK  VARCHAR(60),
    BASE_AMOUNT  DOUBLES NOT NULL,
    TAX_AMOUNT   DOUBLES NOT NULL,
    TRX_AMOUNT   DOUBLES NOT NULL,
    STATUS       VARCHAR(1),
    DUE_DATE     TIMESTAMP NOT NULL,
    REF_NO       VARCHAR(15) NOT NULL,
    REF_DATE     TIMESTAMP NOT NULL,
    UNIT_COST    FLOAT,
    QTY          FLOAT,
    WH_AMOUNT    FLOAT,
    WH_RATE      FLOAT,
    TAX_RATE     FLOAT
);

CREATE TABLE AR_RECEIPT_HD (
    DOC_NO             VARCHAR(15) NOT NULL,
    DOC_DATE           TIMESTAMP NOT NULL,
    DESCS              VARCHAR(60),
    BANK_CODE          VARCHAR(4) NOT NULL,
    DEBTOR_ACCT        VARCHAR(10) NOT NULL,
    CHEQUE_NO          VARCHAR(25) NOT NULL,
    REMARKS            VARCHAR(255),
    STATUS             VARCHAR(1),
    PRINT_STATUS       VARCHAR(1),
    UPDATE_USER        VARCHAR(10),
    UPDATE_DATE        TIMESTAMP,
    CURRENCY_CODE      VARCHAR(4) NOT NULL,
    CURRENCY_RATE      FLOAT,
    BATHTEXT           VARCHAR(255),
    TRX_TYPE           VARCHAR(2) NOT NULL,
    REQUIRE_REFERENCE  VARCHAR(1) DEFAULT 'N'
);

CREATE TABLE BANK (
    BANK_CODE    VARCHAR4 NOT NULL,
    BANK_NAME    VARCHAR60,
    BRANCH_NAME  VARCHAR60,
    REMARKS      VARCHAR60,
    UPDATE_USER  VARCHAR10,
    UPDATE_DATE  TIMESTAMP
);

CREATE TABLE BRD_REPORT_PARAMS (
    KEYVAR15      VARCHAR(15),
    KEYVARDATE    TIMESTAMP,
    KEYVAR10      VARCHAR(10),
    FLOATVALUE1   FLOAT,
    FLOATVALUE2   FLOAT,
    FLOATVALUE3   FLOAT,
    FLOATVALUE4   FLOAT,
    FLOATVALUE5   FLOAT,
    FLOATVALUE6   FLOAT,
    FLOATVALUE7   FLOAT,
    FLOATVALUE8   FLOAT,
    FLOATVALUE9   FFLOAT,
    FLOATVALUE10  FFLOAT,
    FLOATVALUE11  FFLOAT,
    FLOATVALUE12  FFLOAT,
    STRVALUE1     VARCHAR(60),
    MEMOVALUE1    VARCHAR(255),
    FLOATVALUE13  FFLOAT,
    FLOATVALUE14  FFLOAT,
    FLOATVALUE15  FFLOAT,
    FLOATVALUE16  FFLOAT,
    FLOATVALUE17  FFLOAT,
    FLOATVALUE18  FFLOAT,
    FLOATVALUE19  FFLOAT,
    FLOATVALUE20  FFLOAT,
    FLOATVALUE21  FFLOAT,
    FLOATVALUE22  FFLOAT,
    FLOATVALUE23  FFLOAT,
    FLOATVALUE24  FFLOAT,
    FLOATVALUE25  FFLOAT
);

CREATE TABLE COMPANY_PROFILE (
    ENG_NAME          VARCHAR(150) NOT NULL,
    THAI_NAME         VARCHAR(150) NOT NULL,
    ADDRESS1          VARCHAR(100) NOT NULL,
    ADDRESS2          VARCHAR(100),
    ADDRESS3          VARCHAR(100),
    TH_ADDRESS1       VARCHAR(100) NOT NULL,
    TH_ADDRESS2       VARCHAR(100),
    TH_ADDRESS3       VARCHAR(100),
    POSTCODE          VARCHAR(10) NOT NULL,
    PROVINCE          VARCHAR(60) NOT NULL,
    TELEPHONE         VARCHAR(60) NOT NULL,
    FAX               VARCHAR(60),
    LOGO              BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    EMAIL             VARCHAR(60),
    WEBSITE           VARCHAR(60),
    TAXREGISTERED_ID  VARCHAR(25)
);

CREATE TABLE COMPOSITIONCONTROL (
    COMPOSITIONCONTROLID          SMALLINT NOT NULL,
    COMPOSITIONCONTROLNAME        VARCHAR(60),
    COMPOSITIONCONTROLSTARTINDEX  SMALLINT default 1,
    COMPOSITIONCONTROLENDINDEX    SMALLINT DEFAULT 12,
    COMPOSITIONCONTROLCODE        VARCHAR(4) DEFAULT 'Al',
    COMPOSITIONACTIVE             VARCHAR(1) DEFAULT 'N',
    REMELTRECOVERYPERCENTAGE      FLOAT default 98.5
);

CREATE TABLE CURRENCY (
    CURRENCY_CODE  VARCHAR4 NOT NULL,
    CURRENCY_RATE  FFLOAT NOT NULL,
    DESCS          VARCHAR30,
    BASE_RATE      FFLOAT,
    COMPARE_RATE   FFLOAT,
    UPDATE_USER    VARCHAR10,
    UPDATE_DATE    TIMESTAMP
);

CREATE TABLE CUSTOMER_REQUIREMENT (
    CUST_CODE        VARCHAR(10) NOT NULL,
    REQUIREMENTNOTE  VARCHAR(2500),
    UPDATE_USER      VARCHAR(10),
    UPDATE_DATE      TIMESTAMP
);

CREATE TABLE DATABASES (
    DBNO            INTEGER NOT NULL,
    DBPATH          VARCHAR(254),
    DBNAME          VARCHAR(100),
    ADMINUSER       VARCHAR(50),
    ADMINPASSWORD   VARCHAR(50),
    COMMENTS        VARCHAR(1000),
    PRIORITY        INTEGER DEFAULT 0 NOT NULL,
    TIMEFIELDNAME   VARCHAR(20),
    CHARSET         VARCHAR(20) DEFAULT '' NOT NULL,
    DBTYPE          INTEGER DEFAULT 0 NOT NULL,
    X               INTEGER DEFAULT -1,
    Y               INTEGER DEFAULT -1,
    USERROLE        VARCHAR(50),
    DIALECT         INTEGER DEFAULT 1,
    DIALUSERNAME    VARCHAR(20),
    DIALPASSWORD    VARCHAR(20),
    RASNAME         VARCHAR(20),
    KEEPCONNECTION  INTEGER DEFAULT 0 NOT NULL
);

CREATE TABLE DBVERSIONS (
    VERSIONS         VARCHAR15 NOT NULL,
    LASTUPDATE       TIMESTAMP NOT NULL,
    UPGRADE_MACHINE  VARCHAR(100) NOT NULL
);

CREATE TABLE DISCOUNT (
    DISCS_CD     VARCHAR2 NOT NULL,
    DESCS        CHAR(18),
    DISCS_DESCS  VARCHAR60,
    DISCS_RATE   FFLOAT NOT NULL
);

CREATE TABLE DOCUMENT_CONTROL (
    TRX_TYPE       VARCHAR2 NOT NULL,
    DESCS          VARCHAR30 NOT NULL,
    CLASS          FLAG NOT NULL,
    MANUAL_FLAG    FLAG,
    RUNING_NUMBER  SSMALLINT,
    PREFIX         VARCHAR2
);

CREATE TABLE IC_BALANCE_FORWARD (
    STOCK_CD             VARCHAR15 NOT NULL,
    GROUP_ID             VARCHAR10 NOT NULL,
    UOM_CD               VARCHAR4 NOT NULL,
    LOT_CD               VARCHAR15 NOT NULL,
    UNIT_COST            FFLOAT NOT NULL,
    LAST_PURCHASE_PRICE  FFLOAT NOT NULL,
    PURCHASE_DATE        DDATE NOT NULL,
    ONHAND_QTY           FFLOAT NOT NULL,
    RESERVED_QTY         FFLOAT NOT NULL,
    STOCK_VALUE          FFLOAT,
    TOTAL_COST           FFLOAT,
    ACCT_CODE            VARCHAR(10) NOT NULL,
    ORDER_LINE           SMALLINT NOT NULL,
    REF_NO               VARCHAR15 NOT NULL,
    REF_DATE             TIMESTAMP NOT NULL,
    BF_YEAR              SMALLINT NOT NULL,
    BF_MONTH             SMALLINT NOT NULL,
    DOC_DATE             TIMESTAMP NOT NULL
);

CREATE TABLE IC_DEFINEDGROUP (
    DEF_CODE     VARCHAR(10) NOT NULL,
    USER_ID      VARCHAR(10) NOT NULL,
    STOCK_GROUP  VARCHAR(4) NOT NULL,
    DEF_DESCS    VARCHAR(100),
    UPDATE_DATE  DATE
);

CREATE TABLE IC_ELEMENT (
    RUN_NO             SSMALLINT NOT NULL,
    ELEMENT_CODE       VARCHAR(4) NOT NULL,
    NAME               VARCHAR(60),
    UPDATE_USER        VARCHAR(10),
    UPDATE_DATE        TIMESTAMP,
    ELEMENT_LOCKED     VARCHAR(1),
    ELEMENT_ACTIVE     VARCHAR(1),
    ELEMENT_CONTROLED  VARCHAR(1)
);

CREATE TABLE IC_ELEMENT_LABEL (
    ELABEL1   VARCHAR(4),
    ELABEL2   VARCHAR(4),
    ELABEL3   VARCHAR(4),
    ELABEL4   VARCHAR(4),
    ELABEL5   VARCHAR(4),
    ELABEL6   VARCHAR(4),
    ELABEL7   VARCHAR(4),
    ELABEL8   VARCHAR(4),
    ELABEL9   VARCHAR(4),
    ELABEL10  VARCHAR(4),
    ELABEL11  VARCHAR(4),
    ELABEL12  VARCHAR(4),
    ELABEL13  VARCHAR(4),
    ELABEL14  VARCHAR(4),
    ELABEL15  VARCHAR(4),
    ELABEL16  VARCHAR(4),
    ELABEL17  VARCHAR(4),
    ELABEL18  VARCHAR(4),
    ELABEL19  VARCHAR(4),
    ELABEL20  VARCHAR(4),
    ELABEL21  VARCHAR(4),
    ELABEL22  VARCHAR(4),
    ELABEL23  VARCHAR(4),
    ELABEL24  VARCHAR(4),
    ELABEL25  VARCHAR(4)
);

CREATE TABLE IC_GROUP (
    GROUP_ID     VARCHAR10 NOT NULL,
    DESCS        VARCHAR60 NOT NULL,
    REMARKS      VARCHAR60,
    UPDATE_USER  VARCHAR10,
    UPDATE_DATE  TIMESTAMP
);

CREATE TABLE IC_MAT_DEFAULT_ELEMENT (
    STOCK_CD    VARCHAR15 NOT NULL,
    GROUP_ID    VARCHAR10 NOT NULL,
    UOM_CD      VARCHAR4 NOT NULL,
    ELE1_PERC   FLOAT,
    ELE2_PERC   FLOAT,
    ELE3_PERC   FLOAT,
    ELE4_PERC   FLOAT,
    ELE5_PERC   FLOAT,
    ELE6_PERC   FLOAT,
    ELE7_PERC   FLOAT,
    ELE8_PERC   FLOAT,
    ELE9_PERC   FLOAT,
    ELE10_PERC  FLOAT,
    ELE11_PERC  FLOAT,
    ELE12_PERC  FLOAT,
    ELE13_PERC  FLOAT,
    ELE14_PERC  FLOAT,
    ELE15_PERC  FLOAT,
    ELE16_PERC  FLOAT,
    ELE17_PERC  FLOAT,
    ELE18_PERC  FLOAT,
    ELE19_PERC  FLOAT,
    ELE20_PERC  FLOAT,
    ELE21_PERC  FLOAT,
    ELE22_PERC  FLOAT,
    ELE23_PERC  FLOAT,
    ELE24_PERC  FLOAT,
    ELE25_PERC  FLOAT
);

CREATE TABLE IC_MAT_ELEMENT (
    STOCK_CD       VARCHAR15 NOT NULL,
    GROUP_ID       VARCHAR10 NOT NULL,
    UOM_CD         VARCHAR4 NOT NULL,
    LOT_CD         VARCHAR15 NOT NULL,
    PURCHASE_DATE  TIMESTAMP NOT NULL,
    ELE1_PERC      FLOAT,
    ELE2_PERC      FLOAT,
    ELE3_PERC      FLOAT,
    ELE4_PERC      FLOAT,
    ELE5_PERC      FLOAT,
    ELE6_PERC      FLOAT,
    ELE7_PERC      FLOAT,
    ELE8_PERC      FLOAT,
    ELE9_PERC      FLOAT,
    ELE10_PERC     FLOAT,
    ELE11_PERC     FLOAT,
    ELE12_PERC     FLOAT,
    ELE13_PERC     FLOAT,
    ACCT_CD        VARCHAR(10) NOT NULL,
    REF_NO         VARCHAR(15),
    REF_DATE       TIMESTAMP,
    LINE_NO        SSMALLINT DEFAULT 1 NOT NULL,
    ELE14_PERC     FLOAT,
    ELE15_PERC     FLOAT,
    ELE16_PERC     FLOAT,
    ELE17_PERC     FLOAT,
    ELE18_PERC     FLOAT,
    ELE19_PERC     FLOAT,
    ELE20_PERC     FLOAT,
    ELE21_PERC     FLOAT,
    ELE22_PERC     FLOAT,
    ELE23_PERC     FLOAT,
    ELE24_PERC     FLOAT,
    ELE25_PERC     FLOAT
);

CREATE TABLE IC_MAT_STK_DT (
    STOCK_CD             VARCHAR15 NOT NULL,
    GROUP_ID             VARCHAR10 NOT NULL,
    UOM_CD               VARCHAR4 NOT NULL,
    LOT_CD               VARCHAR15 NOT NULL,
    UNIT_COST            FFLOAT NOT NULL,
    LAST_PURCHASE_PRICE  FFLOAT NOT NULL,
    PURCHASE_DATE        DDATE NOT NULL,
    ONHAND_QTY           FFLOAT NOT NULL,
    RESERVED_QTY         FFLOAT NOT NULL,
    STOCK_VALUE          FFLOAT,
    TOTAL_COST           FFLOAT,
    ACCT_CODE            VARCHAR(10) NOT NULL,
    ORDER_LINE           SMALLINT NOT NULL
);

CREATE TABLE IC_MAT_STK_DT_LINK (
    STOCK_CD             VARCHAR15 NOT NULL,
    GROUP_ID             VARCHAR10 NOT NULL,
    UOM_CD               VARCHAR4 NOT NULL,
    LOT_CD               VARCHAR15 NOT NULL,
    UNIT_COST            FFLOAT NOT NULL,
    LAST_PURCHASE_PRICE  FFLOAT NOT NULL,
    PURCHASE_DATE        DDATE NOT NULL,
    ONHAND_QTY           FFLOAT NOT NULL,
    RESERVED_QTY         FFLOAT NOT NULL,
    STOCK_VALUE          FFLOAT,
    TOTAL_COST           FFLOAT,
    ACCT_CODE            VARCHAR(10) NOT NULL,
    ORDER_LINE           SMALLINT NOT NULL,
    REF_NO               VARCHAR15 NOT NULL,
    REF_DATE             TIMESTAMP NOT NULL
);

CREATE TABLE IC_MAT_STK_DT_LINK_TMP (
    STOCK_CD       VARCHAR15 NOT NULL,
    GROUP_ID       VARCHAR10 NOT NULL,
    UOM_CD         VARCHAR4 NOT NULL,
    LOT_CD         VARCHAR15 NOT NULL,
    PURCHASE_DATE  DDATE NOT NULL,
    ONHAND_QTY     FFLOAT NOT NULL,
    RESERVED_QTY   FFLOAT NOT NULL,
    STOCK_VALUE    FFLOAT,
    REF_NO         VARCHAR15 NOT NULL,
    REF_DATE       DATE NOT NULL
);

CREATE TABLE IC_MAT_STK_HD (
    STOCK_CD                VARCHAR15 NOT NULL,
    EN_DESCS                VARCHAR150,
    TH_DESCS                VARCHAR150,
    SHORT_DESCS             VARCHAR45,
    ONHAND_QTY              FFLOAT NOT NULL,
    UNIT_COST               FFLOAT NOT NULL,
    TOTAL_COST              FFLOAT NOT NULL,
    UOM_CD                  VARCHAR4 NOT NULL,
    GROUP_ID                VARCHAR10 NOT NULL,
    RECOVERY                FFLOAT,
    MARKED_UP               FFLOAT,
    UPDATE_USER             VARCHAR10,
    UPDATE_DATE             TIMESTAMP,
    DEFAULT_ELEMENT_DETAIL  FLAG,
    CONSUMEABLE_ITEM        FLAG DEFAULT 'N'
);

CREATE TABLE IC_MONTHLY_CLOSED (
    BF_YEAR      SMALLINT NOT NULL,
    BF_MONTH     SMALLINT NOT NULL,
    CLOSED_DATE  TIMESTAMP,
    CLOSED_BY    VARCHAR(15)
);

CREATE TABLE IC_STOCK_ADJUST_DT (
    ITEM_CODE      VARCHAR(15) NOT NULL,
    UOM_CD         VARCHAR(4) NOT NULL,
    DOC_NO         VARCHAR15 NOT NULL,
    DOC_DATE       TIMESTAMP NOT NULL,
    GROUP_ID       VARCHAR(10) NOT NULL,
    LOT_NO         VARCHAR(15) NOT NULL,
    PURCHASE_DATE  TIMESTAMP NOT NULL,
    QTY            FLOAT,
    UNIT_COST      FLOAT,
    TOTAL_COST     FLOAT,
    ONHAND_QTY     FLOAT,
    STOCK_DESCS    VARCHAR60,
    REF_NO         VARCHAR15 NOT NULL,
    REF_DATE       TIMESTAMP NOT NULL,
    ACCT_CD        VARCHAR(10) NOT NULL,
    VQTY           FLOAT DEFAULT 0.0
);

CREATE TABLE IC_STOCK_ADJUST_HD (
    DOC_NO          VARCHAR15 NOT NULL,
    DOC_DATE        TIMESTAMP NOT NULL,
    MODE            VARCHAR(1) NOT NULL,
    DESCS           VARCHAR(60),
    UPDATE_USER     VARCHAR(10),
    UPDATE_DATE     TIMESTAMP,
    COSTS_ADJUSTED  FLAG,
    QTY_ADJUSTED    FLAG,
    STATUS          FLAG,
    REMARKS         VARCHAR255,
    INIT_ADJUSTED   FLAG,
    MELT_NO         VARCHAR10 NOT NULL,
    TRX_TYPE        VARCHAR2 NOT NULL
);

CREATE TABLE IC_STOCK_ADJUST_LOGS (
    ITEM_CODE           VARCHAR(15) NOT NULL,
    UOM_CD              VARCHAR(4) NOT NULL,
    DOC_NO              VARCHAR15 NOT NULL,
    DOC_DATE            TIMESTAMP NOT NULL,
    GROUP_ID            VARCHAR(10) NOT NULL,
    LOT_NO              VARCHAR(15) NOT NULL,
    ONHAND_QTY          FLOAT,
    ORIGINAL_UNIT_COST  FLOAT,
    UPDATE_UNIT_COST    FLOAT,
    MODE                VARCHAR(1),
    UPDATE_QTY          FLOAT,
    DESCS               VARCHAR60
);

CREATE TABLE IC_STOCK_RESERVED (
    DOC_NO         VARCHAR(15) NOT NULL,
    DOC_DATE       TIMESTAMP NOT NULL,
    LOT_CD         VARCHAR(15) NOT NULL,
    PURCHASE_DATE  TIMESTAMP NOT NULL,
    REF_NO         VARCHAR(15) NOT NULL,
    REF_DATE       TIMESTAMP NOT NULL,
    STOCK_CD       VARCHAR15 NOT NULL,
    GROUP_ID       VARCHAR(10) NOT NULL,
    UOM_CD         VARCHAR4 NOT NULL,
    QTY            FLOAT NOT NULL,
    UPDATE_USER    VARCHAR(10),
    UPDATE_DATE    TIMESTAMP
);

CREATE TABLE IC_STOCKCARD (
    ACCT_CD        VARCHAR10 NOT NULL,
    DOC_NO         VARCHAR15 NOT NULL,
    DOC_DATE       DDATE NOT NULL,
    REF_NO         VARCHAR15 NOT NULL,
    REF_DATE       DDATE NOT NULL,
    QTY            FFLOAT NOT NULL,
    UNIT_COST      FFLOAT NOT NULL,
    TOTAL_COST     FFLOAT NOT NULL,
    LOT_CD         VARCHAR15 NOT NULL,
    PURCHASE_DATE  TIMESTAMP NOT NULL,
    GROUP_ID       VARCHAR10 NOT NULL,
    UOM_CD         VARCHAR4 NOT NULL,
    STOCK_VALUE    FFLOAT NOT NULL,
    FMONTH         SSMALLINT NOT NULL,
    FYEAR          SSMALLINT NOT NULL,
    MODE           FLAG NOT NULL,
    STOCK_CD       VARCHAR15 NOT NULL,
    UPDATE_USER    VARCHAR10,
    UPDATE_DATE    TIMESTAMP,
    MODULE         VARCHAR2 NOT NULL,
    ORDER_LINE     SMALLINT NOT NULL,
    ONHAND_QTY     FFLOAT,
    RESERVED_QTY   FFLOAT,
    DESCS          VARCHAR60,
    TRX_TYPE       VARCHAR(2) NOT NULL,
    MELT_NO        VARCHAR10
);

CREATE TABLE IC_UOM (
    UOM_CD       VARCHAR4 NOT NULL,
    DESCS        VARCHAR30 NOT NULL,
    UPDATE_USER  VARCHAR10,
    UPDATE_DATE  TIMESTAMP
);

CREATE TABLE IC_UOM_CONV (
    FROM_UOM       VARCHAR4 NOT NULL,
    TO_UOM         VARCHAR4 NOT NULL,
    FROM_UOM_RATE  FFLOAT,
    TO_UOM_RATE    FFLOAT,
    CONV_RATE      FFLOAT,
    TO_UOM_QTY     FFLOAT
);

CREATE TABLE IC_WAREHOUSE (
    WH_NO  VARCHAR30 NOT NULL,
    DESCS  VARCHAR60
);

CREATE TABLE LICENSES (
    LICENSENO   INTEGER NOT NULL,
    LICENSEKEY  VARCHAR(15),
    LICENSEID   VARCHAR(15)
);

CREATE TABLE MANUAL_LOG (
    REPLNO      INTEGER NOT NULL,
    PUBDBNO     INTEGER NOT NULL,
    SUBDBNO     INTEGER NOT NULL,
    SEQNO       INTEGER NOT NULL,
    RELATIONNO  INTEGER NOT NULL,
    REPTYPE     CHAR(1),
    OLDKEY      VARCHAR(256),
    NEWKEY      VARCHAR(256),
    SEP         CHAR(1),
    FORCECOUNT  INTEGER DEFAULT 0,
    ERROR_CODE  INTEGER,
    ERROR_MSG   VARCHAR(256)
);

CREATE TABLE MELT_ELEMENT_LABEL (
    DOC_NO    VARCHAR(10),
    ELABEL1   VARCHAR(4),
    ELABEL2   VARCHAR(4),
    ELABEL3   VARCHAR(4),
    ELABEL4   VARCHAR(4),
    ELABEL5   VARCHAR(4),
    ELABEL6   VARCHAR(4),
    ELABEL7   VARCHAR(4),
    ELABEL8   VARCHAR(4),
    ELABEL9   VARCHAR(4),
    ELABEL10  VARCHAR(4),
    ELABEL11  VARCHAR(4),
    ELABEL12  VARCHAR(4),
    ELABEL13  VARCHAR(4),
    ELABEL14  VARCHAR(4),
    ELABEL15  VARCHAR(4),
    ELABEL16  VARCHAR(4),
    ELABEL17  VARCHAR(4),
    ELABEL18  VARCHAR(4),
    ELABEL19  VARCHAR(4),
    ELABEL20  VARCHAR(4),
    ELABEL21  VARCHAR(4),
    ELABEL22  VARCHAR(4),
    ELABEL23  VARCHAR(4),
    ELABEL24  VARCHAR(4),
    ELABEL25  VARCHAR(4)
);

CREATE TABLE MELT_SUMMARY_FINAL_BLEND (
    DOC_NO      VARCHAR(10) NOT NULL,
    ELE_PERC1   FLOAT,
    ELE_PERC2   FLOAT,
    ELE_PERC3   FLOAT,
    ELE_PERC4   FLOAT,
    ELE_PERC5   FLOAT,
    ELE_PERC6   FLOAT,
    ELE_PERC7   FLOAT,
    ELE_PERC8   FLOAT,
    ELE_PERC9   FLOAT,
    ELE_PERC10  FLOAT,
    ELE_PERC11  FLOAT,
    ELE_PERC12  FLOAT,
    ELE_PERC13  FLOAT,
    ELE_PERC14  FLOAT,
    ELE_PERC15  FLOAT,
    ELE_PERC16  FLOAT,
    ELE_PERC17  FLOAT,
    ELE_PERC18  FLOAT,
    ELE_PERC19  FLOAT,
    ELE_PERC20  FLOAT,
    ELE_PERC21  FLOAT,
    ELE_PERC22  FLOAT,
    ELE_PERC23  FLOAT,
    ELE_PERC24  FLOAT,
    ELE_PERC25  FLOAT
);

CREATE TABLE MELT_SUMMARY_FINISHED_GOODS (
    DOC_NO              VARCHAR(10) NOT NULL,
    MELT_NO             VARCHAR(10) NOT NULL,
    ITEM_CODE           VARCHAR(15) NOT NULL,
    ACTUAL_WEIGHT       FLOAT NOT NULL,
    REMELT_WEIGHT       FLOAT NOT NULL,
    CAL_COST            FLOAT NOT NULL,
    CAL_YIELD           FLOAT NOT NULL,
    ACTUAL_COST         FLOAT NOT NULL,
    ACTUAL_YIELD        FLOAT NOT NULL,
    TO_MELT             VARCHAR(10) NOT NULL,
    SCHARGED_WEIGHT     FLOAT DEFAULT 0,
    SRECOVERY_WEIGHT    FLOAT DEFAULT 0,
    TOTAL_COST          FLOAT DEFAULT 0,
    DROSS_WEIGHT        FLOAT,
    ADDITIONAL_WEIGHT1  FLOAT,
    ADDITIONAL_WEIGHT2  FLOAT
);

CREATE TABLE MELT_SUMMARY_METERIAL (
    DOC_NO           VARCHAR(10) NOT NULL,
    MELT_NO          VARCHAR(10) NOT NULL,
    ITEM_CODE        VARCHAR(15) NOT NULL,
    STOCK_CODE       VARCHAR(15) NOT NULL,
    STOCK_DESCS      VARCHAR(60),
    UOM_CD           VARCHAR(4) NOT NULL,
    GROUP_ID         VARCHAR(10) NOT NULL,
    GROUP_DESCS      VARCHAR(20),
    LOT_CD           VARCHAR15 NOT NULL,
    PURCHASE_DATE    DATE NOT NULL,
    UNIT_COST        FLOAT NOT NULL,
    CHARGED_WEIGHT   FLOAT NOT NULL,
    TO_MELT          VARCHAR(10) NOT NULL,
    RECOVERY_PERC    FLOAT,
    RECOVERY_WEIGHT  FLOAT,
    ELE_PERC1        FLOAT,
    ELE_PERC2        FLOAT,
    ELE_PERC3        FLOAT,
    ELE_PERC4        FLOAT,
    ELE_PERC5        FLOAT,
    ELE_PERC6        FLOAT,
    ELE_PERC7        FLOAT,
    ELE_PERC8        FLOAT,
    ELE_PERC9        FLOAT,
    ELE_PERC10       FLOAT,
    ELE_PERC11       FLOAT,
    ELE_PERC12       FLOAT,
    ELE_PERC13       FLOAT,
    SUPP_NAME        VARCHAR60,
    REF_NO           VARCHAR(15) NOT NULL,
    REF_DATE         TIMESTAMP NOT NULL,
    ELE_PERC14       FLOAT,
    ELE_PERC15       FLOAT,
    ELE_PERC16       FLOAT,
    ELE_PERC17       FLOAT,
    ELE_PERC18       FLOAT,
    ELE_PERC19       FLOAT,
    ELE_PERC20       FLOAT,
    ELE_PERC21       FLOAT,
    ELE_PERC22       FLOAT,
    ELE_PERC23       FLOAT,
    ELE_PERC24       FLOAT,
    ELE_PERC25       FLOAT
);

CREATE TABLE MELT_SUMMARY_METERIAL_LOT (
    DOC_NO           VARCHAR(10) NOT NULL,
    ITEM_CODE        VARCHAR(15) NOT NULL,
    STOCK_CODE       VARCHAR(15) NOT NULL,
    STOCK_DESCS      VARCHAR(60),
    UOM_CD           VARCHAR(4) NOT NULL,
    GROUP_ID         VARCHAR(10) NOT NULL,
    GROUP_DESCS      VARCHAR(20),
    LOT_CD           VARCHAR15 NOT NULL,
    PURCHASE_DATE    DATE NOT NULL,
    UNIT_COST        FLOAT NOT NULL,
    CHARGED_WEIGHT   FLOAT NOT NULL,
    RECOVERY_PERC    FLOAT,
    RECOVERY_WEIGHT  FLOAT,
    ELE_PERC1        FLOAT,
    ELE_PERC2        FLOAT,
    ELE_PERC3        FLOAT,
    ELE_PERC4        FLOAT,
    ELE_PERC5        FLOAT,
    ELE_PERC6        FLOAT,
    ELE_PERC7        FLOAT,
    ELE_PERC8        FLOAT,
    ELE_PERC9        FLOAT,
    ELE_PERC10       FLOAT,
    ELE_PERC11       FLOAT,
    ELE_PERC12       FLOAT,
    ELE_PERC13       FLOAT,
    SUPP_NAME        VARCHAR60,
    REF_NO           VARCHAR(15) NOT NULL,
    REF_DATE         TIMESTAMP NOT NULL,
    ELE_PERC14       FLOAT,
    ELE_PERC15       FLOAT,
    ELE_PERC16       FLOAT,
    ELE_PERC17       FLOAT,
    ELE_PERC18       FLOAT,
    ELE_PERC19       FLOAT,
    ELE_PERC20       FLOAT,
    ELE_PERC21       FLOAT,
    ELE_PERC22       FLOAT,
    ELE_PERC23       FLOAT,
    ELE_PERC24       FLOAT,
    ELE_PERC25       FLOAT
);

CREATE TABLE PL_CLOSED_MELT_LOG (
    MELT_NO      VARCHAR10 NOT NULL,
    CMONTH       SSMALLINT NOT NULL,
    CYEAR        SSMALLINT NOT NULL,
    UPDATE_USER  VARCHAR10,
    UPDATE_DATE  TIMESTAMP,
    UNIT_COST    FFLOAT NOT NULL
);

CREATE TABLE PL_DISPATCH_DT (
    DOC_NO         VARCHAR15 NOT NULL,
    DOC_DATE       TIMESTAMP NOT NULL,
    DELIVERY_DATE  TIMESTAMP NOT NULL,
    ORDER_NO       VARCHAR(15) NOT NULL,
    ORDER_DATE     TIMESTAMP NOT NULL,
    ITEM_CODE      VARCHAR(15) NOT NULL,
    UOM_CD         VARCHAR(4) NOT NULL,
    MELT_NO        VARCHAR10 NOT NULL,
    LINE_NO        SSMALLINT NOT NULL,
    CUST_CODE      VARCHAR(10) NOT NULL,
    REMARKS        VARCHAR255,
    ORDER_QTY      FFLOAT,
    DET_QTY        FLOAT,
    CHANGED_FLAG   VARCHAR(1) DEFAULT 'N',
    MELT_TEXT      VARCHAR(150)
);

CREATE TABLE PL_DISPATCH_HD (
    DOC_NO           VARCHAR15 NOT NULL,
    DOC_DATE         TIMESTAMP NOT NULL,
    FROM_ORDER_DATE  TIMESTAMP,
    TO_ORDER_DATE    TIMESTAMP,
    UPDATE_USER      VARCHAR10,
    UPDATE_DATE      TIMESTAMP,
    REF_NO           VARCHAR15,
    REF_DATE         DDATE,
    DIST_TO          VARCHAR60,
    ISSUE_BY         VARCHAR60,
    REVISION_NO      VARCHAR(15)
);

CREATE TABLE PL_DROSS_BALANCE (
    MELT_NO     VARCHAR(10) NOT NULL,
    DROSS_TYPE  SMALLINT NOT NULL,
    ONHAND_QTY  FLOAT NOT NULL
);

CREATE TABLE PL_DROSS_DT (
    MELT_NO       VARCHAR(10) NOT NULL,
    DROSS_TYPE    SMALLINT NOT NULL,
    WEIGHT        FLOAT NOT NULL,
    DESCS         VARCHAR(45),
    NET_WEIGHT    FLOAT,
    RECEIVE_DOC   VARCHAR15 NOT NULL,
    RECEIVE_DATE  DDATE NOT NULL
);

CREATE TABLE PL_DROSS_HD (
    MELT_NO       VARCHAR(10) NOT NULL,
    DESCS         VARCHAR(255),
    RECEIVE_DATE  TIMESTAMP NOT NULL,
    RECEIVE_DOC   VARCHAR15 NOT NULL,
    UPDATE_USER   VARCHAR(10),
    UPDATE_DATE   TIMESTAMP,
    STATUS        VARCHAR(1) DEFAULT 'N'
);

CREATE TABLE PL_DROSS_LEDGER (
    MELT_NO      VARCHAR(10) NOT NULL,
    DROSS_TYPE   SMALLINT NOT NULL,
    QTY          FLOAT NOT NULL,
    TRX_DATE     TIMESTAMP NOT NULL,
    DESCS        VARCHAR60,
    TRX_NO       VARCHAR15 NOT NULL,
    UPDATE_USER  VARCHAR10,
    UPDATE_DATE  DDATE
);

CREATE TABLE PL_DROSS_TYPE (
    DROSS_TYPE  SMALLINT NOT NULL,
    DESCS       VARCHAR30
);

CREATE TABLE PL_FISYEAR (
    FMONTH  SMALLINT NOT NULL,
    FYEAR   SMALLINT NOT NULL,
    SDATE   TIMESTAMP NOT NULL,
    EDATE   TIMESTAMP NOT NULL,
    STATUS  VARCHAR(1),
    PREFIX  VARCHAR(4) NOT NULL
);

CREATE TABLE PL_FN_RECEIVE_DT (
    DOC_NO            VARCHAR(15) NOT NULL,
    DOC_DATE          TIMESTAMP NOT NULL,
    ITEM_CODE         VARCHAR(15) NOT NULL,
    UOM_CD            VARCHAR4 NOT NULL,
    LINE_NO           SMALLINT NOT NULL,
    MELT_NO           VARCHAR(10) NOT NULL,
    REMELT_ITEM_FLAG  VARCHAR(1),
    WEIGHT_QTY        FLOAT NOT NULL,
    QTY               FLOAT NOT NULL,
    GROUP_ID          VARCHAR10 NOT NULL
);

CREATE TABLE PL_FN_RECEIVE_HD (
    DOC_NO             VARCHAR(15) NOT NULL,
    DOC_DATE           TIMESTAMP NOT NULL,
    DESCS              VARCHAR(60),
    UPDATE_USER        VARCHAR10,
    UPDATE_DATE        TIMESTAMP,
    STATUS             FLAG,
    MELT_NO            VARCHAR(10) NOT NULL,
    ITEM_CODE          VARCHAR(15) NOT NULL,
    MARKUP_WEIGHT1     FLOAT,
    MARKUP_WEIGHT2     FLOAT,
    BUNDLE_QTY         SSMALLINT NOT NULL,
    BY_PRODUCTED_ITEM  FLAG DEFAULT 'N',
    UNKNOW_MELT_FLAG   VARCHAR(1) DEFAULT 'N'
);

CREATE TABLE PL_FNG_ADJ_DT (
    DOC_NO             VARCHAR(15) NOT NULL,
    DOC_DATE           TIMESTAMP NOT NULL,
    MELT_NO            VARCHAR10 NOT NULL,
    ITEM_CODE          VARCHAR15 NOT NULL,
    UOM_CD             VARCHAR4 NOT NULL,
    QTY                FLOAT,
    BUNDLE_QTY         FFLOAT,
    ONHAND_QTY         FFLOAT,
    ONHAND_BUNDLE_QTY  FFLOAT,
    UNKNOW_MELT_FLAG   VARCHAR(1) DEFAULT 'N'
);

CREATE TABLE PL_FNG_ADJ_HD (
    DOC_NO       VARCHAR(15) NOT NULL,
    DOC_DATE     TIMESTAMP NOT NULL,
    STATUS       FLAG,
    DESCS        VARCHAR(60),
    UPDATE_USER  VARCHAR(10),
    UPDATE_DATE  TIMESTAMP,
    DESCS1       VARCHAR(60)
);

CREATE TABLE PL_FNG_RET_DT (
    DOC_NO            VARCHAR(15) NOT NULL,
    DOC_DATE          TIMESTAMP NOT NULL,
    CUST_CODE         VARCHAR(10) NOT NULL,
    MELT_NO           VARCHAR(10) NOT NULL,
    UOM_CD            VARCHAR(4) NOT NULL,
    GROUP_ID          VARCHAR10 NOT NULL,
    ITEM_CODE         VARCHAR30 NOT NULL,
    QTY               FLOAT NOT NULL,
    REMELT_ITEM_FLAG  FLAG
);

CREATE TABLE PL_FNG_RET_HD (
    DOC_NO       VARCHAR(15) NOT NULL,
    DOC_DATE     TIMESTAMP NOT NULL,
    CUST_CODE    VARCHAR(10) NOT NULL,
    MELT_NO      VARCHAR(10) NOT NULL,
    STATUS       FLAG,
    DESCS        VARCHAR(60),
    UPDATE_USER  VARCHAR(10),
    UPDATE_DATE  TIMESTAMP,
    BUNDLE_QTY   FFLOAT,
    ITEM_CODE    VARCHAR15 NOT NULL
);

CREATE TABLE PL_MELT (
    MELT_ID      SMALLINT NOT NULL,
    DESCS        VARCHAR(60),
    UPDATE_USER  VARCHAR10,
    UPDATE_DATE  TIMESTAMP,
    MELT_KEY     VARCHAR(4),
    RUN_TYPE     VARCHAR(1) NOT NULL
);

CREATE TABLE PL_MELT_NO_ADDIGNED (
    MELT_NO  VARCHAR(15) NOT NULL
);

CREATE TABLE PL_MELT_TEMPLATE (
    ITEM_CODE      VARCHAR(15) NOT NULL,
    UOM_CD         VARCHAR(4) NOT NULL,
    CUST_CODE      VARCHAR10 NOT NULL,
    ELE_PERC1      FLOAT,
    ELE_PERC2      FLOAT,
    ELE_PERC3      FLOAT,
    ELE_PERC4      FLOAT,
    ELE_PERC5      FLOAT,
    ELE_PERC6      FLOAT,
    ELE_PERC7      FLOAT,
    ELE_PERC8      FLOAT,
    ELE_PERC9      FLOAT,
    ELE_PERC10     FLOAT,
    ELE_PERC11     FLOAT,
    ELE_PERC12     FLOAT,
    ELE_PERC13     FLOAT,
    RECOVERY_PERC  FLOAT,
    UNIT_COST      FLOAT,
    UPDATE_USER    VARCHAR(10),
    UPDATE_DATE    TIMESTAMP,
    MELT_NO        VARCHAR(10),
    ELE_PERC14     FLOAT,
    ELE_PERC15     FLOAT,
    ELE_PERC16     FLOAT,
    ELE_PERC17     FLOAT,
    ELE_PERC18     FLOAT,
    ELE_PERC19     FLOAT,
    ELE_PERC20     FLOAT,
    ELE_PERC21     FLOAT,
    ELE_PERC22     FLOAT,
    ELE_PERC23     FLOAT,
    ELE_PERC24     FLOAT,
    ELE_PERC25     FLOAT
);

CREATE TABLE PL_PRO_PLAN_DISP_DT (
    PLAN_DATE         TIMESTAMP NOT NULL,
    PLAN_DOC          VARCHAR15 NOT NULL,
    TRX_TYPE          VARCHAR2 NOT NULL,
    CUST_CODE         VARCHAR10 NOT NULL,
    ORDER_NO          VARCHAR15 NOT NULL,
    ORDER_DATE        DDATE NOT NULL,
    ITEM_CODE         VARCHAR15 NOT NULL,
    MELT_NO           VARCHAR10 NOT NULL,
    SCHEDULE_DATE     TIMESTAMP NOT NULL,
    ESTIMATED_WEIGHT  FLOAT
);

CREATE TABLE PL_PRO_PLAN_DT (
    PLAN_DATE         TIMESTAMP NOT NULL,
    PLAN_DOC          VARCHAR15 NOT NULL,
    TRX_TYPE          VARCHAR2 NOT NULL,
    MELT_NO           VARCHAR10 NOT NULL,
    ITEM_CODE         VARCHAR15 NOT NULL,
    ORDER_NO          VARCHAR15 NOT NULL,
    CUST_CODE         VARCHAR10 NOT NULL,
    ORDER_DATE        DDATE NOT NULL,
    SCHEDULE_DATE     DDATE NOT NULL,
    STATUS            FLAG NOT NULL,
    LINE_NO           SSMALLINT NOT NULL,
    CAL_TO_TIME       TIMESTAMP,
    FOR_TIME          TIME NOT NULL,
    REMARKS           VARCHAR(255),
    ESTIMATED_WEIGHT  FFLOAT,
    STIME             TIMESTAMP,
    ATTIME            TIMESTAMP,
    PRIOR_ATIME       TIMESTAMP,
    PRIOR_STIME       TIMESTAMP,
    PRIOR_FOR_TIME    TIME,
    STOCK_FLAG        VARCHAR(1),
    STOCK_ITEM_CODE   VARCHAR(15),
    CUST_NAME         VARCHAR(60),
    ITEM_DESCS        VARCHAR(60),
    END_MELT_FLAG     VARCHAR(1) NOT NULL,
    UOM_CD            VARCHAR4 NOT NULL
);

CREATE TABLE PL_PRO_PLAN_HD (
    PLAN_DATE        DDATE NOT NULL,
    PLAN_DOC         VARCHAR15 NOT NULL,
    ISSUE_BY         VARCHAR60 NOT NULL,
    REF_NO           VARCHAR15,
    DESCS            VARCHAR60,
    START_MELT_NO    SSMALLINT NOT NULL,
    END_MELT_NO      SSMALLINT NOT NULL,
    UPDATE_USER      VARCHAR10,
    UPDATE_DATE      TIMESTAMP NOT NULL,
    STATUS           VARCHAR(1) NOT NULL,
    REF_DATE         TIMESTAMP,
    TRX_TYPE         VARCHAR2 NOT NULL,
    MELT_PREFIX      VARCHAR(4),
    REMARKS          VARCHAR(255),
    DIST_TO          VARCHAR60,
    WORK_START_TIME  TIMESTAMP,
    UPDATE_MELT_NO   SSMALLINT NOT NULL,
    ORDER_REMARKS    VARCHAR255,
    PYEAR            SMALLINT,
    PMONTH           SMALLINT,
    CAPACITY         FLOAT
);

CREATE TABLE PL_PRO_PLAN_LOGS (
    PMONTH     SMALLINT NOT NULL,
    PYEAR      SMALLINT NOT NULL,
    MFROM      VARCHAR(10) NOT NULL,
    MTO        VARCHAR(10) NOT NULL,
    PLAN_DOC   VARCHAR(10) NOT NULL,
    PLAN_DATE  TIMESTAMP NOT NULL,
    STATUS     VARCHAR(1)
);

CREATE TABLE PL_RAWMAT_PLAN_DT (
    PLAN_DOC    VARCHAR(15) NOT NULL,
    PLAN_DATE   TIMESTAMP NOT NULL,
    ITEM_CODE   VARCHAR(15) NOT NULL,
    REMARKS     VARCHAR(45),
    ONHAND_QTY  FLOAT,
    USAGE_QTY   FLOAT NOT NULL,
    GROUP_ID    VARCHAR(10) NOT NULL,
    UOM         VARCHAR(4) NOT NULL
);

CREATE TABLE PL_RAWMAT_PLAN_HD (
    PLAN_DATE           TIMESTAMP NOT NULL,
    PLAN_DOC            VARCHAR(15) NOT NULL,
    DIST_TO             VARCHAR(60),
    START_PRODUCE_DATE  TIMESTAMP NOT NULL,
    END_PRODUCE_DATE    TIMESTAMP NOT NULL,
    REVISION            SMALLINT NOT NULL,
    FROM_MELT           VARCHAR(10) NOT NULL,
    TO_MELT             VARCHAR(10) NOT NULL,
    UPDATE_USER         VARCHAR10,
    UPDATE_DATE         TIMESTAMP,
    REMARKS             VARCHAR60,
    STATUS              VARCHAR(1)
);

CREATE TABLE PL_RAWMAT_SHEET_DT (
    PLAN_DOC                VARCHAR15 NOT NULL,
    PLAN_DATE               TIMESTAMP NOT NULL,
    MELT_NO                 VARCHAR(10) NOT NULL,
    ITEM_CODE               VARCHAR(15) NOT NULL,
    STOCK_CODE              VARCHAR(15) NOT NULL,
    GROUP_ID                VARCHAR(10) NOT NULL,
    LOT_NO                  VARCHAR(15) NOT NULL,
    UOM                     VARCHAR(4) NOT NULL,
    CUST_CODE               VARCHAR10 NOT NULL,
    PURCHASE_DATE           TIMESTAMP,
    SUPPLIER_CD             VARCHAR(10),
    ELE_PERC1               FLOAT,
    ELE_PERC2               FLOAT,
    ELE_PERC3               FLOAT,
    ELE_PERC4               FLOAT,
    ELE_PERC5               FLOAT,
    ELE_PERC6               FLOAT,
    ELE_PERC7               FLOAT,
    ELE_PERC8               FLOAT,
    ELE_PERC9               FLOAT,
    ELE_PERC10              FLOAT,
    ELE_PERC11              FLOAT,
    ELE_PERC12              FLOAT,
    ELE_PERC13              FLOAT,
    CHARGED_WEIGHT          FLOAT NOT NULL,
    RECOVERY_WEIGHT         FLOAT,
    UNIT_COST               FLOAT,
    TOTAL_COST              FLOAT,
    RECOVERY_PERC           FLOAT,
    ACTUAL_CHARGED_WEIGHT   FLOAT,
    ACTUAL_RECOVERY_WEIGHT  FLOAT,
    LAST_MELT_ITEM          VARCHAR(1),
    REF_MELT_NO             VARCHAR10,
    DESCS                   VARCHAR150,
    ONHAND_QTY              FLOAT NOT NULL,
    LINE_NO                 SSMALLINT NOT NULL,
    CHECK_PLATE_FLAG        FLAG DEFAULT 'N',
    ORDER_QTY               FFLOAT DEFAULT 0.00,
    CHECK_PLATE_GROUP_ID    SMALLINT DEFAULT 0,
    REF_NO                  VARCHAR(15),
    REF_DATE                TIMESTAMP,
    ELE_PERC14              FLOAT,
    ELE_PERC15              FLOAT,
    ELE_PERC16              FLOAT,
    ELE_PERC17              FLOAT,
    ELE_PERC18              FLOAT,
    ELE_PERC19              FLOAT,
    ELE_PERC20              FLOAT,
    ELE_PERC21              FLOAT,
    ELE_PERC22              FLOAT,
    ELE_PERC23              FLOAT,
    ELE_PERC24              FLOAT,
    ELE_PERC25              FLOAT
);

CREATE TABLE PL_RAWMAT_SHEET_HD (
    PLAN_DATE              TIMESTAMP NOT NULL,
    PLAN_DOC               VARCHAR15 NOT NULL,
    MELT_NO                VARCHAR(10) NOT NULL,
    ITEM_CODE              VARCHAR(15) NOT NULL,
    CUST_CODE              VARCHAR10 NOT NULL,
    REMARKS                VARCHAR(60),
    UPDATE_USER            VARCHAR10,
    UPDATE_DATE            TIMESTAMP,
    FLB1                   FLOAT,
    FLB2                   FLOAT,
    FLB3                   FLOAT,
    FLB4                   FLOAT,
    FLB5                   FLOAT,
    FLB6                   FLOAT,
    FLB7                   FLOAT,
    FLB8                   FLOAT,
    FLB9                   FLOAT,
    FLB10                  FLOAT,
    FLB11                  FLOAT,
    FLB12                  FLOAT,
    FLB13                  FLOAT,
    TOTAL_CHARGED_WEIGHT   FLOAT,
    TOTAL_RECOVERY_WEIGHT  FLOAT,
    TOTAL_COST             FLOAT,
    STATUS                 FLAG,
    CUST_NAME              VARCHAR60,
    ITEM_DESCS             VARCHAR60,
    TAP_REMARK             VARCHAR60,
    ISSUE_BY               VARCHAR(60),
    FLB14                  FLOAT,
    FLB15                  FLOAT,
    FLB16                  FLOAT,
    FLB17                  FLOAT,
    FLB18                  FLOAT,
    FLB19                  FLOAT,
    FLB20                  FLOAT,
    FLB21                  FLOAT,
    FLB22                  FLOAT,
    FLB23                  FLOAT,
    FLB24                  FLOAT,
    FLB25                  FLOAT
);

CREATE TABLE PL_RAWMAT_SHEET_ITEM_REQ (
    PLAN_DATE  TIMESTAMP NOT NULL,
    PLAN_DOC   VARCHAR15 NOT NULL,
    MELT_NO    VARCHAR(10) NOT NULL,
    ITEM_CODE  VARCHAR(15) NOT NULL,
    CUST_CODE  VARCHAR10 NOT NULL,
    MAX_ELE1   FLOAT,
    MAX_ELE2   FLOAT,
    MAX_ELE3   FLOAT,
    MAX_ELE4   FLOAT,
    MAX_ELE5   FLOAT,
    MAX_ELE6   FLOAT,
    MAX_ELE7   FLOAT,
    MAX_ELE8   FLOAT,
    MAX_ELE9   FLOAT,
    MAX_ELE10  FLOAT,
    MAX_ELE11  FLOAT,
    MAX_ELE12  FLOAT,
    MAX_ELE13  FLOAT,
    MAX_ELE14  FLOAT,
    MAX_ELE15  FLOAT,
    MIN_ELE1   FLOAT,
    MIN_ELE2   FLOAT,
    MIN_ELE3   FLOAT,
    MIN_ELE4   FLOAT,
    MIN_ELE5   FLOAT,
    MIN_ELE6   FLOAT,
    MIN_ELE7   FLOAT,
    MIN_ELE8   FLOAT,
    MIN_ELE9   FLOAT,
    MIN_ELE10  FLOAT,
    MIN_ELE11  FLOAT,
    MIN_ELE12  FLOAT,
    MIN_ELE13  FLOAT,
    MIN_ELE14  FLOAT,
    MIN_ELE15  FLOAT,
    MIN_ELE16  FLOAT,
    MIN_ELE17  FLOAT,
    MIN_ELE18  FLOAT,
    MIN_ELE19  FLOAT,
    MIN_ELE20  FLOAT,
    MIN_ELE21  FLOAT,
    MIN_ELE22  FLOAT,
    MIN_ELE23  FLOAT,
    MIN_ELE24  FLOAT,
    MIN_ELE25  FLOAT,
    MAX_ELE16  FLOAT,
    MAX_ELE17  FLOAT,
    MAX_ELE18  FLOAT,
    MAX_ELE19  FLOAT,
    MAX_ELE20  FLOAT,
    MAX_ELE21  FLOAT,
    MAX_ELE22  FLOAT,
    MAX_ELE23  FLOAT,
    MAX_ELE24  FLOAT,
    MAX_ELE25  FLOAT
);

CREATE TABLE PL_REQ_DT (
    DOC_NO         VARCHAR(15) NOT NULL,
    DOC_DATE       TIMESTAMP NOT NULL,
    TRX_TYPE       VARCHAR2 NOT NULL,
    ITEM_CODE      VARCHAR15 NOT NULL,
    ITEM_DESCS     VARCHAR(60),
    LOT_NO         VARCHAR15 NOT NULL,
    PURCHASE_DATE  TIMESTAMP NOT NULL,
    QTY            FLOAT NOT NULL,
    UNIT_COST      FLOAT NOT NULL,
    UOM            VARCHAR4 NOT NULL,
    TOTAL_COST     FLOAT NOT NULL,
    GROUP_ID       VARCHAR10 NOT NULL,
    USAGED_QTY     FLOAT,
    ITEM_TYPE      VARCHAR(1),
    ONHAND_QTY     FFLOAT,
    REF_NO         VARCHAR15 NOT NULL,
    REF_DATE       TIMESTAMP NOT NULL,
    ACCT_CD        VARCHAR(10) NOT NULL
);

CREATE TABLE PL_REQ_HD (
    DOC_NO       VARCHAR15 NOT NULL,
    DOC_DATE     TIMESTAMP NOT NULL,
    DESCS        VARCHAR60,
    REQ_BY       VARCHAR(60) NOT NULL,
    REQ_DATE     TIMESTAMP NOT NULL,
    UPDATE_USER  VARCHAR10,
    UPDATE_DATE  TIMESTAMP,
    TRX_TYPE     VARCHAR2 NOT NULL,
    IC_MODE      FLAG,
    REMARKS      VARCHAR60,
    MELT_NO      VARCHAR(10) NOT NULL,
    STATUS       VARCHAR(1) NOT NULL,
    PLAN_DOC     VARCHAR15 NOT NULL,
    PLAN_DATE    TIMESTAMP NOT NULL,
    ALLOY_CODE   VARCHAR15 NOT NULL,
    ISSUE_BY     VARCHAR60
);

CREATE TABLE PL_TRX_CONTROL (
    TRX_TYPE        VARCHAR(2) NOT NULL,
    IC_MODE         VARCHAR(1),
    DESCS           VARCHAR60,
    GL_MODE         VARCHAR(1),
    PREFIX_DOC      VARCHAR(2),
    MANUAL_FLAG     VARCHAR(1) NOT NULL,
    GEN_DOC_NUMBER  SMALLINT,
    LINK_TO_IC      FLAG,
    LINK_TO_GL      VARCHAR(1),
    UPDATE_USER     VARCHAR10,
    UPDATE_DATE     TIMESTAMP
);

CREATE TABLE PO_CONTRACT (
    SUPP_CODE           VARCHAR(10) NOT NULL,
    CONTRACT_PERSON1    VARCHAR(60),
    CONTRACT_PERSON2    VARCHAR(60),
    LAST_USED_DOC_NO    VARCHAR(15),
    LAST_USED_DOC_DATE  TIMESTAMP,
    UPDATE_USER         VARCHAR(10),
    UPDATE_DATE         TIMESTAMP
);

CREATE TABLE PO_GRN_DT (
    ITEM_CODE   VARCHAR15 NOT NULL,
    ORDER_LINE  SSMALLINT NOT NULL,
    SUPP_CODE   VARCHAR10 NOT NULL,
    GRN_DATE    DDATE NOT NULL,
    GRN_NO      VARCHAR15 NOT NULL,
    UOM         VARCHAR4 NOT NULL,
    ITEM_DESCS  VARCHAR60 NOT NULL,
    UNIT_COST   FFLOAT NOT NULL,
    TOTAL_AMT   FFLOAT NOT NULL,
    REMARKS     VARCHAR60,
    DISCS_AMT   FFLOAT,
    TAX_AMT     FFLOAT NOT NULL,
    BASE_AMT    FFLOAT NOT NULL,
    TAX_CD      VARCHAR2 NOT NULL,
    GRN_LINE    SSMALLINT NOT NULL,
    DISCS_CD    VARCHAR2,
    GRN_QTY     FFLOAT NOT NULL,
    ORDER_QTY   FFLOAT NOT NULL,
    TAX_RATE    FFLOAT NOT NULL,
    ORDER_NO    VARCHAR15 NOT NULL,
    ORDER_DATE  TIMESTAMP NOT NULL,
    STATUS      FLAG,
    GROUP_ID    VARCHAR10 NOT NULL,
    LOT_NO      VARCHAR15 NOT NULL,
    MARK_UP     SSMALLINT
);

CREATE TABLE PO_GRN_HD (
    SUPP_CODE    VARCHAR10 NOT NULL,
    GRN_NO       VARCHAR15 NOT NULL,
    GRN_DATE     DDATE NOT NULL,
    REF_NO       VARCHAR15,
    REF_DATE     DDATE,
    UPDATE_USER  VARCHAR10,
    UPDATE_DATE  TIMESTAMP,
    STATUS       FLAG NOT NULL,
    GRN_AMT      FFLOAT NOT NULL,
    DESCS        VARCHAR60,
    TAX_AMT      FLOAT,
    REMARKS      VARCHAR255,
    NAME         VARCHAR60,
    NO_OF_PRINT  SSMALLINT DEFAULT 0
);

CREATE TABLE PO_ORDER_DT (
    ITEM_CODE         VARCHAR15 NOT NULL,
    LINE_NO           SSMALLINT NOT NULL,
    ORDER_DATE        DDATE NOT NULL,
    SUPP_CODE         VARCHAR10 NOT NULL,
    UOM               VARCHAR4 NOT NULL,
    ORDER_NO          VARCHAR15 NOT NULL,
    ITEM_DESCS        VARCHAR60 NOT NULL,
    UNIT_COST         FFLOAT NOT NULL,
    TOTAL_AMT         FFLOAT NOT NULL,
    REMARKS           VARCHAR60 NOT NULL,
    DISCS_AMT         FFLOAT,
    TAX_AMT           FFLOAT NOT NULL,
    BASE_AMT          FFLOAT NOT NULL,
    TAX_CD            VARCHAR2 NOT NULL,
    DISCS_CD          VARCHAR2,
    QTY               FFLOAT NOT NULL,
    TAX_RATE          FFLOAT NOT NULL,
    STATUS            FLAG,
    GRN_QTY           FFLOAT NOT NULL,
    LOT_NO            VARCHAR15 NOT NULL,
    GROUP_ID          VARCHAR10 NOT NULL,
    MARKUP            SMALLINT,
    DISCS_RATE        FFLOAT,
    UPDATE_PRICE      FLOAT,
    UPDATE_TOTAL_AMT  FLOAT,
    STOCK_EMPTY       FLAG DEFAULT 'N'
);

CREATE TABLE PO_ORDER_HD (
    SUPP_CODE        VARCHAR10 NOT NULL,
    ORDER_NO         VARCHAR15 NOT NULL,
    ORDER_DATE       DDATE NOT NULL,
    REF_NO           VARCHAR15,
    REF_DATE         DDATE,
    UPDATE_USER      VARCHAR10,
    UPDATE_DATE      TIMESTAMP,
    STATUS           FLAG NOT NULL,
    ORDER_AMT        FFLOAT NOT NULL,
    DESCS            VARCHAR60,
    DELIVERY_DATE    TIMESTAMP NOT NULL,
    FAX_TO           VARCHAR60,
    CC_TO            VARCHAR60,
    REMARKS          MEMOS,
    NO_OF_PRINT      SMALLINT,
    VALIDITY         TIMESTAMP,
    MARKUP           SMALLINT,
    TAX_AMT          FLOAT,
    DISCS_AMT        FLOAT,
    TERM_OF_PAYMENT  SMALLINT DEFAULT 0,
    STOCK_EMPTY      FLAG DEFAULT 'N'
);

CREATE TABLE PO_SUPPLIER (
    SUPPLIER_CD      VARCHAR10 NOT NULL,
    CREDITOR_ACCT    VARCHAR10 NOT NULL,
    NAME             VARCHAR60 NOT NULL,
    ADDRESS1         VARCHAR60,
    ADDRESS2         VARCHAR60,
    ADDRESS3         VARCHAR60,
    TELEPHONE        VARCHAR30,
    FAX_NO           VARCHAR30,
    CONTRACT_PERSON  VARCHAR60,
    UPDATE_USER      VARCHAR10,
    UPDATE_DATE      TIMESTAMP,
    TAX_CD           VARCHAR2 NOT NULL,
    POSTCODE         VARCHAR10 NOT NULL,
    PROVINCE         VARCHAR30 NOT NULL
);

CREATE TABLE PUBLISHEDDB (
    REPLNO              INTEGER NOT NULL,
    DBNO                INTEGER NOT NULL,
    DISABLED            CHAR(1) DEFAULT 'N',
    COMMENTS            VARCHAR(1000),
    USERNAME            VARCHAR(31),
    PSWORD              VARCHAR(31),
    CONFLICTMETHOD      INTEGER DEFAULT 2 NOT NULL,
    USEDEFAULTCONFLICT  INTEGER DEFAULT 1 NOT NULL,
    USEDEFAULTLOGGING   INTEGER DEFAULT 1 NOT NULL,
    LOGFILENAME         VARCHAR(100),
    LOGTOFILE           INTEGER DEFAULT 0 NOT NULL,
    LOGTOWINDOW         INTEGER DEFAULT 0 NOT NULL,
    SEP                 INTEGER DEFAULT 5 NOT NULL,
    USERROLE            VARCHAR(50)
);

CREATE TABLE RELATIONKEYFIELDS (
    REPLNO      INTEGER NOT NULL,
    DBNO        INTEGER NOT NULL,
    TGTDBNO     INTEGER NOT NULL,
    RELATIONNO  INTEGER NOT NULL,
    FIELDNO     INTEGER NOT NULL,
    FIELDNAME   VARCHAR(100),
    TARGETNAME  VARCHAR(100),
    COMMENTS    VARCHAR(1000)
);

CREATE TABLE RELATIONREPLFIELDS (
    REPLNO      INTEGER NOT NULL,
    DBNO        INTEGER NOT NULL,
    RELATIONNO  INTEGER NOT NULL,
    FIELDNO     INTEGER NOT NULL,
    FIELDNAME   VARCHAR(100),
    TGTDBNO     INTEGER NOT NULL,
    TARGETNAME  VARCHAR(100),
    COMMENTS    VARCHAR(1000)
);

CREATE TABLE RELATIONS (
    REPLNO         INTEGER NOT NULL,
    DBNO           INTEGER NOT NULL,
    RELATIONNO     INTEGER NOT NULL,
    RELATIONNAME   VARCHAR(100),
    COMMENTS       VARCHAR(1000),
    DISABLED       CHAR(1) DEFAULT 'N',
    TIMEFIELDNAME  VARCHAR(20),
    CONDITION      VARCHAR(255) DEFAULT '' NOT NULL,
    TGTDBNO        INTEGER NOT NULL,
    TARGETNAME     VARCHAR(100),
    TARGETTYPE     CHAR(1),
    INSERTS        INTEGER DEFAULT 0 NOT NULL,
    UPDATES        INTEGER DEFAULT 0 NOT NULL,
    DELETES        INTEGER DEFAULT 0 NOT NULL,
    SECONDS        INTEGER DEFAULT 0 NOT NULL,
    KEEPSTATS      INTEGER DEFAULT 1 NOT NULL,
    ERRORS         INTEGER DEFAULT 0 NOT NULL,
    CONFLICTS      INTEGER DEFAULT 0 NOT NULL
);

CREATE TABLE REPL$CONFIG (
    CONFLICTMETHOD             INTEGER DEFAULT 2 NOT NULL,
    LOGFILENAME                VARCHAR(100) DEFAULT 'REPLICATE.LOG' NOT NULL,
    LOGTOFILE                  INTEGER DEFAULT 3 NOT NULL,
    LOGTOWINDOW                INTEGER DEFAULT 3 NOT NULL,
    TIMERINTERVAL              INTEGER DEFAULT 5 NOT NULL,
    ALERTVALUE                 VARCHAR(10) DEFAULT 'REPLICATE' NOT NULL,
    TIMERMETHOD                INTEGER DEFAULT 1 NOT NULL,
    "VERSION"                  INTEGER NOT NULL,
    BKGRNDIMG                  VARCHAR(254),
    LINKCOLORUNSEL             INTEGER,
    LINKCOLORSEL               INTEGER,
    DBICON                     VARCHAR(254),
    DEFAULTSET                 CHAR(1) DEFAULT 'Y',
    ENABLED_SCHEDULER_LOGFILE  CHAR(1) DEFAULT 'N',
    SCHEDULERLOGFILE           VARCHAR(255) DEFAULT '',
    ERROR_HOSTNAME             VARCHAR(255) DEFAULT '',
    ERROR_FROMADDRESS          VARCHAR(255) DEFAULT '',
    ERROR_FROMNAME             VARCHAR(255) DEFAULT '',
    ERROR_TOOADDRESS           VARCHAR(255) DEFAULT '',
    REPL_BEEP                  CHAR(1) DEFAULT 'Y',
    NOTIFY_ERROR_MESSAGE       CHAR(1) DEFAULT 'N',
    MAIL_SYSDBA                CHAR(1) DEFAULT 'N'
);

CREATE TABLE REPL_LOG (
    REPLNO      INTEGER NOT NULL,
    PUBDBNO     INTEGER NOT NULL,
    SUBDBNO     INTEGER NOT NULL,
    SEQNO       INTEGER NOT NULL,
    RELATIONNO  INTEGER NOT NULL,
    REPTYPE     CHAR(1),
    OLDKEY      VARCHAR(256),
    NEWKEY      VARCHAR(256),
    SEP         CHAR(1),
    FORCECOUNT  INTEGER DEFAULT 0
);

CREATE TABLE REPL_SEPARATOR (
    REPLNO        INTEGER NOT NULL,
    PUBDBNO       INTEGER NOT NULL,
    SUBDBNO       INTEGER NOT NULL,
    RELATIONNO    INTEGER NOT NULL,
    RELATIONNAME  VARCHAR(100) NOT NULL,
    SEP           CHAR(1)
);

CREATE TABLE REPLTIMES (
    ID             INTEGER NOT NULL,
    DATABASE_NAME  VARCHAR(50),
    FREQUENCY      VARCHAR(25),
    SCHEDULED      VARCHAR(35),
    ENABLED        VARCHAR(1),
    EVERYDAY       VARCHAR(1),
    WEEKDAYS       VARCHAR(1),
    WEEKLY         VARCHAR(1),
    MINUTES        INTEGER,
    MONTHLY        INTEGER,
    ATIME          VARCHAR(8),
    AEXECUTEDATE   VARCHAR(20)
);

CREATE TABLE RESULT_CHECK_PLATE (
    MELT_NO      VARCHAR(10) NOT NULL,
    CUST_CODE    VARCHAR(10) NOT NULL,
    ITEM_CODE    VARCHAR(15) NOT NULL,
    F1           FLOAT NOT NULL,
    F2           FLOAT NOT NULL,
    F3           FLOAT NOT NULL,
    F4           FLOAT NOT NULL,
    F5           FLOAT NOT NULL,
    F6           FLOAT NOT NULL,
    F7           FLOAT NOT NULL,
    F8           FLOAT NOT NULL,
    F9           FLOAT NOT NULL,
    F10          FLOAT NOT NULL,
    F11          FLOAT NOT NULL,
    F12          FLOAT NOT NULL,
    F13          FLOAT NOT NULL,
    EXPECT_LINE  SMALLINT NOT NULL,
    F14          FLOAT,
    F15          FLOAT,
    F16          FLOAT,
    F17          FLOAT,
    F18          FLOAT,
    F19          FLOAT,
    F20          FLOAT,
    F21          FLOAT,
    F22          FLOAT,
    F23          FLOAT,
    F24          FLOAT,
    F25          FLOAT
);

CREATE TABLE SCHEMATA (
    REPLNO  INTEGER NOT NULL,
    NAME    VARCHAR(100) NOT NULL
);

CREATE TABLE SO_COMPONENTS_DETAIL (
    CUST_CODE  VARCHAR10 NOT NULL,
    ITEM_CODE  VARCHAR(15) NOT NULL,
    LINE1      VARCHAR(150),
    LINE2      VARCHAR(150),
    LINE3      VARCHAR(150),
    LINE4      VARCHAR(150),
    LINE5      VARCHAR(150),
    LINE6      VARCHAR(150)
);

CREATE TABLE SO_CONTRACT (
    CUST_CODE           VARCHAR(10) NOT NULL,
    CONTRACT_PERSON1    VARCHAR(60),
    CONTRACT_PERSON2    VARCHAR(60),
    LAST_USED_DOC_NO    VARCHAR(15),
    LAST_USED_DOC_DATE  TIMESTAMP,
    UPDATE_USER         VARCHAR(10),
    UPDATE_DATE         TIMESTAMP
);

CREATE TABLE SO_CUSTOMERS (
    CUSTOMER_CD      VARCHAR10 NOT NULL,
    NAME             VARCHAR60 NOT NULL,
    ADDRESS1         VARCHAR60,
    ADDRESS2         VARCHAR60,
    ADDRESS3         VARCHAR60,
    TELEPHONE        VARCHAR30,
    FAX_NO           VARCHAR30,
    CONTRACT_PERSON  VARCHAR60,
    UPDATE_USER      VARCHAR10,
    UPDATE_DATE      TIMESTAMP,
    DEBTOR_ACCT      VARCHAR10 NOT NULL,
    TAX_CD           VARCHAR2 NOT NULL,
    POSTCODE         VARCHAR10 NOT NULL,
    PROVINCE         VARCHAR30 NOT NULL
);

CREATE TABLE SO_DET_DT (
    ITEM_CODE      VARCHAR15 NOT NULL,
    DELIVERY_NO    VARCHAR15 NOT NULL,
    DESCS          VARCHAR60,
    DELIVERY_DATE  TIMESTAMP NOT NULL,
    UOM            VARCHAR4 NOT NULL,
    CUST_CODE      VARCHAR10 NOT NULL,
    DET_QTY        FFLOAT NOT NULL,
    UNIT_COST      FFLOAT NOT NULL,
    ORDER_NO       VARCHAR15 NOT NULL,
    TOTAL_AMT      FFLOAT NOT NULL,
    ORDER_DATE     TIMESTAMP NOT NULL,
    TAX_AMT        FFLOAT NOT NULL,
    TAX_CD         VARCHAR2 NOT NULL,
    MELT_NO        VARCHAR10 NOT NULL,
    BUNDLE_NO      SSMALLINT NOT NULL,
    REF_NO         VARCHAR15,
    REF_DATE       DDATE,
    ORDER_QTY      FFLOAT NOT NULL,
    ONHAND_QTY     FFLOAT NOT NULL,
    MARK_UP        SMALLINT,
    MARK_UP_QTY    FFLOAT
);

CREATE TABLE SO_DET_DT_LINK (
    DELIVERY_NO    VARCHAR15 NOT NULL,
    DELIVERY_DATE  TIMESTAMP NOT NULL,
    BATCH_NO       INTEGER NOT NULL,
    MELT_NO        VARCHAR10 NOT NULL,
    REF_NO         VARCHAR15 NOT NULL,
    REF_DATE       TIMESTAMP NOT NULL,
    BUNDLE_NO      SMALLINT NOT NULL,
    QTY            FFLOAT NOT NULL
);

CREATE TABLE SO_DET_DT_MELT (
    DELIVERY_NO        VARCHAR15 NOT NULL,
    DELIVERY_DATE      TIMESTAMP NOT NULL,
    BATCH_NO           INTEGER NOT NULL,
    MELT_NO            VARCHAR10 NOT NULL,
    REF_NO             VARCHAR(15) NOT NULL,
    REF_DATE           TIMESTAMP NOT NULL,
    START_BUNDLE       SMALLINT NOT NULL,
    TOTAL_BUNDLE       SMALLINT NOT NULL,
    ONHAND_QTY         FFLOAT NOT NULL,
    TOTAL_CHARGED_QTY  FFLOAT NOT NULL
);

CREATE TABLE SO_DET_DT_ORDER (
    DELIVERY_NO    VARCHAR15 NOT NULL,
    DELIVERY_DATE  TIMESTAMP NOT NULL,
    ORDER_NO       VARCHAR15 NOT NULL,
    ORDER_DATE     TIMESTAMP NOT NULL,
    CUST_CODE      VARCHAR10 NOT NULL,
    ITEM_CODE      VARCHAR15 NOT NULL,
    UOM            VARCHAR4 NOT NULL,
    BATCH_NO       INTEGER NOT NULL,
    ORDER_QTY      FLOAT,
    MARKUP         SMALLINT,
    DET_QTY        FLOAT,
    UNIT_COST      FLOAT
);

CREATE TABLE SO_DET_HD (
    DELIVERY_NO      VARCHAR15 NOT NULL,
    DELIVERY_DATE    TIMESTAMP NOT NULL,
    CUST_CODE        VARCHAR10 NOT NULL,
    REMARKS          VARCHAR255,
    UPDATE_USER      VARCHAR10,
    UPDATE_DATE      TIMESTAMP,
    STATUS           FLAG,
    REF_NO           VARCHAR(15),
    REF_DATE         TIMESTAMP,
    DESCS            VARCHAR60,
    INVOICE_MATCHED  FLAG DEFAULT 'N'
);

CREATE TABLE SO_INVOICE_DT (
    DOC_NO      VARCHAR15 NOT NULL,
    DOC_DATE    DDATE NOT NULL,
    ITEM_CODE   VARCHAR15 NOT NULL,
    CUST_CODE   VARCHAR10 NOT NULL,
    LINE_NO     SSMALLINT NOT NULL,
    ITEM_DESCS  VARCHAR60 NOT NULL,
    QTY         FFLOAT NOT NULL,
    UNIT_COST   FFLOAT NOT NULL,
    TOTAL_AMT   FFLOAT NOT NULL,
    BASE_AMT    FFLOAT NOT NULL,
    TAX_AMT     FFLOAT NOT NULL,
    DISCS_AMT   FFLOAT DEFAULT 0.00,
    TAX_CD      VARCHAR2 NOT NULL,
    DISCS_CD    VARCHAR2,
    MELT_NO     VARCHAR10,
    ORDER_NO    VARCHAR15,
    ORDER_DATE  TIMESTAMP
);

CREATE TABLE SO_INVOICE_HD (
    DOC_NO        VARCHAR15 NOT NULL,
    DOC_DATE      DDATE NOT NULL,
    TAX_INV_NO    VARCHAR15,
    CUST_CODE     VARCHAR10 NOT NULL,
    DOC_AMT       FFLOAT NOT NULL,
    REF_NO        VARCHAR15,
    REF_DATE      DDATE,
    DESCS         VARCHAR60,
    STATUS        FLAG NOT NULL,
    UPDATE_USER   VARCHAR10,
    UPDATE_DATE   TIMESTAMP,
    TAX_INV_DATE  DDATE
);

CREATE TABLE SO_LEDGER (
    CUST_CODE       VARCHAR10 NOT NULL,
    CUST_NAME       VARCHAR45,
    DOC_NO          VARCHAR15 NOT NULL,
    DOC_DATE        TIMESTAMP NOT NULL,
    BASE_AMT        FFLOAT NOT NULL,
    TAX_AMT         FFLOAT,
    DISCS_AMT       FFLOAT,
    TAX_INV_NO      VARCHAR15,
    UPDATE_USER     VARCHAR10,
    ITEM_CODE       CHAR(18) NOT NULL,
    UPDATE_DATE     DDATE,
    DESCS           VARCHAR60,
    QTY             FFLOAT,
    UNIT_COST       FFLOAT NOT NULL,
    TOTAL_AMT       FFLOAT NOT NULL,
    TAX_CD          VARCHAR2,
    DISCS_CD        VARCHAR2,
    REF_NO          VARCHAR15 NOT NULL,
    REF_DATE        DDATE NOT NULL,
    TAX_INV_DATE    DDATE,
    LINE_NO         SSMALLINT NOT NULL,
    UOM_CD          VARCHAR4 NOT NULL,
    MODE            FLAG,
    MELT_NO         VARCHAR10,
    ORDER_NO        VARCHAR(15),
    ORDER_DATE      TIMESTAMP,
    ONHAND_QTY      FLOAT,
    BUNDLE_QTY      SSMALLINT NOT NULL,
    ADJ_BUNDLE_QTY  FFLOAT
);

CREATE TABLE SO_ORDER_DT (
    ORDER_NO           VARCHAR15 NOT NULL,
    ORDER_DATE         DDATE NOT NULL,
    ITEM_CODE          VARCHAR15 NOT NULL,
    CUST_CODE          VARCHAR10 NOT NULL,
    LINE_NO            SSMALLINT NOT NULL,
    UOM                VARCHAR4 NOT NULL,
    ITEM_DESCS         VARCHAR60 NOT NULL,
    UNIT_COST          FFLOAT NOT NULL,
    TOTAL_AMT          FFLOAT NOT NULL,
    REMARKS            VARCHAR255,
    DISCS_AMT          FFLOAT DEFAULT 0.00 NOT NULL,
    TAX_AMT            FFLOAT NOT NULL,
    BASE_AMT           FFLOAT NOT NULL,
    TAX_CD             VARCHAR2 NOT NULL,
    DISCS_CD           VARCHAR2 DEFAULT NULL,
    QTY                FLOAT NOT NULL,
    TAX_RATE           FLOAT NOT NULL,
    STATUS             FLAG NOT NULL,
    DET_QTY            FLOAT NOT NULL,
    DELIVERY_DATE      TIMESTAMP,
    URGENT_FLAG        VARCHAR(1),
    MARK_UP            SSMALLINT NOT NULL,
    STOCK_USAGED_FLAG  FLAG DEFAULT 'N',
    STOCK_USAGED_QTY   FFLOAT
);

CREATE TABLE SO_ORDER_DT_STOCK (
    ORDER_NO       VARCHAR15 NOT NULL,
    ORDER_DATE     DDATE NOT NULL,
    ITEM_CODE      VARCHAR15 NOT NULL,
    CUST_CODE      VARCHAR10 NOT NULL,
    LINE_NO        SSMALLINT NOT NULL,
    DELIVERY_DATE  TIMESTAMP NOT NULL,
    REF_NO         VARCHAR15 NOT NULL,
    REF_DATE       TIMESTAMP NOT NULL,
    ORDER_QTY      FFLOAT NOT NULL,
    ONHAND_QTY     FFLOAT NOT NULL,
    QTY            FFLOAT NOT NULL,
    UOM_CD         VARCHAR4 NOT NULL,
    MELT_NO        VARCHAR10 NOT NULL,
    STATUS         FLAG
);

CREATE TABLE SO_ORDER_HD (
    CUST_CODE            VARCHAR10 NOT NULL,
    ORDER_NO             VARCHAR15 NOT NULL,
    ORDER_DATE           DDATE NOT NULL,
    REF_NO               VARCHAR15,
    REF_DATE             DDATE,
    UPDATE_USER          VARCHAR10,
    UPDATE_DATE          DDATE,
    STATUS               FLAG NOT NULL,
    ORDER_AMT            FFLOAT NOT NULL,
    DESCS                VARCHAR60,
    SCHEDULE_DATE        TIMESTAMP,
    REQUIRED_SPEC_SHEET  VARCHAR(1),
    REMARKS              MEMOS,
    FAX_TO               VARCHAR60,
    CC_TO                VARCHAR60,
    NEW_ORDER_FLAG       FLAG,
    NO_OF_PRINT          SMALLINT,
    VALIDITY             TIMESTAMP,
    TAX_AMT              FLOAT,
    CURRENCY_CD          VARCHAR4 NOT NULL,
    NAME                 VARCHAR60,
    ADDRESS1             VARCHAR60,
    ADDRESS2             VARCHAR60,
    ADDRESS3             VARCHAR60,
    CURRENCY_DESCS       VARCHAR30,
    STOCK_USAGED_FLAG    FLAG DEFAULT 'N',
    TERM_OF_PAYMENT      SSMALLINT
);

CREATE TABLE SO_ORDER_REVISION_DT (
    ORDER_NO        VARCHAR15 NOT NULL,
    ORDER_DATE      DDATE NOT NULL,
    ITEM_CODE       VARCHAR15 NOT NULL,
    CUST_CODE       VARCHAR10 NOT NULL,
    DOC_DATE        TIMESTAMP NOT NULL,
    DOC_NO          VARCHAR(15) NOT NULL,
    LINE_NO         SSMALLINT NOT NULL,
    UOM             VARCHAR4 NOT NULL,
    UNIT_COST       FFLOAT NOT NULL,
    TOTAL_AMT       FFLOAT NOT NULL,
    NEW_ORDER_FLAG  FLAG,
    QTY             FFLOAT NOT NULL,
    REMARKS         VARCHAR255,
    REF_NO          VARCHAR(15),
    REF_DATE        TIMESTAMP,
    STATUS          FLAG DEFAULT 'N'
);

CREATE TABLE SO_ORDER_REVISION_HD (
    DOC_DATE         TIMESTAMP NOT NULL,
    DOC_NO           VARCHAR(15) NOT NULL,
    NO_OF_REVISION   SMALLINT,
    FROM_ORDER_DATE  TIMESTAMP,
    TO_ORDER_DATE    TIMESTAMP,
    REVISION_BY      VARCHAR60,
    DISTRIBUTE_TO    VARCHAR60,
    UPDATE_USER      VARCHAR(10),
    UPDATE_DATE      TIMESTAMP,
    REMARKS          VARCHAR255,
    STATUS           FLAG
);

CREATE TABLE SO_ORDER_SCH_DT (
    CUST_CODE      VARCHAR10 NOT NULL,
    ORDER_NO       VARCHAR15 NOT NULL,
    ORDER_DATE     DDATE NOT NULL,
    ITEM_CODE      VARCHAR15 NOT NULL,
    LINE_NO        SSMALLINT NOT NULL,
    SCHEDULE_DATE  TIMESTAMP NOT NULL,
    SCHEDULE_QTY   FLOAT NOT NULL,
    REMARKS        VARCHAR255,
    UOM            VARCHAR(4) NOT NULL
);

CREATE TABLE SO_QUOTATION_DT (
    DOC_NO      VARCHAR15 NOT NULL,
    DOC_DATE    DDATE NOT NULL,
    ITEM_CODE   VARCHAR15 NOT NULL,
    ITEM_DESCS  VARCHAR60,
    CUST_CODE   VARCHAR10 NOT NULL,
    UNIT_COST   FFLOAT NOT NULL,
    QTY         FFLOAT NOT NULL,
    TOTAL_AMT   FFLOAT NOT NULL,
    UOM         VARCHAR4 NOT NULL,
    REMARKS     VARCHAR255,
    DISCS_AMT   FFLOAT,
    TAX_AMT     FFLOAT,
    BASE_AMT    FFLOAT NOT NULL,
    TAX_CD      VARCHAR2,
    DISCS_CD    VARCHAR2,
    TAX_RATE    FLOAT,
    LINE_NO     SMALLINT NOT NULL,
    STATUS      FLAG NOT NULL,
    MARK_UP     SSMALLINT NOT NULL
);

CREATE TABLE SO_QUOTATION_HD (
    DOC_NO               VARCHAR15 NOT NULL,
    DOC_DATE             DDATE NOT NULL,
    REF_NO               VARCHAR15,
    DESCS                VARCHAR60 NOT NULL,
    CUST_CODE            VARCHAR10 NOT NULL,
    REF_DATE             DDATE,
    DOC_AMT              FFLOAT NOT NULL,
    STATUS               FLAG NOT NULL,
    VALIDITY             TIMESTAMP,
    UPDATE_USER          VARCHAR10,
    UPDATE_DATE          TIMESTAMP,
    PREPARE_PERSON       VARCHAR(60),
    DELIVERY_DATE        TIMESTAMP,
    REQUIRED_SPEC_SHEET  VARCHAR(1),
    REMARKS              VARCHAR255,
    FAX_TO               VARCHAR60,
    CC_TO                VARCHAR60,
    NO_OF_PRINT          SMALLINT,
    TAX_AMT              FLOAT,
    CURRENCY_CD          VARCHAR(4) NOT NULL,
    CURRENCY_DESCS       VARCHAR30,
    ADDRESS1             VARCHAR60,
    ADDRESS2             VARCHAR60,
    ADDRESS3             VARCHAR60,
    NAME                 VARCHAR60,
    TERM_OF_PAYMENT      SSMALLINT
);

CREATE TABLE SO_SALES_ITEM_DT (
    ITEM_CODE   VARCHAR15 NOT NULL,
    STOCK_CD    VARCHAR15 NOT NULL,
    DESCS       VARCHAR60,
    GROUP_ID    VARCHAR10 NOT NULL,
    UNIT_COST   FFLOAT NOT NULL,
    CUST_CODE   VARCHAR10 NOT NULL,
    WEIGHT      FFLOAT NOT NULL,
    UOM_CD      VARCHAR4 NOT NULL,
    TOTAL_COST  FFLOAT NOT NULL
);

CREATE TABLE SO_SALES_ITEM_HD (
    ITEM_CODE       VARCHAR15 NOT NULL,
    DESCS           VARCHAR60 NOT NULL,
    REMARKS         VARCHAR255,
    UNIT_COST       FFLOAT,
    SALE_PRICE      FFLOAT,
    UPDATE_USER     VARCHAR10,
    CUST_CODE       VARCHAR10 NOT NULL,
    UOM_CD          VARCHAR4 NOT NULL,
    UPDATE_DATE     TIMESTAMP,
    STANDARD_PRICE  FFLOAT,
    CURRENT_ACTIVE  FLAG
);

CREATE TABLE SO_SALES_ITEM_REQ_SHEET (
    ITEM_CODE          VARCHAR15 NOT NULL,
    UOM_CD             VARCHAR4 NOT NULL,
    CUST_CODE          VARCHAR10 NOT NULL,
    MAX_ELE1           FLOAT,
    MAX_ELE2           FLOAT,
    MAX_ELE3           FLOAT,
    MAX_ELE4           FLOAT,
    MAX_ELE5           FLOAT,
    MAX_ELE6           FLOAT,
    MAX_ELE7           FLOAT,
    MAX_ELE8           FLOAT,
    MAX_ELE9           FLOAT,
    MAX_ELE10          FLOAT,
    MAX_ELE11          FLOAT,
    MAX_ELE12          FLOAT,
    MAX_ELE13          FLOAT,
    MAX_ELE14          FLOAT,
    MAX_ELE15          FLOAT,
    MIN_ELE1           FLOAT,
    MIN_ELE2           FLOAT,
    MIN_ELE3           FLOAT,
    MIN_ELE4           FLOAT,
    MIN_ELE5           FLOAT,
    MIN_ELE6           FLOAT,
    MIN_ELE7           FLOAT,
    MIN_ELE8           FLOAT,
    MIN_ELE9           FLOAT,
    MIN_ELE10          FLOAT,
    MIN_ELE11          FLOAT,
    MIN_ELE12          FLOAT,
    MIN_ELE13          FLOAT,
    MIN_ELE14          FLOAT,
    MIN_ELE15          FLOAT,
    ELABEL1            VARCHAR4,
    ELABEL2            VARCHAR4,
    ELABEL3            VARCHAR4,
    ELABEL4            VARCHAR4,
    ELABEL5            VARCHAR4,
    ELABEL6            VARCHAR4,
    ELABEL7            VARCHAR4,
    ELABEL8            VARCHAR4,
    ELABEL9            VARCHAR4,
    ELABEL10           VARCHAR4,
    ELABEL11           VARCHAR4,
    ELABEL12           VARCHAR4,
    ELABEL13           VARCHAR4,
    ELABEL14           VARCHAR4,
    ELABEL15           VARCHAR4,
    MIN_FLOAT_POINT1   SMALLINT,
    MIN_FLOAT_POINT2   SMALLINT,
    MIN_FLOAT_POINT3   SMALLINT,
    MIN_FLOAT_POINT4   SMALLINT,
    MIN_FLOAT_POINT5   SMALLINT,
    MIN_FLOAT_POINT6   SMALLINT,
    MIN_FLOAT_POINT7   SMALLINT,
    MIN_FLOAT_POINT8   SMALLINT,
    MIN_FLOAT_POINT9   SMALLINT,
    MIN_FLOAT_POINT10  SMALLINT,
    MIN_FLOAT_POINT11  SMALLINT,
    MIN_FLOAT_POINT12  SMALLINT,
    MIN_FLOAT_POINT13  SMALLINT,
    MAX_FLOAT_POINT1   SMALLINT,
    MAX_FLOAT_POINT2   SMALLINT,
    MAX_FLOAT_POINT3   SMALLINT,
    MAX_FLOAT_POINT4   SMALLINT,
    MAX_FLOAT_POINT5   SMALLINT,
    MAX_FLOAT_POINT6   SMALLINT,
    MAX_FLOAT_POINT7   SMALLINT,
    MAX_FLOAT_POINT8   SMALLINT,
    MAX_FLOAT_POINT9   SMALLINT,
    MAX_FLOAT_POINT10  SMALLINT,
    MAX_FLOAT_POINT11  SMALLINT,
    MAX_FLOAT_POINT12  SMALLINT,
    MAX_FLOAT_POINT13  SMALLINT,
    MIN_MASK1          VARCHAR30,
    MIN_MASK2          VARCHAR30,
    MIN_MASK3          VARCHAR30,
    MIN_MASK4          VARCHAR30,
    MIN_MASK5          VARCHAR30,
    MIN_MASK6          VARCHAR30,
    MIN_MASK7          VARCHAR30,
    MIN_MASK8          VARCHAR30,
    MIN_MASK9          VARCHAR30,
    MIN_MASK10         VARCHAR30,
    MIN_MASK11         VARCHAR30,
    MIN_MASK12         VARCHAR30,
    MIN_MASK13         VARCHAR30,
    MAX_MASK1          VARCHAR30,
    MAX_MASK2          VARCHAR30,
    MAX_MASK3          VARCHAR30,
    MAX_MASK4          VARCHAR30,
    MAX_MASK5          VARCHAR30,
    MAX_MASK6          VARCHAR30,
    MAX_MASK7          VARCHAR30,
    MAX_MASK8          VARCHAR30,
    MAX_MASK9          VARCHAR30,
    MAX_MASK10         VARCHAR30,
    MAX_MASK11         VARCHAR30,
    MAX_MASK12         VARCHAR30,
    MAX_MASK13         VARCHAR30,
    CUST_NAME          VARCHAR60,
    MIN_ELE16          FLOAT,
    MIN_ELE17          FLOAT,
    MIN_ELE18          FLOAT,
    MIN_ELE19          FLOAT,
    MIN_ELE20          FLOAT,
    MIN_ELE21          FLOAT,
    MIN_ELE22          FLOAT,
    MIN_ELE23          FLOAT,
    MIN_ELE24          FLOAT,
    MIN_ELE25          FLOAT,
    MAX_ELE16          FLOAT,
    MAX_ELE17          FLOAT,
    MAX_ELE18          FLOAT,
    MAX_ELE19          FLOAT,
    MAX_ELE20          FLOAT,
    MAX_ELE21          FLOAT,
    MAX_ELE22          FLOAT,
    MAX_ELE23          FLOAT,
    MAX_ELE24          FLOAT,
    MAX_ELE25          FLOAT,
    ELABEL16           VARCHAR4,
    ELABEL17           VARCHAR4,
    ELABEL18           VARCHAR4,
    ELABEL19           VARCHAR4,
    ELABEL20           VARCHAR4,
    ELABEL21           VARCHAR4,
    ELABEL22           VARCHAR4,
    ELABEL23           VARCHAR4,
    ELABEL24           VARCHAR4,
    ELABEL25           VARCHAR4,
    ELE1_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE2_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE3_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE4_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE5_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE6_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE7_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE8_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE9_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE10_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE11_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE12_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE13_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE14_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE15_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE16_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE17_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE18_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE19_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE20_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE21_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE22_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE23_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE24_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE25_ACTIVE       VARCHAR(1) DEFAULT 'N',
    MIN_FLOAT_POINT14  SMALLINT,
    MIN_FLOAT_POINT15  SMALLINT,
    MIN_FLOAT_POINT16  SMALLINT,
    MIN_FLOAT_POINT17  SMALLINT,
    MIN_FLOAT_POINT18  SMALLINT,
    MIN_FLOAT_POINT19  SMALLINT,
    MIN_FLOAT_POINT20  SMALLINT,
    MIN_FLOAT_POINT21  SMALLINT,
    MIN_FLOAT_POINT22  SMALLINT,
    MIN_FLOAT_POINT23  SMALLINT,
    MIN_FLOAT_POINT24  SMALLINT,
    MIN_FLOAT_POINT25  SMALLINT,
    MAX_FLOAT_POINT14  SMALLINT,
    MAX_FLOAT_POINT15  SMALLINT,
    MAX_FLOAT_POINT16  SMALLINT,
    MAX_FLOAT_POINT17  SMALLINT,
    MAX_FLOAT_POINT18  SMALLINT,
    MAX_FLOAT_POINT19  SMALLINT,
    MAX_FLOAT_POINT20  SMALLINT,
    MAX_FLOAT_POINT21  SMALLINT,
    MAX_FLOAT_POINT22  SMALLINT,
    MAX_FLOAT_POINT23  SMALLINT,
    MAX_FLOAT_POINT24  SMALLINT,
    MAX_FLOAT_POINT25  SMALLINT,
    MIN_MASK14         VARCHAR30,
    MIN_MASK15         VARCHAR30,
    MIN_MASK16         VARCHAR30,
    MIN_MASK17         VARCHAR30,
    MIN_MASK18         VARCHAR30,
    MIN_MASK19         VARCHAR30,
    MIN_MASK20         VARCHAR30,
    MIN_MASK21         VARCHAR30,
    MIN_MASK22         VARCHAR30,
    MIN_MASK23         VARCHAR30,
    MIN_MASK24         VARCHAR30,
    MIN_MASK25         VARCHAR30,
    MAX_MASK14         VARCHAR30,
    MAX_MASK15         VARCHAR30,
    MAX_MASK16         VARCHAR30,
    MAX_MASK17         VARCHAR30,
    MAX_MASK18         VARCHAR30,
    MAX_MASK19         VARCHAR30,
    MAX_MASK20         VARCHAR30,
    MAX_MASK21         VARCHAR30,
    MAX_MASK22         VARCHAR30,
    MAX_MASK23         VARCHAR30,
    MAX_MASK24         VARCHAR30,
    MAX_MASK25         VARCHAR30,
    PELE1_ACTIVE       VARCHAR(1) DEFAULT 'N',
    PELE2_ACTIVE       VARCHAR(1) DEFAULT 'N',
    PELE3_ACTIVE       VARCHAR(1) DEFAULT 'N',
    PELE4_ACTIVE       VARCHAR(1) DEFAULT 'N',
    PELE5_ACTIVE       VARCHAR(1) DEFAULT 'N',
    PELE6_ACTIVE       VARCHAR(1) DEFAULT 'N',
    PELE7_ACTIVE       VARCHAR(1) DEFAULT 'N',
    PELE8_ACTIVE       VARCHAR(1) DEFAULT 'N',
    PELE9_ACTIVE       VARCHAR(1) DEFAULT 'N',
    PELE10_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE11_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE12_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE13_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE14_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE15_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE16_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE17_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE18_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE19_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE20_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE21_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE22_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE23_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE24_ACTIVE      VARCHAR(1) DEFAULT 'N',
    PELE25_ACTIVE      VARCHAR(1) DEFAULT 'N'
);

CREATE TABLE SO_SALES_ITEM_REQ_SHEET_TEMP (
    ITEM_CODE          VARCHAR15 NOT NULL,
    UOM_CD             VARCHAR4 NOT NULL,
    CUST_CODE          VARCHAR10 NOT NULL,
    MAX_ELE1           FLOAT,
    MAX_ELE2           FLOAT,
    MAX_ELE3           FLOAT,
    MAX_ELE4           FLOAT,
    MAX_ELE5           FLOAT,
    MAX_ELE6           FLOAT,
    MAX_ELE7           FLOAT,
    MAX_ELE8           FLOAT,
    MAX_ELE9           FLOAT,
    MAX_ELE10          FLOAT,
    MAX_ELE11          FLOAT,
    MAX_ELE12          FLOAT,
    MAX_ELE13          FLOAT,
    MAX_ELE14          FLOAT,
    MAX_ELE15          FLOAT,
    MIN_ELE1           FLOAT,
    MIN_ELE2           FLOAT,
    MIN_ELE3           FLOAT,
    MIN_ELE4           FLOAT,
    MIN_ELE5           FLOAT,
    MIN_ELE6           FLOAT,
    MIN_ELE7           FLOAT,
    MIN_ELE8           FLOAT,
    MIN_ELE9           FLOAT,
    MIN_ELE10          FLOAT,
    MIN_ELE11          FLOAT,
    MIN_ELE12          FLOAT,
    MIN_ELE13          FLOAT,
    MIN_ELE14          FLOAT,
    MIN_ELE15          FLOAT,
    ELABEL1            VARCHAR4,
    ELABEL2            VARCHAR4,
    ELABEL3            VARCHAR4,
    ELABEL4            VARCHAR4,
    ELABEL5            VARCHAR4,
    ELABEL6            VARCHAR4,
    ELABEL7            VARCHAR4,
    ELABEL8            VARCHAR4,
    ELABEL9            VARCHAR4,
    ELABEL10           VARCHAR4,
    ELABEL11           VARCHAR4,
    ELABEL12           VARCHAR4,
    ELABEL13           VARCHAR4,
    ELABEL14           VARCHAR4,
    ELABEL15           VARCHAR4,
    MIN_FLOAT_POINT1   SMALLINT,
    MIN_FLOAT_POINT2   SMALLINT,
    MIN_FLOAT_POINT3   SMALLINT,
    MIN_FLOAT_POINT4   SMALLINT,
    MIN_FLOAT_POINT5   SMALLINT,
    MIN_FLOAT_POINT6   SMALLINT,
    MIN_FLOAT_POINT7   SMALLINT,
    MIN_FLOAT_POINT8   SMALLINT,
    MIN_FLOAT_POINT9   SMALLINT,
    MIN_FLOAT_POINT10  SMALLINT,
    MIN_FLOAT_POINT11  SMALLINT,
    MIN_FLOAT_POINT12  SMALLINT,
    MIN_FLOAT_POINT13  SMALLINT,
    MAX_FLOAT_POINT1   SMALLINT,
    MAX_FLOAT_POINT2   SMALLINT,
    MAX_FLOAT_POINT3   SMALLINT,
    MAX_FLOAT_POINT4   SMALLINT,
    MAX_FLOAT_POINT5   SMALLINT,
    MAX_FLOAT_POINT6   SMALLINT,
    MAX_FLOAT_POINT7   SMALLINT,
    MAX_FLOAT_POINT8   SMALLINT,
    MAX_FLOAT_POINT9   SMALLINT,
    MAX_FLOAT_POINT10  SMALLINT,
    MAX_FLOAT_POINT11  SMALLINT,
    MAX_FLOAT_POINT12  SMALLINT,
    MAX_FLOAT_POINT13  SMALLINT,
    MIN_MASK1          VARCHAR30,
    MIN_MASK2          VARCHAR30,
    MIN_MASK3          VARCHAR30,
    MIN_MASK4          VARCHAR30,
    MIN_MASK5          VARCHAR30,
    MIN_MASK6          VARCHAR30,
    MIN_MASK7          VARCHAR30,
    MIN_MASK8          VARCHAR30,
    MIN_MASK9          VARCHAR30,
    MIN_MASK10         VARCHAR30,
    MIN_MASK11         VARCHAR30,
    MIN_MASK12         VARCHAR30,
    MIN_MASK13         VARCHAR30,
    MAX_MASK1          VARCHAR30,
    MAX_MASK2          VARCHAR30,
    MAX_MASK3          VARCHAR30,
    MAX_MASK4          VARCHAR30,
    MAX_MASK5          VARCHAR30,
    MAX_MASK6          VARCHAR30,
    MAX_MASK7          VARCHAR30,
    MAX_MASK8          VARCHAR30,
    MAX_MASK9          VARCHAR30,
    MAX_MASK10         VARCHAR30,
    MAX_MASK11         VARCHAR30,
    MAX_MASK12         VARCHAR30,
    MAX_MASK13         VARCHAR30,
    MIN_ELE16          FLOAT,
    MIN_ELE17          FLOAT,
    MIN_ELE18          FLOAT,
    MIN_ELE19          FLOAT,
    MIN_ELE20          FLOAT,
    MIN_ELE21          FLOAT,
    MIN_ELE22          FLOAT,
    MIN_ELE23          FLOAT,
    MIN_ELE24          FLOAT,
    MIN_ELE25          FLOAT,
    MAX_ELE16          FLOAT,
    MAX_ELE17          FLOAT,
    MAX_ELE18          FLOAT,
    MAX_ELE19          FLOAT,
    MAX_ELE20          FLOAT,
    MAX_ELE21          FLOAT,
    MAX_ELE22          FLOAT,
    MAX_ELE23          FLOAT,
    MAX_ELE24          FLOAT,
    MAX_ELE25          FLOAT,
    ELABEL16           VARCHAR4,
    ELABEL17           VARCHAR4,
    ELABEL18           VARCHAR4,
    ELABEL19           VARCHAR4,
    ELABEL20           VARCHAR4,
    ELABEL21           VARCHAR4,
    ELABEL22           VARCHAR4,
    ELABEL23           VARCHAR4,
    ELABEL24           VARCHAR4,
    ELABEL25           VARCHAR4,
    ELE1_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE2_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE3_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE4_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE5_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE6_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE7_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE8_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE9_ACTIVE        VARCHAR(1) DEFAULT 'N',
    ELE10_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE11_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE12_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE13_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE14_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE15_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE16_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE17_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE18_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE19_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE20_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE21_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE22_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE23_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE24_ACTIVE       VARCHAR(1) DEFAULT 'N',
    ELE25_ACTIVE       VARCHAR(1) DEFAULT 'N',
    MIN_FLOAT_POINT14  SMALLINT,
    MIN_FLOAT_POINT15  SMALLINT,
    MIN_FLOAT_POINT16  SMALLINT,
    MIN_FLOAT_POINT17  SMALLINT,
    MIN_FLOAT_POINT18  SMALLINT,
    MIN_FLOAT_POINT19  SMALLINT,
    MIN_FLOAT_POINT20  SMALLINT,
    MIN_FLOAT_POINT21  SMALLINT,
    MIN_FLOAT_POINT22  SMALLINT,
    MIN_FLOAT_POINT23  SMALLINT,
    MIN_FLOAT_POINT24  SMALLINT,
    MIN_FLOAT_POINT25  SMALLINT,
    MAX_FLOAT_POINT14  SMALLINT,
    MAX_FLOAT_POINT15  SMALLINT,
    MAX_FLOAT_POINT16  SMALLINT,
    MAX_FLOAT_POINT17  SMALLINT,
    MAX_FLOAT_POINT18  SMALLINT,
    MAX_FLOAT_POINT19  SMALLINT,
    MAX_FLOAT_POINT20  SMALLINT,
    MAX_FLOAT_POINT21  SMALLINT,
    MAX_FLOAT_POINT22  SMALLINT,
    MAX_FLOAT_POINT23  SMALLINT,
    MAX_FLOAT_POINT24  SMALLINT,
    MAX_FLOAT_POINT25  SMALLINT,
    MIN_MASK14         VARCHAR30,
    MIN_MASK15         VARCHAR30,
    MIN_MASK16         VARCHAR30,
    MIN_MASK17         VARCHAR30,
    MIN_MASK18         VARCHAR30,
    MIN_MASK19         VARCHAR30,
    MIN_MASK20         VARCHAR30,
    MIN_MASK21         VARCHAR30,
    MIN_MASK22         VARCHAR30,
    MIN_MASK23         VARCHAR30,
    MIN_MASK24         VARCHAR30,
    MIN_MASK25         VARCHAR30,
    MAX_MASK14         VARCHAR30,
    MAX_MASK15         VARCHAR30,
    MAX_MASK16         VARCHAR30,
    MAX_MASK17         VARCHAR30,
    MAX_MASK18         VARCHAR30,
    MAX_MASK19         VARCHAR30,
    MAX_MASK20         VARCHAR30,
    MAX_MASK21         VARCHAR30,
    MAX_MASK22         VARCHAR30,
    MAX_MASK23         VARCHAR30,
    MAX_MASK24         VARCHAR30,
    MAX_MASK25         VARCHAR30
);

CREATE TABLE SO_SALES_ITEM_STOCK (
    ITEM_CODE     VARCHAR(15) NOT NULL,
    UOM_CD        VARCHAR(4) NOT NULL,
    ONHAND_QTY    FLOAT,
    RESERVED_QTY  FLOAT,
    CUST_CODE     VARCHAR10 NOT NULL,
    DOC_NO        VARCHAR(15) NOT NULL,
    DOC_DATE      TIMESTAMP NOT NULL,
    UNIT_COST     FLOAT,
    TOTAL_COST    FLOAT,
    MELT_NO       VARCHAR10 NOT NULL,
    BUNDLE_QTY    SSMALLINT NOT NULL
);

CREATE TABLE SUBSCRIBEDDB (
    REPLNO       INTEGER NOT NULL,
    DBNO         INTEGER NOT NULL,
    USERNAME     VARCHAR(31),
    PSWORD       VARCHAR(31),
    USERROLE     VARCHAR(50),
    COMMITCOUNT  INTEGER DEFAULT 0
);

CREATE TABLE SYS_CONFIGS (
    PRINTED_LOGO           VARCHAR(1) DEFAULT 'Y',
    PRINTED_LETTER_HEADER  VARCHAR(1) DEFAULT 'Y',
    PURCHASE_MARKUP_PERC   SMALLINT,
    SALE_MARKUP_PERC       SMALLINT,
    CLOSE_PO_AFTER         SMALLINT
);

CREATE TABLE SYS_FIELD_DEFS (
    FIELD_NAME      VARCHAR(30) NOT NULL,
    TABLE_NAME      VARCHAR(30) NOT NULL,
    FIELD_EN_DESCS  VARCHAR(80),
    FIELD_TH_DESCS  VARCHAR(80),
    FORM_NAME       VARCHAR(25),
    PROGRAM_NAME    VARCHAR60,
    ACCESS_FLAG     VARCHAR2
);

CREATE TABLE SYS_GROUPS (
    GROUP_ID           VARCHAR(4) NOT NULL,
    GROUP_NAME         VARCHAR(60),
    EDIT_FLAG          VARCHAR(1),
    DELETE_FLAG        VARCHAR(1),
    INSERT_FLAG        VARCHAR(1),
    UPDATE_USER        VARCHAR(10),
    UPDATE_DATE        TIMESTAMP,
    DEFAULT_MODULE_ID  VARCHAR(4),
    ADMIN_USER         VARCHAR(1),
    EXECUTE_FLAG       VARCHAR(1) DEFAULT 'N',
    POST_FLAG          VARCHAR(1) DEFAULT 'N'
);

CREATE TABLE SYS_ITEMS_MENUS (
    MODULE_ID     VARCHAR(4) NOT NULL,
    MENU_INDEX    SMALLINT NOT NULL,
    UPDATE_USER   VARCHAR(10),
    UPDATE_DATE   TIMESTAMP,
    MENU_CAPTION  VARCHAR(60) NOT NULL
);

CREATE TABLE SYS_KEY_INDEX (
    KEY_FIELD  VARCHAR15 NOT NULL,
    ENG_DESCS  VARCHAR60,
    TH_DESCS   VARCHAR60
);

CREATE TABLE SYS_MENUS (
    FORM_NAME        VARCHAR(25) NOT NULL,
    MENU_INDEX       SMALLINT NOT NULL,
    MODULE_ID        VARCHAR(4) NOT NULL,
    MENU_ITEM_INDEX  SMALLINT NOT NULL,
    FORM_CAPTION     VARCHAR(60),
    ENABLED          VARCHAR(1),
    UPDATE_DATE      TIMESTAMP,
    UPDATE_USER      VARCHAR(10),
    FORM_TAG         SMALLINT,
    HISTORY_CAPTION  VARCHAR60,
    MAIN_MENU_NAME   VARCHAR(30),
    REPORTID         VARCHAR60,
    QUERYSTRING      BLOB SUB_TYPE 1 SEGMENT SIZE 4096 CHARACTER SET UTF8
);

CREATE TABLE SYS_MODULES (
    MODULE_ID           VARCHAR(4) NOT NULL,
    MODULE_DESCRIPTION  VARCHAR(60) NOT NULL,
    UPDATE_USER         VARCHAR(10),
    UPDATE_DATE         TIMESTAMP
);

CREATE TABLE SYS_USER_MENUS (
    MODULE_ID        VARCHAR(4) NOT NULL,
    MENU_INDEX       SMALLINT NOT NULL,
    MENU_ITEM_INDEX  SMALLINT NOT NULL,
    FORM_NAME        VARCHAR(25) NOT NULL,
    GROUP_ID         VARCHAR(4) NOT NULL,
    USER_ID          VARCHAR(10) NOT NULL,
    EDIT_FLAG        VARCHAR(1) DEFAULT 'Y',
    DELETE_FLAG      VARCHAR(1) DEFAULT 'Y',
    INSERT_FLAG      VARCHAR(1) DEFAULT 'Y',
    EXECUTE_FLAG     VARCHAR(1) DEFAULT 'Y',
    POST_FLAG        VARCHAR(1) DEFAULT 'Y',
    FORM_CAPTION     VARCHAR(60),
    MAIN_MENU_NAME   VARCHAR(30) NOT NULL
);

CREATE TABLE SYS_USERS (
    USER_ID           VARCHAR(10) NOT NULL,
    USER_NAME         VARCHAR(60) NOT NULL,
    GROUP_ID          VARCHAR(4) NOT NULL,
    OLD_PASSWORD      VARCHAR(10),
    CURRENT_PASSWORD  VARCHAR(10),
    CONFIRM_PASSWORD  VARCHAR(10),
    UPDATE_USER       VARCHAR(10),
    UPDATE_DATE       TIMESTAMP,
    ACTIVED           VARCHAR(1) DEFAULT 'Y',
    DEFAULT_MODULE    VARCHAR60
);

CREATE TABLE TAX_SCHEM_HD (
    SCHEME_CD    VARCHAR2 NOT NULL,
    TAX_CD       VARCHAR2 NOT NULL,
    DESCS        VARCHAR45 NOT NULL,
    TAX_RATE     FFLOAT NOT NULL,
    UPDATE_USER  VARCHAR10,
    UPDATE_DATE  DDATE,
    INCL         FLAG NOT NULL
);

CREATE TABLE TB_COMPUTE (
    U_ID        SMALLINT NOT NULL,
    QTY         FLOAT DEFAULT 0,
    UNIT_COST   FLOAT DEFAULT 0,
    TOTAL_COST  COMPUTED BY (qty * unit_cost)
);

CREATE TABLE TEMP_BALANCE_FORWARD (
    STOCK_CD             VARCHAR15 NOT NULL,
    GROUP_ID             VARCHAR10 NOT NULL,
    UOM_CD               VARCHAR4 NOT NULL,
    LOT_CD               VARCHAR15 NOT NULL,
    UNIT_COST            FFLOAT NOT NULL,
    LAST_PURCHASE_PRICE  FFLOAT NOT NULL,
    PURCHASE_DATE        DDATE NOT NULL,
    ONHAND_QTY           FFLOAT NOT NULL,
    STOCK_VALUE          FFLOAT,
    TOTAL_COST           FFLOAT,
    ACCT_CODE            VARCHAR(10) NOT NULL,
    ORDER_LINE           SMALLINT NOT NULL,
    REF_NO               VARCHAR15 NOT NULL,
    REF_DATE             TIMESTAMP NOT NULL,
    BF_YEAR              SMALLINT NOT NULL,
    BF_MONTH             SMALLINT NOT NULL,
    DOC_DATE             TIMESTAMP NOT NULL
);

CREATE TABLE TRANSACTIONTYPE (
    TRX_TYPE           VARCHAR(2) NOT NULL,
    DESCRIPTION        VARCHAR(60),
    DEFAULT_MODULE     VARCHAR(60),
    UPDATE_USER        VARCHAR(10),
    UPDATE_DATE        TIMESTAMP,
    REQUIRE_REFERENCE  VARCHAR(1) DEFAULT 'Y',
    MODE               VARCHAR(1) NOT NULL,
    PREFIX             VARCHAR(10),
    CURRENT_NO         INTEGER
);

CREATE TABLE WITHHOLDING_TAX (
    WHTAX_CODE  VARCHAR(2) NOT NULL,
    WHTAX_RATE  FLOAT NOT NULL
);



/******************************************************************************/
/***                                 Views                                  ***/
/******************************************************************************/


/* View: V_MATERIAL_REQUEST */
CREATE VIEW V_MATERIAL_REQUEST(
    DOC_NO,
    DOC_DATE,
    REQ_BY,
    ISSUE_BY,
    MELT_NO,
    STATUS)
AS
select pl_req_hd.doc_no as "document No"  ,
 pl_req_hd.doc_date as "document Date"  ,
 pl_req_hd.req_by as "Request By"  ,
 pl_req_hd.issue_by as "Issue By"  ,
 pl_req_hd.melt_no as "Melt No",
 pl_req_hd.status as "Status"
from pl_req_hd
where status ='N'
;



/* View: V_RAWMATERIAL_PLAN */
CREATE VIEW V_RAWMATERIAL_PLAN(
    MELT_NO,
    PLAN_DOC,
    PLAN_DATE,
    ITEM_CODE)
AS
select distinct H.melt_no ,d.plan_doc ,d.plan_date,H.item_code FROM pl_rawmat_sheet_hd    H  ,pl_pro_plan_dt d
where h.melt_no = d.melt_no
and h.status ='N'
;



/* View: VW_PL_PRO_PLAN_LOGS */
CREATE VIEW VW_PL_PRO_PLAN_LOGS(
    MONTH_OF_PLAN,
    YEAR_OF_PLAN,
    FROM_MELT_NO,
    TO_MELT_NO,
    PLAN_DOCUMENT,
    DATE_OF_PLANING,
    STATUS)
AS
SELECT PMONTH ,
PYEAR ,
MFROM ,
MTO ,
PLAN_DOC ,
PLAN_DATE ,
STATUS
FROM
PL_PRO_PLAN_LOGS
;




/* Check constraints definition */

ALTER TABLE TB_COMPUTE ADD CHECK (qty BETWEEN 0 AND 5);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE AP_CREDITOR ADD PRIMARY KEY (CREDITOR_ACCT, CURRENCY_CODE, CREDITOR_TYPE);
ALTER TABLE AP_CREDITOR_TYPE ADD PRIMARY KEY (CREDITOR_TYPE);
ALTER TABLE AP_INVOICE_DT ADD PRIMARY KEY (CREDITOR_ACCT, DOC_DATE, DOC_NO, TRX_TYPE);
ALTER TABLE AP_INVOICE_HD ADD PRIMARY KEY (CREDITOR_ACCT, DOC_NO, DOC_DATE, TRX_TYPE);
ALTER TABLE AP_LEDGER ADD CONSTRAINT PK_AP_LEDGER PRIMARY KEY (DOC_NO, DOC_DATE, CREDITOR_ACCT, TRX_TYPE, REF_NO, REF_DATE);
ALTER TABLE AP_PAYMENT_DT ADD CONSTRAINT PK_AP_PAYMENT_DT PRIMARY KEY (DOC_NO, DOC_DATE, TRX_TYPE, CREDITOR_ACCT, LINE_NO);
ALTER TABLE AP_PAYMENT_HD ADD CONSTRAINT PK_AP_PAYMENT_HD PRIMARY KEY (DOC_NO, DOC_DATE, TRX_TYPE, CREDITOR_ACCT);
ALTER TABLE AP_PAY_DT ADD PRIMARY KEY (CREDITOR_ACCT, DOC_NO, DOC_DATE, INV_NO, INV_DATE);
ALTER TABLE AP_PAY_HD ADD PRIMARY KEY (CREDITOR_ACCT, DOC_NO, DOC_DATE);
ALTER TABLE AR_CREDIT_NOTE_DT ADD CONSTRAINT PK_AR_CREDIT_NOTE_DT PRIMARY KEY (DEBTOR_ACCT, DOC_NO, DOC_DATE, TRX_TYPE, LINE_NO);
ALTER TABLE AR_CREDIT_NOTE_HD ADD CONSTRAINT PK_AR_CREDIT_NOTE_HD PRIMARY KEY (DEBTOR_ACCT, DOC_NO, DOC_DATE, TRX_TYPE);
ALTER TABLE AR_DEBTOR ADD PRIMARY KEY (DEBTOR_ACCT, CURRENCY_CODE, DEBTOR_TYPE);
ALTER TABLE AR_DEBTOR_TYPE ADD PRIMARY KEY (DEBTOR_TYPE);
ALTER TABLE AR_INVOICE_DT ADD CONSTRAINT PK_AR_INVOICE_DT PRIMARY KEY (DEBTOR_ACCT, DOC_NO, DOC_DATE, TRX_TYPE, LINE_NO);
ALTER TABLE AR_INVOICE_HD ADD PRIMARY KEY (DEBTOR_ACCT, DOC_NO, DOC_DATE, TRX_TYPE);
ALTER TABLE AR_LEDGER ADD PRIMARY KEY (DOC_NO, DEBT_ACCT, DOC_DATE, DEBTOR_ACCT, CURRENCY_CODE, DEBTOR_TYPE, TRX_TYPE, REF_NO, REF_DATE);
ALTER TABLE AR_PAY_DT ADD PRIMARY KEY (DEBTOR_ACCT, DOC_NO, DOC_DATE, INV_NO, INV_DATE);
ALTER TABLE AR_PAY_HD ADD PRIMARY KEY (DEBTOR_ACCT, DOC_NO, DOC_DATE);
ALTER TABLE AR_RECEIPT_DT ADD CONSTRAINT PK_AR_RECEIPT_DT PRIMARY KEY (DOC_NO, DOC_DATE, DEBTOR_ACCT, LINE_NO);
ALTER TABLE AR_RECEIPT_HD ADD CONSTRAINT PK_AR_RECEIPT_HD PRIMARY KEY (DOC_NO, DOC_DATE, DEBTOR_ACCT);
ALTER TABLE BANK ADD PRIMARY KEY (BANK_CODE);
ALTER TABLE COMPANY_PROFILE ADD CONSTRAINT PK_COMPANY_PROFILE PRIMARY KEY (ENG_NAME);
ALTER TABLE COMPOSITIONCONTROL ADD PRIMARY KEY (COMPOSITIONCONTROLID);
ALTER TABLE CURRENCY ADD PRIMARY KEY (CURRENCY_CODE);
ALTER TABLE CUSTOMER_REQUIREMENT ADD CONSTRAINT PK_CUSTOMER_REQUIREMENT PRIMARY KEY (CUST_CODE);
ALTER TABLE DATABASES ADD PRIMARY KEY (DBNO);
ALTER TABLE DBVERSIONS ADD CONSTRAINT PK_DBVERSIONS PRIMARY KEY (VERSIONS);
ALTER TABLE DISCOUNT ADD PRIMARY KEY (DISCS_CD);
ALTER TABLE DOCUMENT_CONTROL ADD PRIMARY KEY (TRX_TYPE);
ALTER TABLE IC_BALANCE_FORWARD ADD PRIMARY KEY (STOCK_CD, GROUP_ID, UOM_CD, LOT_CD, PURCHASE_DATE, ACCT_CODE, REF_NO, REF_DATE, BF_YEAR, BF_MONTH);
ALTER TABLE IC_DEFINEDGROUP ADD PRIMARY KEY (DEF_CODE);
ALTER TABLE IC_ELEMENT ADD PRIMARY KEY (RUN_NO, ELEMENT_CODE);
ALTER TABLE IC_GROUP ADD PRIMARY KEY (GROUP_ID);
ALTER TABLE IC_MAT_DEFAULT_ELEMENT ADD PRIMARY KEY (STOCK_CD, GROUP_ID, UOM_CD);
ALTER TABLE IC_MAT_ELEMENT ADD PRIMARY KEY (STOCK_CD, GROUP_ID, UOM_CD, LOT_CD, PURCHASE_DATE, LINE_NO);
ALTER TABLE IC_MAT_STK_DT ADD PRIMARY KEY (STOCK_CD, GROUP_ID, UOM_CD, LOT_CD, PURCHASE_DATE, ACCT_CODE, ORDER_LINE);
ALTER TABLE IC_MAT_STK_DT_LINK ADD PRIMARY KEY (STOCK_CD, GROUP_ID, UOM_CD, LOT_CD, PURCHASE_DATE, ACCT_CODE, REF_NO, REF_DATE, ORDER_LINE);
ALTER TABLE IC_MAT_STK_HD ADD PRIMARY KEY (STOCK_CD, GROUP_ID, UOM_CD);
ALTER TABLE IC_MONTHLY_CLOSED ADD PRIMARY KEY (BF_YEAR, BF_MONTH);
ALTER TABLE IC_STOCKCARD ADD PRIMARY KEY (ACCT_CD, DOC_NO, DOC_DATE, REF_NO, REF_DATE, STOCK_CD, GROUP_ID, UOM_CD, LOT_CD, TRX_TYPE, ORDER_LINE);
ALTER TABLE IC_STOCK_ADJUST_DT ADD PRIMARY KEY (ITEM_CODE, UOM_CD, DOC_NO, DOC_DATE, GROUP_ID, LOT_NO, REF_NO, REF_DATE, ACCT_CD, PURCHASE_DATE);
ALTER TABLE IC_STOCK_ADJUST_HD ADD PRIMARY KEY (DOC_NO, DOC_DATE);
ALTER TABLE IC_STOCK_ADJUST_LOGS ADD PRIMARY KEY (ITEM_CODE, UOM_CD, DOC_NO, DOC_DATE, GROUP_ID, LOT_NO);
ALTER TABLE IC_STOCK_RESERVED ADD CONSTRAINT PK_IC_STOCK_RESERVED PRIMARY KEY (DOC_NO, DOC_DATE, LOT_CD, PURCHASE_DATE, REF_NO, REF_DATE, GROUP_ID, UOM_CD, STOCK_CD);
ALTER TABLE IC_UOM ADD PRIMARY KEY (UOM_CD);
ALTER TABLE IC_UOM_CONV ADD PRIMARY KEY (FROM_UOM, TO_UOM);
ALTER TABLE IC_WAREHOUSE ADD PRIMARY KEY (WH_NO);
ALTER TABLE LICENSES ADD PRIMARY KEY (LICENSENO);
ALTER TABLE MANUAL_LOG ADD PRIMARY KEY (REPLNO, PUBDBNO, SUBDBNO, SEQNO);
ALTER TABLE MELT_SUMMARY_FINISHED_GOODS ADD PRIMARY KEY (DOC_NO, MELT_NO, ITEM_CODE);
ALTER TABLE MELT_SUMMARY_METERIAL ADD PRIMARY KEY (DOC_NO, MELT_NO, ITEM_CODE, STOCK_CODE, UOM_CD, GROUP_ID, LOT_CD, PURCHASE_DATE, REF_NO, REF_DATE);
ALTER TABLE MELT_SUMMARY_METERIAL_LOT ADD CONSTRAINT PK_MELT_SUMMARY_METERIAL_LO PRIMARY KEY (DOC_NO, ITEM_CODE, STOCK_CODE, UOM_CD, GROUP_ID, LOT_CD, PURCHASE_DATE, REF_NO, REF_DATE);
ALTER TABLE PL_CLOSED_MELT_LOG ADD PRIMARY KEY (MELT_NO);
ALTER TABLE PL_DISPATCH_DT ADD PRIMARY KEY (DOC_NO, DOC_DATE, CUST_CODE, ORDER_NO, ORDER_DATE, DELIVERY_DATE, ITEM_CODE, UOM_CD, MELT_NO, LINE_NO);
ALTER TABLE PL_DISPATCH_HD ADD PRIMARY KEY (DOC_NO, DOC_DATE);
ALTER TABLE PL_DROSS_BALANCE ADD CONSTRAINT PK_PL_DROSS_BALANCE PRIMARY KEY (MELT_NO, DROSS_TYPE);
ALTER TABLE PL_DROSS_DT ADD CONSTRAINT PK_PL_DROSS_DT PRIMARY KEY (MELT_NO, DROSS_TYPE, RECEIVE_DOC, RECEIVE_DATE);
ALTER TABLE PL_DROSS_HD ADD CONSTRAINT PK_PL_DROSS_HD PRIMARY KEY (MELT_NO, RECEIVE_DOC, RECEIVE_DATE);
ALTER TABLE PL_DROSS_LEDGER ADD CONSTRAINT PK_PL_DROSS_LEDGER PRIMARY KEY (MELT_NO, DROSS_TYPE, TRX_DATE, TRX_NO);
ALTER TABLE PL_DROSS_TYPE ADD CONSTRAINT PK_PL_DROSS_TYPE PRIMARY KEY (DROSS_TYPE);
ALTER TABLE PL_FISYEAR ADD PRIMARY KEY (FMONTH, FYEAR, SDATE, EDATE);
ALTER TABLE PL_FNG_ADJ_DT ADD PRIMARY KEY (DOC_NO, DOC_DATE);
ALTER TABLE PL_FNG_ADJ_HD ADD PRIMARY KEY (DOC_NO, DOC_DATE);
ALTER TABLE PL_FNG_RET_DT ADD PRIMARY KEY (DOC_NO, DOC_DATE, CUST_CODE, MELT_NO);
ALTER TABLE PL_FNG_RET_HD ADD PRIMARY KEY (DOC_NO, DOC_DATE, CUST_CODE, MELT_NO);
ALTER TABLE PL_FN_RECEIVE_DT ADD PRIMARY KEY (DOC_NO, DOC_DATE, ITEM_CODE, MELT_NO, LINE_NO);
ALTER TABLE PL_FN_RECEIVE_HD ADD PRIMARY KEY (DOC_NO, DOC_DATE, MELT_NO, ITEM_CODE);
ALTER TABLE PL_MELT ADD PRIMARY KEY (MELT_ID);
ALTER TABLE PL_MELT_NO_ADDIGNED ADD PRIMARY KEY (MELT_NO);
ALTER TABLE PL_MELT_TEMPLATE ADD PRIMARY KEY (ITEM_CODE, UOM_CD, CUST_CODE);
ALTER TABLE PL_PRO_PLAN_DISP_DT ADD PRIMARY KEY (PLAN_DATE, PLAN_DOC, TRX_TYPE, CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, MELT_NO, SCHEDULE_DATE);
ALTER TABLE PL_PRO_PLAN_DT ADD PRIMARY KEY (PLAN_DATE, PLAN_DOC, TRX_TYPE, CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, MELT_NO, LINE_NO);
ALTER TABLE PL_PRO_PLAN_HD ADD PRIMARY KEY (PLAN_DATE, PLAN_DOC, TRX_TYPE);
ALTER TABLE PL_PRO_PLAN_LOGS ADD PRIMARY KEY (PMONTH, PYEAR, PLAN_DOC, PLAN_DATE, MFROM, MTO);
ALTER TABLE PL_RAWMAT_PLAN_DT ADD PRIMARY KEY (PLAN_DOC, PLAN_DATE, ITEM_CODE, GROUP_ID, UOM);
ALTER TABLE PL_RAWMAT_PLAN_HD ADD PRIMARY KEY (PLAN_DOC, PLAN_DATE);
ALTER TABLE PL_RAWMAT_SHEET_DT ADD PRIMARY KEY (PLAN_DOC, PLAN_DATE, MELT_NO, ITEM_CODE, STOCK_CODE, GROUP_ID, LOT_NO, UOM, CUST_CODE, LINE_NO);
ALTER TABLE PL_RAWMAT_SHEET_HD ADD PRIMARY KEY (PLAN_DOC, PLAN_DATE, MELT_NO, ITEM_CODE, CUST_CODE);
ALTER TABLE PL_RAWMAT_SHEET_ITEM_REQ ADD PRIMARY KEY (PLAN_DOC, PLAN_DATE, MELT_NO, ITEM_CODE, CUST_CODE);
ALTER TABLE PL_REQ_DT ADD CONSTRAINT PK_PL_REQ_DT PRIMARY KEY (DOC_NO, DOC_DATE, TRX_TYPE, ITEM_CODE, LOT_NO, PURCHASE_DATE, GROUP_ID, UOM, REF_NO, REF_DATE, ACCT_CD);
ALTER TABLE PL_REQ_HD ADD PRIMARY KEY (DOC_NO, DOC_DATE, TRX_TYPE);
ALTER TABLE PO_GRN_DT ADD PRIMARY KEY (SUPP_CODE, GRN_NO, GRN_DATE, ITEM_CODE, GRN_LINE);
ALTER TABLE PO_GRN_HD ADD PRIMARY KEY (SUPP_CODE, GRN_DATE, GRN_NO);
ALTER TABLE PO_ORDER_DT ADD PRIMARY KEY (SUPP_CODE, ORDER_DATE, ITEM_CODE, ORDER_NO, GROUP_ID, LOT_NO, LINE_NO);
ALTER TABLE PO_ORDER_HD ADD PRIMARY KEY (SUPP_CODE, ORDER_DATE, ORDER_NO);
ALTER TABLE PO_SUPPLIER ADD PRIMARY KEY (SUPPLIER_CD, CREDITOR_ACCT, NAME);
ALTER TABLE PUBLISHEDDB ADD PRIMARY KEY (REPLNO, DBNO);
ALTER TABLE RELATIONKEYFIELDS ADD PRIMARY KEY (REPLNO, DBNO, TGTDBNO, RELATIONNO, FIELDNO);
ALTER TABLE RELATIONREPLFIELDS ADD PRIMARY KEY (REPLNO, DBNO, TGTDBNO, RELATIONNO, FIELDNO);
ALTER TABLE RELATIONS ADD PRIMARY KEY (REPLNO, DBNO, TGTDBNO, RELATIONNO);
ALTER TABLE REPLTIMES ADD PRIMARY KEY (ID);
ALTER TABLE REPL_LOG ADD PRIMARY KEY (REPLNO, PUBDBNO, SUBDBNO, SEQNO);
ALTER TABLE REPL_SEPARATOR ADD PRIMARY KEY (REPLNO, PUBDBNO, SUBDBNO, RELATIONNO);
ALTER TABLE RESULT_CHECK_PLATE ADD PRIMARY KEY (MELT_NO, CUST_CODE, ITEM_CODE, EXPECT_LINE);
ALTER TABLE SCHEMATA ADD PRIMARY KEY (REPLNO);
ALTER TABLE SO_COMPONENTS_DETAIL ADD CONSTRAINT PK_SO_COMPONENTS_DETAIL PRIMARY KEY (CUST_CODE, ITEM_CODE);
ALTER TABLE SO_CUSTOMERS ADD PRIMARY KEY (DEBTOR_ACCT, CUSTOMER_CD, NAME);
ALTER TABLE SO_DET_DT ADD CONSTRAINT PK_SO_DET_DT PRIMARY KEY (DELIVERY_NO, DELIVERY_DATE, CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, MELT_NO, BUNDLE_NO);
ALTER TABLE SO_DET_DT_LINK ADD CONSTRAINT PK_SO_DET_DT_LINK PRIMARY KEY (DELIVERY_NO, DELIVERY_DATE, BATCH_NO, MELT_NO, REF_NO, REF_DATE, BUNDLE_NO);
ALTER TABLE SO_DET_DT_MELT ADD CONSTRAINT PK_SO_DET_DT_MELT PRIMARY KEY (DELIVERY_NO, DELIVERY_DATE, BATCH_NO, MELT_NO, REF_NO, REF_DATE, START_BUNDLE);
ALTER TABLE SO_DET_DT_ORDER ADD CONSTRAINT PK_SO_DET_DT_ORDER PRIMARY KEY (DELIVERY_NO, DELIVERY_DATE, ORDER_NO, ORDER_DATE, CUST_CODE, ITEM_CODE, UOM, BATCH_NO);
ALTER TABLE SO_DET_HD ADD PRIMARY KEY (DELIVERY_NO, DELIVERY_DATE, CUST_CODE);
ALTER TABLE SO_INVOICE_DT ADD PRIMARY KEY (CUST_CODE, DOC_NO, DOC_DATE, ITEM_CODE, LINE_NO);
ALTER TABLE SO_INVOICE_HD ADD PRIMARY KEY (DOC_NO, DOC_DATE, CUST_CODE);
ALTER TABLE SO_LEDGER ADD PRIMARY KEY (CUST_CODE, DOC_NO, DOC_DATE, REF_NO, REF_DATE, ITEM_CODE, LINE_NO);
ALTER TABLE SO_ORDER_DT ADD PRIMARY KEY (CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, LINE_NO);
ALTER TABLE SO_ORDER_DT_STOCK ADD PRIMARY KEY (CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, LINE_NO, DELIVERY_DATE, MELT_NO);
ALTER TABLE SO_ORDER_HD ADD PRIMARY KEY (CUST_CODE, ORDER_NO, ORDER_DATE);
ALTER TABLE SO_ORDER_REVISION_DT ADD PRIMARY KEY (CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, DOC_DATE, DOC_NO, LINE_NO);
ALTER TABLE SO_ORDER_REVISION_HD ADD PRIMARY KEY (DOC_DATE, DOC_NO);
ALTER TABLE SO_ORDER_SCH_DT ADD CONSTRAINT PK_SO_ORDER_SCH_DT PRIMARY KEY (CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, LINE_NO, SCHEDULE_DATE);
ALTER TABLE SO_QUOTATION_DT ADD PRIMARY KEY (DOC_NO, CUST_CODE, DOC_DATE, ITEM_CODE, UOM);
ALTER TABLE SO_QUOTATION_HD ADD PRIMARY KEY (CUST_CODE, DOC_NO, DOC_DATE);
ALTER TABLE SO_SALES_ITEM_DT ADD PRIMARY KEY (ITEM_CODE, STOCK_CD, UOM_CD, GROUP_ID, CUST_CODE);
ALTER TABLE SO_SALES_ITEM_HD ADD PRIMARY KEY (ITEM_CODE, UOM_CD, CUST_CODE);
ALTER TABLE SO_SALES_ITEM_REQ_SHEET ADD PRIMARY KEY (ITEM_CODE, UOM_CD, CUST_CODE);
ALTER TABLE SO_SALES_ITEM_REQ_SHEET_TEMP ADD PRIMARY KEY (ITEM_CODE, UOM_CD, CUST_CODE);
ALTER TABLE SO_SALES_ITEM_STOCK ADD PRIMARY KEY (DOC_DATE, ITEM_CODE, UOM_CD, DOC_NO, CUST_CODE);
ALTER TABLE SUBSCRIBEDDB ADD PRIMARY KEY (REPLNO, DBNO);
ALTER TABLE SYS_FIELD_DEFS ADD PRIMARY KEY (FIELD_NAME, TABLE_NAME);
ALTER TABLE SYS_GROUPS ADD PRIMARY KEY (GROUP_ID);
ALTER TABLE SYS_ITEMS_MENUS ADD PRIMARY KEY (MODULE_ID, MENU_INDEX);
ALTER TABLE SYS_KEY_INDEX ADD PRIMARY KEY (KEY_FIELD);
ALTER TABLE SYS_MENUS ADD PRIMARY KEY (MENU_INDEX, MENU_ITEM_INDEX, FORM_NAME, MODULE_ID);
ALTER TABLE SYS_MODULES ADD PRIMARY KEY (MODULE_ID);
ALTER TABLE SYS_USERS ADD PRIMARY KEY (USER_ID, GROUP_ID);
ALTER TABLE SYS_USER_MENUS ADD PRIMARY KEY (MODULE_ID, GROUP_ID, USER_ID, MENU_INDEX, MENU_ITEM_INDEX, FORM_NAME, MAIN_MENU_NAME);
ALTER TABLE TAX_SCHEM_HD ADD PRIMARY KEY (SCHEME_CD, TAX_CD);
ALTER TABLE TB_COMPUTE ADD PRIMARY KEY (U_ID);
ALTER TABLE TRANSACTIONTYPE ADD PRIMARY KEY (TRX_TYPE);
ALTER TABLE WITHHOLDING_TAX ADD PRIMARY KEY (WHTAX_CODE);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE PUBLISHEDDB ADD CONSTRAINT REPL$C_PUBLISHED_DB FOREIGN KEY (DBNO) REFERENCES DATABASES (DBNO);
ALTER TABLE PUBLISHEDDB ADD CONSTRAINT REPL$C_PUBLISHED_SCHEMATA FOREIGN KEY (REPLNO) REFERENCES SCHEMATA (REPLNO);
ALTER TABLE RELATIONKEYFIELDS ADD CONSTRAINT REPL$C_KEYS_RELATIONS FOREIGN KEY (REPLNO, DBNO, TGTDBNO, RELATIONNO) REFERENCES RELATIONS (REPLNO, DBNO, TGTDBNO, RELATIONNO);
ALTER TABLE RELATIONREPLFIELDS ADD CONSTRAINT REPL$C_FIELDS_RELATIONS FOREIGN KEY (REPLNO, DBNO, TGTDBNO, RELATIONNO) REFERENCES RELATIONS (REPLNO, DBNO, TGTDBNO, RELATIONNO);
ALTER TABLE RELATIONS ADD CONSTRAINT REPL$C_RELATIONS_PUBLISHED FOREIGN KEY (REPLNO, DBNO) REFERENCES PUBLISHEDDB (REPLNO, DBNO);
ALTER TABLE SUBSCRIBEDDB ADD CONSTRAINT REPL$C_SUBSCRIBED_DB FOREIGN KEY (DBNO) REFERENCES DATABASES (DBNO);
ALTER TABLE SUBSCRIBEDDB ADD CONSTRAINT REPL$C_SUBSCRIBED_SCHEMATA FOREIGN KEY (REPLNO) REFERENCES SCHEMATA (REPLNO);


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX IDX_NAME ON AP_CREDITOR (NAME);
CREATE INDEX XIF10AP_CREDITOR ON AP_CREDITOR (CREDITOR_TYPE);
CREATE UNIQUE INDEX XPKAP_CREDITOR ON AP_CREDITOR (CREDITOR_ACCT, CURRENCY_CODE, CREDITOR_TYPE);
CREATE UNIQUE INDEX XPKAP_CREDITOR_TYPE ON AP_CREDITOR_TYPE (CREDITOR_TYPE);
CREATE UNIQUE INDEX XPKAP_INVOICE_DT ON AP_INVOICE_DT (CREDITOR_ACCT, DOC_DATE, DOC_NO, TRX_TYPE);
CREATE UNIQUE INDEX XPKAP_INVOICE_HD ON AP_INVOICE_HD (CREDITOR_ACCT, DOC_NO, DOC_DATE, TRX_TYPE);
CREATE INDEX XIF11AP_LEDGER ON AP_LEDGER (CREDITOR_ACCT, CURRENCY_CODE, CREDITOR_TYPE);
CREATE INDEX XIF13AP_LEDGER ON AP_LEDGER (CURRENCY_CODE);
CREATE INDEX XIF17AP_LEDGER ON AP_LEDGER (CREDITOR_TYPE);
CREATE INDEX XIF90AP_PAY_DT ON AP_PAY_DT (CREDITOR_ACCT, DOC_NO, DOC_DATE);
CREATE UNIQUE INDEX XPKAP_PAY_DT ON AP_PAY_DT (CREDITOR_ACCT, DOC_NO, DOC_DATE, INV_NO, INV_DATE);
CREATE UNIQUE INDEX XPKAP_PAY_HD ON AP_PAY_HD (CREDITOR_ACCT, DOC_NO, DOC_DATE);
CREATE INDEX XIF61AR_DEBTOR ON AR_DEBTOR (CURRENCY_CODE);
CREATE INDEX XIF8AR_DEBTOR ON AR_DEBTOR (DEBTOR_TYPE);
CREATE UNIQUE INDEX XPKAR_DEBTOR ON AR_DEBTOR (DEBTOR_ACCT, CURRENCY_CODE, DEBTOR_TYPE);
CREATE UNIQUE INDEX XPKAR_DEBTOR_TYPE ON AR_DEBTOR_TYPE (DEBTOR_TYPE);
CREATE INDEX AR_INVOICE_DT_IDX1 ON AR_INVOICE_DT (DOC_NO, DOC_DATE, TRX_TYPE, LINE_NO, ORDER_NO, DELIVERY_NO);
CREATE UNIQUE INDEX XPKAR_INVOICE_HD ON AR_INVOICE_HD (DEBTOR_ACCT, DOC_NO, DOC_DATE, TRX_TYPE);
CREATE INDEX XIF34AR_LEDGER ON AR_LEDGER (DEBTOR_TYPE);
CREATE INDEX XIF51AR_LEDGER ON AR_LEDGER (DEBTOR_ACCT, CURRENCY_CODE, DEBTOR_TYPE);
CREATE INDEX XIF87AR_PAY_DT ON AR_PAY_DT (DEBTOR_ACCT, DOC_NO, DOC_DATE);
CREATE UNIQUE INDEX XPKAR_PAY_DT ON AR_PAY_DT (DEBTOR_ACCT, DOC_NO, DOC_DATE, INV_NO, INV_DATE);
CREATE UNIQUE INDEX XPKAR_PAY_HD ON AR_PAY_HD (DEBTOR_ACCT, DOC_NO, DOC_DATE);
CREATE UNIQUE INDEX XPKBANK ON BANK (BANK_CODE);
CREATE UNIQUE INDEX XPKCURRENCY ON CURRENCY (CURRENCY_CODE);
CREATE UNIQUE INDEX XPKDISCOUNT ON DISCOUNT (DISCS_CD);
CREATE UNIQUE INDEX XPKDOCUMENT_CONTROL ON DOCUMENT_CONTROL (TRX_TYPE);
CREATE UNIQUE INDEX XPKIC_ELEMENT ON IC_ELEMENT (RUN_NO, ELEMENT_CODE);
CREATE UNIQUE INDEX XPKIC_GROUP ON IC_GROUP (GROUP_ID);
CREATE UNIQUE INDEX XPKIC_MAT_DEFAULT_ELEMENT ON IC_MAT_DEFAULT_ELEMENT (STOCK_CD, GROUP_ID, UOM_CD);
CREATE UNIQUE INDEX XPKIC_MAT_STK_DT ON IC_MAT_STK_DT (STOCK_CD, GROUP_ID, UOM_CD, LOT_CD, PURCHASE_DATE, ACCT_CODE, ORDER_LINE);
CREATE INDEX IC_MAT_STK_HD_IDX1 ON IC_MAT_STK_HD (STOCK_CD);
CREATE INDEX XIF17IC_MAT_STK_HD ON IC_MAT_STK_HD (UOM_CD);
CREATE INDEX XIF18IC_MAT_STK_HD ON IC_MAT_STK_HD (GROUP_ID);
CREATE UNIQUE INDEX XPKIC_MAT_STK_HD ON IC_MAT_STK_HD (STOCK_CD, GROUP_ID, UOM_CD);
CREATE INDEX XIF24IC_STOCKCARD ON IC_STOCKCARD (STOCK_CD, GROUP_ID, UOM_CD);
CREATE INDEX XIF25IC_STOCKCARD ON IC_STOCKCARD (STOCK_CD, GROUP_ID, UOM_CD, LOT_CD);
CREATE UNIQUE INDEX XPKIC_STOCKCARD ON IC_STOCKCARD (ACCT_CD, DOC_NO, DOC_DATE, REF_NO, REF_DATE, STOCK_CD, GROUP_ID, UOM_CD, LOT_CD, ORDER_LINE);
CREATE INDEX XIF29IC_STOCK_ADJUST_DT ON IC_STOCK_ADJUST_DT (DOC_NO, DOC_DATE);
CREATE UNIQUE INDEX XPKIC_STOCK_ADJUST_HD ON IC_STOCK_ADJUST_HD (DOC_NO, DOC_DATE);
CREATE UNIQUE INDEX XPKIC_STOCK_ADJUST_LOGS ON IC_STOCK_ADJUST_LOGS (ITEM_CODE, UOM_CD, DOC_NO, DOC_DATE, GROUP_ID, LOT_NO);
CREATE UNIQUE INDEX XPKIC_UOM ON IC_UOM (UOM_CD);
CREATE INDEX MELT_ELEMENT_LABEL_IDX1 ON MELT_ELEMENT_LABEL (DOC_NO);
CREATE INDEX MELT_SUMMARY_FINAL_BLEND_IDX1 ON MELT_SUMMARY_FINAL_BLEND (DOC_NO);
CREATE INDEX PL_DISPATCH_DT_IDX1 ON PL_DISPATCH_DT (DELIVERY_DATE);
CREATE INDEX XIF29PL_DISPATCH_DT ON PL_DISPATCH_DT (DOC_NO, DOC_DATE);
CREATE UNIQUE INDEX XPKPL_DISPATCH_DT ON PL_DISPATCH_DT (DOC_NO, DOC_DATE, CUST_CODE, ORDER_NO, ORDER_DATE, DELIVERY_DATE, ITEM_CODE, UOM_CD, MELT_NO, LINE_NO);
CREATE UNIQUE INDEX XPKPL_DISPATCH_HD ON PL_DISPATCH_HD (DOC_NO, DOC_DATE);
CREATE UNIQUE INDEX XPKPL_FNG_ADJ_DT ON PL_FNG_ADJ_DT (DOC_NO, DOC_DATE);
CREATE UNIQUE INDEX XPKPL_FNG_ADJ_HD ON PL_FNG_ADJ_HD (DOC_NO, DOC_DATE);
CREATE UNIQUE INDEX XPKPL_FNG_RET_DT ON PL_FNG_RET_DT (DOC_NO, DOC_DATE, CUST_CODE, MELT_NO);
CREATE UNIQUE INDEX XPKPL_FNG_RET_HD ON PL_FNG_RET_HD (DOC_NO, DOC_DATE, CUST_CODE, MELT_NO);
CREATE INDEX XIF63PL_FN_RECEIVE_DT ON PL_FN_RECEIVE_DT (DOC_NO, DOC_DATE, MELT_NO, ITEM_CODE);
CREATE UNIQUE INDEX XPKPL_FN_RECEIVE_DT ON PL_FN_RECEIVE_DT (DOC_NO, DOC_DATE, ITEM_CODE, MELT_NO, LINE_NO);
CREATE UNIQUE INDEX XPKPL_FN_RECEIVE_HD ON PL_FN_RECEIVE_HD (DOC_NO, DOC_DATE, MELT_NO, ITEM_CODE);
CREATE UNIQUE INDEX XPKPL_MELT ON PL_MELT (MELT_ID);
CREATE INDEX XIF99PL_PRO_PLAN_DISP_DT ON PL_PRO_PLAN_DISP_DT (PLAN_DATE, PLAN_DOC, TRX_TYPE, CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, MELT_NO);
CREATE UNIQUE INDEX XPKPL_PRO_PLAN_DISP_DT ON PL_PRO_PLAN_DISP_DT (PLAN_DATE, PLAN_DOC, TRX_TYPE, CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, MELT_NO, SCHEDULE_DATE);
CREATE INDEX PL_PRO_PLAN_DT_MELT_LINE ON PL_PRO_PLAN_DT (PLAN_DOC, PLAN_DATE, MELT_NO);
CREATE UNIQUE INDEX XPKPL_PRO_PLAN_DT ON PL_PRO_PLAN_DT (PLAN_DATE, PLAN_DOC, TRX_TYPE, LINE_NO, CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, MELT_NO);
CREATE UNIQUE INDEX XPKPL_PRO_PLAN_HD ON PL_PRO_PLAN_HD (PLAN_DATE, PLAN_DOC, TRX_TYPE);
CREATE UNIQUE INDEX XPKPL_RAWMAT_PLAN_HD ON PL_RAWMAT_PLAN_HD (PLAN_DOC, PLAN_DATE);
CREATE INDEX XIF27PL_RAWMAT_SHEET_DT ON PL_RAWMAT_SHEET_DT (PLAN_DOC, PLAN_DATE, MELT_NO, ITEM_CODE, CUST_CODE);
CREATE UNIQUE INDEX XPKPL_RAWMAT_SHEET_DT ON PL_RAWMAT_SHEET_DT (PLAN_DOC, PLAN_DATE, MELT_NO, ITEM_CODE, STOCK_CODE, GROUP_ID, LOT_NO, UOM, CUST_CODE, LINE_NO);
CREATE UNIQUE INDEX XPKPL_RAWMAT_SHEET_HD ON PL_RAWMAT_SHEET_HD (PLAN_DOC, PLAN_DATE, MELT_NO, ITEM_CODE, CUST_CODE);
CREATE UNIQUE INDEX PL_REQ_DT_IDX1 ON PL_REQ_DT (DOC_NO, DOC_DATE, TRX_TYPE, GROUP_ID, LOT_NO, ITEM_CODE, PURCHASE_DATE, REF_NO, REF_DATE, ACCT_CD);
CREATE UNIQUE INDEX XPKPL_REQ_HD ON PL_REQ_HD (DOC_NO, DOC_DATE, TRX_TYPE);
CREATE INDEX XIF77PO_GRN_DT ON PO_GRN_DT (SUPP_CODE, GRN_DATE, GRN_NO);
CREATE UNIQUE INDEX XPKPO_GRN_DT ON PO_GRN_DT (SUPP_CODE, GRN_NO, GRN_DATE, ITEM_CODE, GRN_LINE);
CREATE UNIQUE INDEX XPKPO_GRN_HD ON PO_GRN_HD (SUPP_CODE, GRN_DATE, GRN_NO);
CREATE UNIQUE INDEX XPKPO_ORDER_DT ON PO_ORDER_DT (SUPP_CODE, ORDER_DATE, ITEM_CODE, ORDER_NO, LINE_NO);
CREATE INDEX PO_ORDER_HD_IDX_ORDER_NO ON PO_ORDER_HD (ORDER_NO);
CREATE UNIQUE INDEX XPKPO_ORDER_HD ON PO_ORDER_HD (SUPP_CODE, ORDER_DATE, ORDER_NO);
CREATE INDEX PO_SUPPLIER_NAME_IDX ON PO_SUPPLIER (NAME);
CREATE UNIQUE INDEX XPKPO_SUPPLIER ON PO_SUPPLIER (SUPPLIER_CD, CREDITOR_ACCT, NAME);
CREATE UNIQUE INDEX REPL$I_RELATIONS ON RELATIONS (REPLNO, DBNO, TGTDBNO, RELATIONNAME);
CREATE INDEX I_REPL_LOG ON REPL_LOG (SEQNO);
CREATE UNIQUE INDEX XPKSO_CUSTOMERS ON SO_CUSTOMERS (DEBTOR_ACCT, CUSTOMER_CD, NAME);
CREATE INDEX SO_DET_DT_IDX1 ON SO_DET_DT (DELIVERY_NO, DELIVERY_DATE, CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, MELT_NO, BUNDLE_NO);
CREATE INDEX SO_DET_DT_IDX2 ON SO_DET_DT (DELIVERY_NO, DELIVERY_DATE);
CREATE UNIQUE INDEX XPKSO_DET_HD ON SO_DET_HD (DELIVERY_NO, DELIVERY_DATE, CUST_CODE);
CREATE INDEX XIF54SO_INVOICE_DT ON SO_INVOICE_DT (DOC_NO, DOC_DATE, CUST_CODE);
CREATE UNIQUE INDEX XPKSO_INVOICE_DT ON SO_INVOICE_DT (CUST_CODE, DOC_NO, DOC_DATE, ITEM_CODE, LINE_NO);
CREATE UNIQUE INDEX XPKSO_INVOICE_HD ON SO_INVOICE_HD (DOC_NO, DOC_DATE, CUST_CODE);
CREATE UNIQUE INDEX XPKSO_LEDGER ON SO_LEDGER (CUST_CODE, DOC_NO, DOC_DATE, REF_NO, REF_DATE, ITEM_CODE, LINE_NO);
CREATE INDEX XIF55SO_ORDER_DT ON SO_ORDER_DT (CUST_CODE, ORDER_NO, ORDER_DATE);
CREATE UNIQUE INDEX XPKSO_ORDER_DT ON SO_ORDER_DT (CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, LINE_NO);
CREATE UNIQUE INDEX XPKSO_ORDER_HD ON SO_ORDER_HD (CUST_CODE, ORDER_NO, ORDER_DATE);
CREATE INDEX XIF36SO_ORDER_REVISION_DT ON SO_ORDER_REVISION_DT (DOC_DATE, DOC_NO);
CREATE UNIQUE INDEX XPKSO_ORDER_REVISION_DT ON SO_ORDER_REVISION_DT (CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, DOC_DATE, DOC_NO, LINE_NO);
CREATE UNIQUE INDEX XPKSO_ORDER_REVISION_HD ON SO_ORDER_REVISION_HD (DOC_DATE, DOC_NO);
CREATE UNIQUE INDEX XPKSO_ORDER_SCH_DT ON SO_ORDER_SCH_DT (CUST_CODE, ORDER_NO, ORDER_DATE, ITEM_CODE, LINE_NO, SCHEDULE_DATE);
CREATE INDEX XIF56SO_QUOTATION_DT ON SO_QUOTATION_DT (CUST_CODE, DOC_NO, DOC_DATE);
CREATE UNIQUE INDEX XPKSO_QUOTATION_DT ON SO_QUOTATION_DT (DOC_NO, CUST_CODE, DOC_DATE, ITEM_CODE, UOM);
CREATE UNIQUE INDEX XPKSO_QUOTATION_HD ON SO_QUOTATION_HD (CUST_CODE, DOC_NO, DOC_DATE);
CREATE INDEX XIF16SO_SALES_ITEM_DT ON SO_SALES_ITEM_DT (ITEM_CODE, UOM_CD, CUST_CODE);
CREATE INDEX XIF24SO_SALES_ITEM_DT ON SO_SALES_ITEM_DT (STOCK_CD, GROUP_ID, UOM_CD);
CREATE UNIQUE INDEX XPKSO_SALES_ITEM_DT ON SO_SALES_ITEM_DT (ITEM_CODE, STOCK_CD, UOM_CD, GROUP_ID, CUST_CODE);
CREATE UNIQUE INDEX XPKSO_SALES_ITEM_HD ON SO_SALES_ITEM_HD (ITEM_CODE, UOM_CD, CUST_CODE);
CREATE UNIQUE INDEX XPKSO_SALES_ITEM_REQ_SHEET ON SO_SALES_ITEM_REQ_SHEET (ITEM_CODE, UOM_CD, CUST_CODE);
CREATE UNIQUE INDEX XPKSO_SALES_ITEM_REQ_SHEET_TEMP ON SO_SALES_ITEM_REQ_SHEET_TEMP (ITEM_CODE, UOM_CD, CUST_CODE);
CREATE INDEX XIF31SO_SALES_ITEM_STOCK ON SO_SALES_ITEM_STOCK (ITEM_CODE, UOM_CD, CUST_CODE);
CREATE UNIQUE INDEX XPKSO_SALES_ITEM_STOCK ON SO_SALES_ITEM_STOCK (DOC_DATE, ITEM_CODE, UOM_CD, DOC_NO, CUST_CODE);
CREATE UNIQUE INDEX SYS_FIELD_DEFS_IDX1 ON SYS_FIELD_DEFS (FIELD_NAME, TABLE_NAME);
CREATE UNIQUE INDEX XPKSYS_GROUPS ON SYS_GROUPS (GROUP_ID);
CREATE UNIQUE INDEX XPKSYS_ITEMS_MENUS ON SYS_ITEMS_MENUS (MODULE_ID, MENU_INDEX);
CREATE INDEX SYS_MENUS_IDX1 ON SYS_MENUS (FORM_NAME);
CREATE UNIQUE INDEX XPKSYS_MENUS ON SYS_MENUS (MENU_INDEX, MENU_ITEM_INDEX, FORM_NAME, MODULE_ID);
CREATE UNIQUE INDEX XPKSYS_MODULES ON SYS_MODULES (MODULE_ID);
CREATE UNIQUE INDEX XPKSYS_USERS ON SYS_USERS (USER_ID);
CREATE UNIQUE INDEX XPKSYS_USER_MENUS ON SYS_USER_MENUS (MODULE_ID, GROUP_ID, USER_ID, MENU_INDEX, MENU_ITEM_INDEX, FORM_NAME);
CREATE UNIQUE INDEX XPKTAX_SCHEM_HD ON TAX_SCHEM_HD (SCHEME_CD, TAX_CD);
CREATE INDEX TEMP_BALANCE_FORWARD_IDX1 ON TEMP_BALANCE_FORWARD (STOCK_CD, GROUP_ID, UOM_CD, LOT_CD, PURCHASE_DATE, ACCT_CODE, ORDER_LINE, REF_NO, REF_DATE);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: IC_MAT_STK_DT_LINK_AD0 */
CREATE TRIGGER IC_MAT_STK_DT_LINK_AD0 FOR IC_MAT_STK_DT_LINK
ACTIVE AFTER DELETE POSITION 0
as
declare variable ROWSNUM integer;
begin
     SELECT COUNT(*) FROM IC_MAT_STK_DT
     WHERE IC_MAT_STK_DT.STOCK_CD = OLD.STOCK_CD AND
           IC_MAT_STK_DT.GROUP_ID = OLD.GROUP_ID AND
           IC_MAT_STK_DT.UOM_CD = OLD.UOM_CD AND
           IC_MAT_STK_DT.LOT_CD = OLD.LOT_CD
     INTO ROWSNUM;

     IF(ROWSNUM > 0) THEN
      BEGIN
        EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
      END
end
^

/* Trigger: REPL_GEN_SEQNO */
CREATE TRIGGER REPL_GEN_SEQNO FOR REPL_LOG
ACTIVE BEFORE INSERT POSITION 0
AS BEGIN NEW.SEQNO = GEN_ID(REPL_GENERATOR,1); END
^

/* Trigger: SO_ORDER_DT_STOCK_AD0 */
CREATE TRIGGER SO_ORDER_DT_STOCK_AD0 FOR SO_ORDER_DT_STOCK
ACTIVE AFTER DELETE POSITION 0
as

declare variable resv_qty float;
declare variable counts integer;
declare variable ROWSNUM integer;
begin
  /* Trigger Text */

  begin
    select count(*) from so_order_dt_stock
    where order_no = old.order_no
      and order_date = old.order_date
      and item_code = old.item_code
      and cust_code = old.cust_code
    into :counts;
  end


  begin
    select qty from so_order_dt_stock
    where order_no = old.order_no
      and order_date = old.order_date
      and item_code = old.item_code
      and cust_code = old.cust_code
      and melt_no = old.melt_no
      and ref_no = old.ref_no
      and ref_date = old.ref_date
    into :resv_qty;
  end

  begin
    update SO_SALES_ITEM_STOCK
    set reserved_qty = reserved_qty - :resv_qty
    where item_code = old.item_code
      and doc_no = old.ref_no
      and doc_date = old.ref_date
      and melt_no = old.melt_no;
  end

  begin
      if(counts = 1) then
        begin
           update so_order_dt
           set stock_usaged_qty = stock_usaged_qty- :resv_qty,
               stock_usaged_flag = 'N'
           where order_no = old.order_no
             and order_date = old.order_date
             and item_code = old.item_code
             and cust_code = old.cust_code ;
        end
      else
        begin
           update so_order_dt
           set stock_usaged_qty = stock_usaged_qty- :resv_qty
           where order_no = old.order_no
             and order_date = old.order_date
             and item_code = old.item_code
             and cust_code = old.cust_code ;
        end
  end

  begin
    select count(*) from so_order_dt
    where stock_usaged_flag = 'Y'
      and order_no = old.order_no
      and order_date = old.order_date
      and item_code = old.item_code
      and cust_code = old.cust_code
    into ROWSNUM;

    if(ROWSNUM = 0) then
     begin
       update so_order_hd
       set stock_usaged_flag = 'N'
       where order_no = old.order_no
         and order_date = old.order_date
         and cust_code = old.cust_code;
    end
  end
end
^

/* Trigger: TD_AP_CREDITOR */
CREATE TRIGGER TD_AP_CREDITOR FOR AP_CREDITOR
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* DELETE trigger on AP_CREDITOR */
DECLARE VARIABLE ROWSNUM INTEGER;
declare variable po_row integer;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
    /* AP_CREDITOR R/32 AP_LEDGER ON PARENT DELETE RESTRICT */
    select count(*)
      from AP_LEDGER
      where
        /*  AP_LEDGER.CREDITOR_ACCT = OLD.CREDITOR_ACCT and
            AP_LEDGER.CURRENCY_CODE = OLD.CURRENCY_CODE and
            AP_LEDGER.CREDITOR_TYPE = OLD.CREDITOR_TYPE */
        AP_LEDGER.CREDITOR_ACCT = OLD.CREDITOR_ACCT and
        AP_LEDGER.CURRENCY_CODE = OLD.CURRENCY_CODE and
        AP_LEDGER.CREDITOR_TYPE = OLD.CREDITOR_TYPE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END

    select count(*)
    from po_order_dt, po_supplier
    where po_order_dt.supp_code = po_supplier.supplier_cd
    and po_supplier.supplier_cd = old.creditor_acct
    and po_supplier.creditor_acct = old.creditor_acct
    into :po_row  ;
    if (po_row > 0) then
    begin
       EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;

    end
    if (po_row =0) then
    begin
       delete from po_supplier
       where po_supplier.creditor_acct = old.creditor_acct;
    end

    /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
    /* AP_CREDITOR_TYPE R/31 AP_CREDITOR ON CHILD DELETE RESTRICT */


  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TD_AP_CREDITOR_TYPE */
CREATE TRIGGER TD_AP_CREDITOR_TYPE FOR AP_CREDITOR_TYPE
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* DELETE trigger on AP_CREDITOR_TYPE */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
    /* AP_CREDITOR_TYPE R/38 AP_LEDGER ON PARENT DELETE RESTRICT */
    select count(*)
      from AP_LEDGER
      where
        /*  AP_LEDGER.CREDITOR_TYPE = OLD.CREDITOR_TYPE */
        AP_LEDGER.CREDITOR_TYPE = OLD.CREDITOR_TYPE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END

    /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
    /* AP_CREDITOR_TYPE R/31 AP_CREDITOR ON PARENT DELETE RESTRICT */


  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TD_AP_INVOICE_HD */
CREATE TRIGGER TD_AP_INVOICE_HD FOR AP_INVOICE_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* DELETE trigger on AP_INVOICE_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
    /* AP_INVOICE_HD R/65 AP_INVOICE_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from AP_INVOICE_DT
      where
        /*  AP_INVOICE_DT.CREDITOR_ACCT = OLD.CREDITOR_ACCT and
            AP_INVOICE_DT.DOC_NO = OLD.DOC_NO and
            AP_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
            AP_INVOICE_DT.TRX_TYPE = OLD.TRX_TYPE */
        AP_INVOICE_DT.CREDITOR_ACCT = OLD.CREDITOR_ACCT and
        AP_INVOICE_DT.DOC_NO = OLD.DOC_NO and
        AP_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
        AP_INVOICE_DT.TRX_TYPE = OLD.TRX_TYPE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TD_AP_LEDGER */
CREATE TRIGGER TD_AP_LEDGER FOR AP_LEDGER
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* DELETE trigger on AP_LEDGER */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
    /* AP_CREDITOR_TYPE R/38 AP_LEDGER ON CHILD DELETE RESTRICT */
    select count(*) from AP_CREDITOR_TYPE
      where
        /* OLD.CREDITOR_TYPE = AP_CREDITOR_TYPE.CREDITOR_TYPE */
        OLD.CREDITOR_TYPE = AP_CREDITOR_TYPE.CREDITOR_TYPE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_CHILD_DELETE_RESTRICT;
    END

    /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
    /* CURRENCY R/34 AP_LEDGER ON CHILD DELETE RESTRICT */
    select count(*) from CURRENCY
      where
        /* OLD.CURRENCY_CODE = CURRENCY.CURRENCY_CODE */
        OLD.CURRENCY_CODE = CURRENCY.CURRENCY_CODE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_CHILD_DELETE_RESTRICT;
    END

    /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
    /* AP_CREDITOR R/32 AP_LEDGER ON CHILD DELETE RESTRICT */
    select count(*) from AP_CREDITOR
      where
        /* OLD.CREDITOR_ACCT = AP_CREDITOR.CREDITOR_ACCT and
           OLD.CURRENCY_CODE = AP_CREDITOR.CURRENCY_CODE and
           OLD.CREDITOR_TYPE = AP_CREDITOR.CREDITOR_TYPE */
        OLD.CREDITOR_ACCT = AP_CREDITOR.CREDITOR_ACCT and
        OLD.CURRENCY_CODE = AP_CREDITOR.CURRENCY_CODE and
        OLD.CREDITOR_TYPE = AP_CREDITOR.CREDITOR_TYPE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_CHILD_DELETE_RESTRICT;
    END


  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TD_AP_PAY_HD */
CREATE TRIGGER TD_AP_PAY_HD FOR AP_PAY_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* DELETE trigger on AP_PAY_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
    /* AP_PAY_HD R/66 AP_PAY_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from AP_PAY_DT
      where
        /*  AP_PAY_DT.CREDITOR_ACCT = OLD.CREDITOR_ACCT and
            AP_PAY_DT.DOC_NO = OLD.DOC_NO and
            AP_PAY_DT.DOC_DATE = OLD.DOC_DATE */
        AP_PAY_DT.CREDITOR_ACCT = OLD.CREDITOR_ACCT and
        AP_PAY_DT.DOC_NO = OLD.DOC_NO and
        AP_PAY_DT.DOC_DATE = OLD.DOC_DATE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TD_AR_CREDIT_NOTE_HD */
CREATE TRIGGER TD_AR_CREDIT_NOTE_HD FOR AR_CREDIT_NOTE_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* DELETE trigger on AR_INVOICE_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* AR_INVOICE_HD R/65 AR_INVOICE_DT ON PARENT DELETE RESTRICT */
  SELECT COUNT(*) FROM AR_CREDIT_NOTE_DT
  WHERE DEBTOR_ACCT = OLD.debtor_acct
  AND DOC_NO = OLD.doc_no
  AND DOC_DATE = OLD.DOC_DATE
  INTO :ROWSNUM;
  IF (:ROWSNUM >0) then
  begin
   exception  e_no_row;
   exit;
  end
  delete
      from AR_CREDIT_NOTE_DT
      where
        /*  AR_INVOICE_DT.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
            AR_INVOICE_DT.DOC_NO = OLD.DOC_NO and
            AR_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
            AR_INVOICE_DT.TRX_TYPE = OLD.TRX_TYPE */
        AR_CREDIT_NOTE_DT.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
        AR_CREDIT_NOTE_DT.DOC_NO = OLD.DOC_NO and
        AR_CREDIT_NOTE_DT.DOC_DATE = OLD.DOC_DATE and
        AR_CREDIT_NOTE_DT.TRX_TYPE = OLD.TRX_TYPE ;


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TD_AR_DEBTOR */
CREATE TRIGGER TD_AR_DEBTOR FOR AR_DEBTOR
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* DELETE trigger on AR_DEBTOR */
DECLARE VARIABLE ROWSNUM INTEGER;
declare variable so_row integer;
declare variable qo_row integer;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
    /* AR_DEBTOR R/16 AR_LEDGER ON PARENT DELETE RESTRICT */
    select count(*)
      from AR_LEDGER
      where
        /*  AR_LEDGER.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
            AR_LEDGER.CURRENCY_CODE = OLD.CURRENCY_CODE and
            AR_LEDGER.DEBTOR_TYPE = OLD.DEBTOR_TYPE */
        AR_LEDGER.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
        AR_LEDGER.CURRENCY_CODE = OLD.CURRENCY_CODE and
        AR_LEDGER.DEBTOR_TYPE = OLD.DEBTOR_TYPE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END
    select count(*)
    from so_order_dt , so_customers
    where  so_order_dt.cust_code = so_customers.customer_cd
    and so_customers.debtor_acct= old.debtor_acct
    into :so_row;
     select count(*)
    from so_quotation_dt , so_customers
    where  so_quotation_dt.cust_code = so_customers.customer_cd
    and so_customers.debtor_acct= old.debtor_acct
    into :qo_row;

    if ((so_row > 0)  or (qo_row> 0)) then
    begin
         EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    end
    if ((so_row = 0)  or (qo_row = 0)) then
    begin
      delete from so_customers
      where debtor_acct = old.debtor_acct;
    end

  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TD_AR_DEBTOR_TYPE */
CREATE TRIGGER TD_AR_DEBTOR_TYPE FOR AR_DEBTOR_TYPE
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* DELETE trigger on AR_DEBTOR_TYPE */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
    /* AR_DEBTOR_TYPE R/40 AR_LEDGER ON PARENT DELETE RESTRICT */
    select count(*)
      from AR_LEDGER
      where
        /*  AR_LEDGER.DEBTOR_TYPE = OLD.DEBTOR_TYPE */
        AR_LEDGER.DEBTOR_TYPE = OLD.DEBTOR_TYPE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END

    /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
    /* AR_DEBTOR_TYPE R/29 AR_DEBTOR ON PARENT DELETE RESTRICT */
    select count(*)
      from AR_DEBTOR
      where
        /*  AR_DEBTOR.DEBTOR_TYPE = OLD.DEBTOR_TYPE */
        AR_DEBTOR.DEBTOR_TYPE = OLD.DEBTOR_TYPE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TD_AR_INVOICE_HD */
CREATE TRIGGER TD_AR_INVOICE_HD FOR AR_INVOICE_HD
INACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* DELETE trigger on AR_INVOICE_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* AR_INVOICE_HD R/65 AR_INVOICE_DT ON PARENT DELETE RESTRICT */
  delete
      from AR_INVOICE_DT
      where
        /*  AR_INVOICE_DT.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
            AR_INVOICE_DT.DOC_NO = OLD.DOC_NO and
            AR_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
            AR_INVOICE_DT.TRX_TYPE = OLD.TRX_TYPE */
        AR_INVOICE_DT.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
        AR_INVOICE_DT.DOC_NO = OLD.DOC_NO and
        AR_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
        AR_INVOICE_DT.TRX_TYPE = OLD.TRX_TYPE ;


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TD_AR_LEDGER */
CREATE TRIGGER TD_AR_LEDGER FOR AR_LEDGER
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* DELETE trigger on AR_LEDGER */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* AR_DEBTOR_TYPE R/40 AR_LEDGER ON CHILD DELETE RESTRICT */
    select count(*) from AR_DEBTOR_TYPE
      where
        /* OLD.DEBTOR_TYPE = AR_DEBTOR_TYPE.DEBTOR_TYPE */
        OLD.DEBTOR_TYPE = AR_DEBTOR_TYPE.DEBTOR_TYPE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_CHILD_DELETE_RESTRICT;
    END

    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* AR_DEBTOR R/16 AR_LEDGER ON CHILD DELETE RESTRICT */
    select count(*) from AR_DEBTOR
      where
        /* OLD.DEBTOR_ACCT = AR_DEBTOR.DEBTOR_ACCT and
           OLD.CURRENCY_CODE = AR_DEBTOR.CURRENCY_CODE and
           OLD.DEBTOR_TYPE = AR_DEBTOR.DEBTOR_TYPE */
        OLD.DEBTOR_ACCT = AR_DEBTOR.DEBTOR_ACCT and
        OLD.CURRENCY_CODE = AR_DEBTOR.CURRENCY_CODE and
        OLD.DEBTOR_TYPE = AR_DEBTOR.DEBTOR_TYPE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_CHILD_DELETE_RESTRICT;
    END


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TD_AR_PAY_HD */
CREATE TRIGGER TD_AR_PAY_HD FOR AR_PAY_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* DELETE trigger on AR_PAY_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* AR_PAY_HD R/66 AR_PAY_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from AR_PAY_DT
      where
        /*  AR_PAY_DT.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
            AR_PAY_DT.DOC_NO = OLD.DOC_NO and
            AR_PAY_DT.DOC_DATE = OLD.DOC_DATE */
        AR_PAY_DT.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
        AR_PAY_DT.DOC_NO = OLD.DOC_NO and
        AR_PAY_DT.DOC_DATE = OLD.DOC_DATE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TD_AR_RECEIPT_HD */
CREATE TRIGGER TD_AR_RECEIPT_HD FOR AR_RECEIPT_HD
ACTIVE AFTER DELETE POSITION 0
AS
begin
   DELETE FROM AR_RECEIPT_DT
   WHERE DOC_NO = OLD.doc_no
   AND DOC_DATE = OLD.DOC_DATE
   AND DEBTOR_ACCT = OLD.debtor_acct;
  /* Trigger text */
end
^

/* Trigger: TD_CURRENCY */
CREATE TRIGGER TD_CURRENCY FOR CURRENCY
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* DELETE trigger on CURRENCY */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* CURRENCY R/34 AP_LEDGER ON PARENT DELETE RESTRICT */
    select count(*)
      from AP_LEDGER
      where
        /*  AP_LEDGER.CURRENCY_CODE = OLD.CURRENCY_CODE */
        AP_LEDGER.CURRENCY_CODE = OLD.CURRENCY_CODE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END

    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* CURRENCY R/26 AR_DEBTOR ON PARENT DELETE RESTRICT */
    select count(*)
      from AR_DEBTOR
      where
        /*  AR_DEBTOR.CURRENCY_CODE = OLD.CURRENCY_CODE */
        AR_DEBTOR.CURRENCY_CODE = OLD.CURRENCY_CODE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TD_DET_DT_MELT */
CREATE TRIGGER TD_DET_DT_MELT FOR SO_DET_DT_MELT
ACTIVE AFTER DELETE POSITION 0
AS
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    delete FROM SO_DET_DT_LINK
      where
       delivery_no = OLD.delivery_no   AND
        delivery_DATE = OLD.delivery_DATE  AND
        MELT_NO = OLD.MELT_NO AND
        REF_NO = OLD.ref_no AND
        REF_DATE = OLD.ref_DATE AND
        BATCH_NO = OLD.BATCH_NO    ;



  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TD_IC_GROUP */
CREATE TRIGGER TD_IC_GROUP FOR IC_GROUP
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* DELETE trigger on IC_GROUP */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* IC_GROUP R/43 IC_MAT_STK_HD ON PARENT DELETE RESTRICT */
    select count(*)
      from IC_MAT_STK_HD
      where
        /*  IC_MAT_STK_HD.GROUP_ID = OLD.GROUP_ID */
        IC_MAT_STK_HD.GROUP_ID = OLD.GROUP_ID into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TD_IC_MAT_STK_DT */
CREATE TRIGGER TD_IC_MAT_STK_DT FOR IC_MAT_STK_DT
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* DELETE trigger on IC_MAT_STK_DT */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* IC_MAT_STK_DT R/70 IC_STOCKCARD ON PARENT DELETE RESTRICT */
  BEGIN
    select count(*)
      from IC_STOCKCARD
      where
        /*  IC_STOCKCARD.STOCK_CD = OLD.STOCK_CD and
            IC_STOCKCARD.GROUP_ID = OLD.GROUP_ID and
            IC_STOCKCARD.UOM_CD = OLD.UOM_CD and
            IC_STOCKCARD.LOT_CD = OLD.LOT_CD */
        IC_STOCKCARD.STOCK_CD = OLD.STOCK_CD and
        IC_STOCKCARD.GROUP_ID = OLD.GROUP_ID and
        IC_STOCKCARD.UOM_CD = OLD.UOM_CD and
        IC_STOCKCARD.purchase_date = OLD.purchase_date  AND
        IC_STOCKCARD.LOT_CD = OLD.LOT_CD into ROWSNUM;
    IF (ROWSNUM > 0) THEN
     BEGIN
       EXCEPTION E_DEL_STOCK_DETAIL;
     END
  END

  BEGIN
     SELECT COUNT(*) FROM IC_MAT_STK_DT_LINK
     WHERE IC_MAT_STK_DT_LINK.STOCK_CD = OLD.STOCK_CD AND
           IC_MAT_STK_DT_LINK.GROUP_ID = OLD.GROUP_ID AND
           IC_MAT_STK_DT_LINK.UOM_CD = OLD.UOM_CD AND
           IC_MAT_STK_DT_LINK.LOT_CD = OLD.LOT_CD
     INTO ROWSNUM;

     IF(ROWSNUM > 0) THEN
      BEGIN
        EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
      END
  END

  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TD_IC_MAT_STK_HD */
CREATE TRIGGER TD_IC_MAT_STK_HD FOR IC_MAT_STK_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* DELETE trigger on IC_MAT_STK_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* IC_MAT_STK_HD R/73 SO_SALES_ITEM_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from SO_SALES_ITEM_DT
      where
        /*  SO_SALES_ITEM_DT.STOCK_CD = OLD.STOCK_CD and
            SO_SALES_ITEM_DT.GROUP_ID = OLD.GROUP_ID and
            SO_SALES_ITEM_DT.UOM_CD = OLD.UOM_CD */
        SO_SALES_ITEM_DT.STOCK_CD = OLD.STOCK_CD and
        SO_SALES_ITEM_DT.GROUP_ID = OLD.GROUP_ID and
        SO_SALES_ITEM_DT.UOM_CD = OLD.UOM_CD into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END

    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* IC_MAT_STK_HD R/69 IC_STOCKCARD ON PARENT DELETE RESTRICT */
    select count(*)
      from IC_STOCKCARD
      where
        /*  IC_STOCKCARD.STOCK_CD = OLD.STOCK_CD and
            IC_STOCKCARD.GROUP_ID = OLD.GROUP_ID and
            IC_STOCKCARD.UOM_CD = OLD.UOM_CD */
        IC_STOCKCARD.STOCK_CD = OLD.STOCK_CD and
        IC_STOCKCARD.GROUP_ID = OLD.GROUP_ID and
        IC_STOCKCARD.UOM_CD = OLD.UOM_CD into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END

    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* IC_MAT_STK_HD R/44 IC_MAT_STK_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from IC_MAT_STK_DT
      where
        /*  IC_MAT_STK_DT.STOCK_CD = OLD.STOCK_CD and
            IC_MAT_STK_DT.GROUP_ID = OLD.GROUP_ID and
            IC_MAT_STK_DT.UOM_CD = OLD.UOM_CD */
        IC_MAT_STK_DT.STOCK_CD = OLD.STOCK_CD and
        IC_MAT_STK_DT.GROUP_ID = OLD.GROUP_ID and
        IC_MAT_STK_DT.UOM_CD = OLD.UOM_CD into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END

  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TD_IC_STOCKCARD */
CREATE TRIGGER TD_IC_STOCKCARD FOR IC_STOCKCARD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* DELETE trigger on IC_STOCKCARD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* IC_MAT_STK_HD R/69 IC_STOCKCARD ON CHILD DELETE RESTRICT */
    select count(*) from IC_MAT_STK_HD
      where
        /* OLD.STOCK_CD = IC_MAT_STK_HD.STOCK_CD and
           OLD.GROUP_ID = IC_MAT_STK_HD.GROUP_ID and
           OLD.UOM_CD = IC_MAT_STK_HD.UOM_CD */
        OLD.STOCK_CD = IC_MAT_STK_HD.STOCK_CD and
        OLD.GROUP_ID = IC_MAT_STK_HD.GROUP_ID and
        OLD.UOM_CD = IC_MAT_STK_HD.UOM_CD into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION E_DEL_STOCKCARD;
    END


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TD_IC_STOCK_ADJUST_DT */
CREATE TRIGGER TD_IC_STOCK_ADJUST_DT FOR IC_STOCK_ADJUST_DT
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Thu Apr 24 13:09:59 2003 */
  /* DELETE trigger on IC_STOCK_ADJUST_DT */

BEGIN
    /* ERwin Builtin Thu Apr 24 13:09:59 2003 */
    /* IC_STOCK_ADJUST_DT R/81 IC_STOCK_ADJUST_LOGS ON PARENT DELETE RESTRICT */
   delete
      from IC_STOCK_ADJUST_LOGS
      where
        /*  IC_STOCK_ADJUST_LOGS.ITEM_CODE = OLD.ITEM_CODE and
            IC_STOCK_ADJUST_LOGS.UOM_CD = OLD.UOM_CD and
            IC_STOCK_ADJUST_LOGS.DOC_NO = OLD.DOC_NO and
            IC_STOCK_ADJUST_LOGS.DOC_DATE = OLD.DOC_DATE and
            IC_STOCK_ADJUST_LOGS.GROUP_ID = OLD.GROUP_ID and
            IC_STOCK_ADJUST_LOGS.LOT_NO = OLD.LOT_NO */
        IC_STOCK_ADJUST_LOGS.ITEM_CODE = OLD.ITEM_CODE and
        IC_STOCK_ADJUST_LOGS.UOM_CD = OLD.UOM_CD and
        IC_STOCK_ADJUST_LOGS.DOC_NO = OLD.DOC_NO and
        IC_STOCK_ADJUST_LOGS.DOC_DATE = OLD.DOC_DATE and
        IC_STOCK_ADJUST_LOGS.GROUP_ID = OLD.GROUP_ID and
        IC_STOCK_ADJUST_LOGS.LOT_NO = OLD.LOT_NO ;
     /* ERwin Builtin Thu Apr 24 13:09:59 2003 */
END
^

/* Trigger: TD_IC_STOCK_ADJUST_HD */
CREATE TRIGGER TD_IC_STOCK_ADJUST_HD FOR IC_STOCK_ADJUST_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Thu Apr 24 12:36:49 2003 */
  /* DELETE trigger on IC_STOCK_ADJUST_HD */

BEGIN
    /* ERwin Builtin Thu Apr 24 12:36:49 2003 */
    /* IC_STOCK_ADJUST_HD R/79 IC_STOCK_ADJUST_DT ON PARENT DELETE RESTRICT */
   delete
   from IC_STOCK_ADJUST_DT
   where
        /*  IC_STOCK_ADJUST_DT.DOC_NO = OLD.DOC_NO and
            IC_STOCK_ADJUST_DT.DOC_DATE = OLD.DOC_DATE */
        IC_STOCK_ADJUST_DT.DOC_NO = OLD.DOC_NO and
        IC_STOCK_ADJUST_DT.DOC_DATE = OLD.DOC_DATE;

  /* ERwin Builtin Thu Apr 24 12:36:49 2003 */
END
^

/* Trigger: TD_IC_UOM */
CREATE TRIGGER TD_IC_UOM FOR IC_UOM
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* DELETE trigger on IC_UOM */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* IC_UOM R/42 IC_MAT_STK_HD ON PARENT DELETE RESTRICT */
    select count(*)
      from IC_MAT_STK_HD
      where
        /*  IC_MAT_STK_HD.UOM_CD = OLD.UOM_CD */
        IC_MAT_STK_HD.UOM_CD = OLD.UOM_CD into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TD_PL_DISPATCH_HD */
CREATE TRIGGER TD_PL_DISPATCH_HD FOR PL_DISPATCH_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 17 14:19:28 2003 */
  /* DELETE trigger on PL_DISPATCH_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 17 14:19:28 2003 */
    /* PL_DISPATCH_HD R/79 PL_DISPATCH_DT ON PARENT DELETE CASCADE */
    delete from PL_DISPATCH_DT
      where
        /*  PL_DISPATCH_DT.DOC_NO = OLD.DOC_NO and
            PL_DISPATCH_DT.DOC_DATE = OLD.DOC_DATE */
        PL_DISPATCH_DT.DOC_NO = OLD.DOC_NO and
        PL_DISPATCH_DT.DOC_DATE = OLD.DOC_DATE;


  /* ERwin Builtin Mon Nov 17 14:19:28 2003 */
END
^

/* Trigger: TD_PL_DROSS_HD */
CREATE TRIGGER TD_PL_DROSS_HD FOR PL_DROSS_HD
ACTIVE AFTER DELETE POSITION 0
AS
begin
   delete from pl_dross_dt
   where melt_no = old.melt_no
   and receive_Doc= old.receive_doc
   and receive_date = old.receive_date;
  /* Trigger text */
end
^

/* Trigger: TD_PL_FNG_ADJ_HD */
CREATE TRIGGER TD_PL_FNG_ADJ_HD FOR PL_FNG_ADJ_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Fri Aug 08 09:30:39 2003 */
  /* DELETE trigger on PL_FNG_ADJ_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Fri Aug 08 09:30:39 2003 */
    /* PL_FNG_ADJ_HD R/78 PL_FNG_ADJ_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from PL_FNG_ADJ_DT
      where
        /*  PL_FNG_ADJ_DT.DOC_NO = OLD.DOC_NO and
            PL_FNG_ADJ_DT.DOC_DATE = OLD.DOC_DATE */
        PL_FNG_ADJ_DT.DOC_NO = OLD.DOC_NO and
        PL_FNG_ADJ_DT.DOC_DATE = OLD.DOC_DATE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Fri Aug 08 09:30:39 2003 */
END
^

/* Trigger: TD_PL_FNG_RET_HD */
CREATE TRIGGER TD_PL_FNG_RET_HD FOR PL_FNG_RET_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Fri Aug 08 09:31:38 2003 */
  /* DELETE trigger on PL_FNG_RET_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Fri Aug 08 09:31:38 2003 */
    /* PL_FNG_RET_HD R/77 PL_FNG_RET_DT ON PARENT DELETE CASCADE */
    delete from PL_FNG_RET_DT
      where
        /*  PL_FNG_RET_DT.DOC_NO = OLD.DOC_NO and
            PL_FNG_RET_DT.DOC_DATE = OLD.DOC_DATE and
            PL_FNG_RET_DT.CUST_CODE = OLD.CUST_CODE and
            PL_FNG_RET_DT.MELT_NO = OLD.MELT_NO */
        PL_FNG_RET_DT.DOC_NO = OLD.DOC_NO and
        PL_FNG_RET_DT.DOC_DATE = OLD.DOC_DATE and
        PL_FNG_RET_DT.CUST_CODE = OLD.CUST_CODE and
        PL_FNG_RET_DT.MELT_NO = OLD.MELT_NO;


  /* ERwin Builtin Fri Aug 08 09:31:38 2003 */
END
^

/* Trigger: TD_PL_FN_RECEIVE_HD */
CREATE TRIGGER TD_PL_FN_RECEIVE_HD FOR PL_FN_RECEIVE_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Tue Apr 29 17:07:45 2003 */
  /* DELETE trigger on PL_FN_RECEIVE_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Tue Apr 29 17:07:45 2003 */
    /* PL_FN_RECEIVE_HD R/77 PL_FN_RECEIVE_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from PL_FN_RECEIVE_DT
      where
        /*  PL_FN_RECEIVE_DT.DOC_NO = OLD.DOC_NO and
            PL_FN_RECEIVE_DT.DOC_DATE = OLD.DOC_DATE and
            PL_FN_RECEIVE_DT.MELT_NO = OLD.MELT_NO and
            PL_FN_RECEIVE_DT.ITEM_CODE = OLD.ITEM_CODE */
        PL_FN_RECEIVE_DT.DOC_NO = OLD.DOC_NO and
        PL_FN_RECEIVE_DT.DOC_DATE = OLD.DOC_DATE and
        PL_FN_RECEIVE_DT.MELT_NO = OLD.MELT_NO and
        PL_FN_RECEIVE_DT.ITEM_CODE = OLD.ITEM_CODE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Tue Apr 29 17:07:45 2003 */
END
^

/* Trigger: TD_PL_PRO_PLAN_DT */
CREATE TRIGGER TD_PL_PRO_PLAN_DT FOR PL_PRO_PLAN_DT
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Tue Mar 11 12:29:28 2003 */
  /* DELETE trigger on PL_PRO_PLAN_DT */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN


    /* ERwin Builtin Tue Mar 11 12:29:28 2003 */
    /* PL_PRO_PLAN_DT R/93 PL_PRO_PLAN_DISP_DT ON PARENT DELETE CASCADE */
    delete from PL_PRO_PLAN_DISP_DT
      where
        /*  PL_PRO_PLAN_DISP_DT.PLAN_DATE = OLD.PLAN_DATE and
            PL_PRO_PLAN_DISP_DT.PLAN_DOC = OLD.PLAN_DOC and
            PL_PRO_PLAN_DISP_DT.TRX_TYPE = OLD.TRX_TYPE and
            PL_PRO_PLAN_DISP_DT.CUST_CODE = OLD.CUST_CODE and
            PL_PRO_PLAN_DISP_DT.ORDER_NO = OLD.ORDER_NO and
            PL_PRO_PLAN_DISP_DT.ORDER_DATE = OLD.ORDER_DATE and
            PL_PRO_PLAN_DISP_DT.ITEM_CODE = OLD.ITEM_CODE and
            PL_PRO_PLAN_DISP_DT.MELT_NO = OLD.MELT_NO */
        PL_PRO_PLAN_DISP_DT.PLAN_DATE = OLD.PLAN_DATE and
        PL_PRO_PLAN_DISP_DT.PLAN_DOC = OLD.PLAN_DOC and
        PL_PRO_PLAN_DISP_DT.TRX_TYPE = OLD.TRX_TYPE and
        PL_PRO_PLAN_DISP_DT.CUST_CODE = OLD.CUST_CODE and
        PL_PRO_PLAN_DISP_DT.ORDER_NO = OLD.ORDER_NO and
        PL_PRO_PLAN_DISP_DT.ORDER_DATE = OLD.ORDER_DATE and
        PL_PRO_PLAN_DISP_DT.ITEM_CODE = OLD.ITEM_CODE and
        PL_PRO_PLAN_DISP_DT.MELT_NO = OLD.MELT_NO;


     /**protect deletion where melt_sheet exists**/
     SELECT COUNT(*)
     FROM pl_rawmat_sheet_dt
     WHERE MELT_NO = OLD.MELT_NO
     AND ITEM_CODE = OLD. ITEM_CODE
     INTO :ROWSNUM;
     if (ROWSNUM > 0) then
     begin
         exception erwin_child_delete_restrict;
     end


  /* ERwin Builtin Tue Mar 11 12:29:28 2003 */
END
^

/* Trigger: TD_PL_PRO_PLAN_HD */
CREATE TRIGGER TD_PL_PRO_PLAN_HD FOR PL_PRO_PLAN_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Wed Nov 27 13:47:52 2002 */
  /* DELETE trigger on PL_PRO_PLAN_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Wed Nov 27 13:47:52 2002 */
    /* PL_PRO_PLAN_HD R/68 PL_PRO_PLAN_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from PL_PRO_PLAN_DT
      where
        /*  PL_PRO_PLAN_DT.PLAN_DATE = OLD.PLAN_DATE and
            PL_PRO_PLAN_DT.PLAN_DOC = OLD.PLAN_DOC and
            PL_PRO_PLAN_DT.TRX_TYPE = OLD.TRX_TYPE */
        PL_PRO_PLAN_DT.PLAN_DATE = OLD.PLAN_DATE and
        PL_PRO_PLAN_DT.PLAN_DOC = OLD.PLAN_DOC and
        PL_PRO_PLAN_DT.TRX_TYPE = OLD.TRX_TYPE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Wed Nov 27 13:47:52 2002 */
END
^

/* Trigger: TD_PL_RAWMAT_PLAN_HD */
CREATE TRIGGER TD_PL_RAWMAT_PLAN_HD FOR PL_RAWMAT_PLAN_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Tue Jan 07 10:48:27 2003 */
  /* DELETE trigger on PL_RAWMAT_PLAN_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Tue Jan 07 10:48:27 2003 */
    /* PL_RAWMAT_PLAN_HD R/81 PL_RAWMAT_PLAN_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from PL_RAWMAT_PLAN_DT
      where
        /*  PL_RAWMAT_PLAN_DT.PLAN_DOC = OLD.PLAN_DOC and
            PL_RAWMAT_PLAN_DT.PLAN_DATE = OLD.PLAN_DATE */
        PL_RAWMAT_PLAN_DT.PLAN_DOC = OLD.PLAN_DOC and
        PL_RAWMAT_PLAN_DT.PLAN_DATE = OLD.PLAN_DATE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Tue Jan 07 10:48:27 2003 */
END
^

/* Trigger: TD_PL_RAWMAT_SHEET_HD */
CREATE TRIGGER TD_PL_RAWMAT_SHEET_HD FOR PL_RAWMAT_SHEET_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Tue Feb 25 11:25:40 2003 */
  /* DELETE trigger on PL_RAWMAT_SHEET_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Tue Feb 25 11:25:40 2003 */
    /* PL_RAWMAT_SHEET_HD R/82 PL_RAWMAT_SHEET_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from PL_RAWMAT_SHEET_DT
      where
        /*  PL_RAWMAT_SHEET_DT.PLAN_DOC = OLD.PLAN_DOC and
            PL_RAWMAT_SHEET_DT.PLAN_DATE = OLD.PLAN_DATE and
            PL_RAWMAT_SHEET_DT.MELT_NO = OLD.MELT_NO and
            PL_RAWMAT_SHEET_DT.ITEM_CODE = OLD.ITEM_CODE and
            PL_RAWMAT_SHEET_DT.CUST_CODE = OLD.CUST_CODE */
        PL_RAWMAT_SHEET_DT.PLAN_DOC = OLD.PLAN_DOC and
        PL_RAWMAT_SHEET_DT.PLAN_DATE = OLD.PLAN_DATE and
        PL_RAWMAT_SHEET_DT.MELT_NO = OLD.MELT_NO and
        PL_RAWMAT_SHEET_DT.ITEM_CODE = OLD.ITEM_CODE and
        PL_RAWMAT_SHEET_DT.CUST_CODE = OLD.CUST_CODE into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END
    ELSE
    BEGIN
      DELETE    from PL_RAWMAT_SHEET_DT
      where
        /*  PL_RAWMAT_SHEET_DT.PLAN_DOC = OLD.PLAN_DOC and
            PL_RAWMAT_SHEET_DT.PLAN_DATE = OLD.PLAN_DATE and
            PL_RAWMAT_SHEET_DT.MELT_NO = OLD.MELT_NO and
            PL_RAWMAT_SHEET_DT.ITEM_CODE = OLD.ITEM_CODE and
            PL_RAWMAT_SHEET_DT.CUST_CODE = OLD.CUST_CODE */
        PL_RAWMAT_SHEET_DT.PLAN_DOC = OLD.PLAN_DOC and
        PL_RAWMAT_SHEET_DT.PLAN_DATE = OLD.PLAN_DATE and
        PL_RAWMAT_SHEET_DT.MELT_NO = OLD.MELT_NO and
        PL_RAWMAT_SHEET_DT.ITEM_CODE = OLD.ITEM_CODE and
        PL_RAWMAT_SHEET_DT.CUST_CODE = OLD.CUST_CODE;


      DELETE    from PL_RAWMAT_SHEET_ITEM_REQ
      where
        /*  PL_RAWMAT_SHEET_DT.PLAN_DOC = OLD.PLAN_DOC and
            PL_RAWMAT_SHEET_DT.PLAN_DATE = OLD.PLAN_DATE and
            PL_RAWMAT_SHEET_DT.MELT_NO = OLD.MELT_NO and
            PL_RAWMAT_SHEET_DT.ITEM_CODE = OLD.ITEM_CODE and
            PL_RAWMAT_SHEET_DT.CUST_CODE = OLD.CUST_CODE */
        PL_RAWMAT_SHEET_ITEM_REQ.PLAN_DOC = OLD.PLAN_DOC and
        PL_RAWMAT_SHEET_ITEM_REQ.PLAN_DATE = OLD.PLAN_DATE and
        PL_RAWMAT_SHEET_ITEM_REQ.MELT_NO = OLD.MELT_NO and
        PL_RAWMAT_SHEET_ITEM_REQ.ITEM_CODE = OLD.ITEM_CODE and
        PL_RAWMAT_SHEET_ITEM_REQ.CUST_CODE = OLD.CUST_CODE;

    END


  /* ERwin Builtin Tue Feb 25 11:25:40 2003 */
END
^

/* Trigger: TD_PL_REQ_DT_AD0 */
CREATE TRIGGER TD_PL_REQ_DT_AD0 FOR PL_REQ_DT
INACTIVE AFTER DELETE POSITION 0
AS
begin
  DELETE FROM IC_STOCK_RESERVED
  WHERE DOC_NO = old.DOC_NO
  AND DOC_DATE = old.DOC_DATE
  AND LOT_CD = old.lot_no
  AND PURCHASE_DATE = old.purchase_date
  AND REF_NO = old.REF_NO
  AND REF_DATE = old.REF_DATE
  AND STOCK_CD = old.item_code
  AND GROUP_ID = old.group_id
  AND UOM_CD = old.uom ;
end
^

/* Trigger: TD_PL_REQ_HD */
CREATE TRIGGER TD_PL_REQ_HD FOR PL_REQ_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Dec 02 11:09:01 2002 */
  /* DELETE trigger on PL_REQ_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Dec 02 11:09:01 2002 */
    /* PL_REQ_HD R/75 PL_REQ_DT ON PARENT DELETE RESTRICT */
    DELETE
      from PL_REQ_DT
      where
        /*  PL_REQ_DT.DOC_NO = OLD.DOC_NO and
            PL_REQ_DT.DOC_DATE = OLD.DOC_DATE and
            PL_REQ_DT.TRX_TYPE = OLD.TRX_TYPE */
        PL_REQ_DT.DOC_NO = OLD.DOC_NO and
        PL_REQ_DT.DOC_DATE = OLD.DOC_DATE and
        PL_REQ_DT.TRX_TYPE = OLD.TRX_TYPE;


      DELETE FROM  ic_stock_reserved

      where
        /*  PL_REQ_DT.DOC_NO = OLD.DOC_NO and
            PL_REQ_DT.DOC_DATE = OLD.DOC_DATE and
            PL_REQ_DT.TRX_TYPE = OLD.TRX_TYPE */
       ic_stock_reserved.DOC_NO = OLD.DOC_NO and
       ic_stock_reserved.DOC_DATE = OLD.DOC_DATE ;


  /* ERwin Builtin Mon Dec 02 11:09:01 2002 */
END
^

/* Trigger: TD_PO_GRN_HD */
CREATE TRIGGER TD_PO_GRN_HD FOR PO_GRN_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* DELETE trigger on PO_GRN_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
    /* PO_GRN_HD R/56 PO_GRN_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from PO_GRN_DT
      where
        /*  PO_GRN_DT.SUPP_CODE = OLD.SUPP_CODE and
            PO_GRN_DT.GRN_DATE = OLD.GRN_DATE and
            PO_GRN_DT.GRN_NO = OLD.GRN_NO */
        PO_GRN_DT.SUPP_CODE = OLD.SUPP_CODE and
        PO_GRN_DT.GRN_DATE = OLD.GRN_DATE and
        PO_GRN_DT.GRN_NO = OLD.GRN_NO into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
END
^

/* Trigger: TD_PO_ORDER_DT */
CREATE TRIGGER TD_PO_ORDER_DT FOR PO_ORDER_DT
ACTIVE BEFORE DELETE POSITION 0
as
declare variable ROWSNUM smallint;
begin
  SELECT COUNT(*)
  FROM PO_GRN_DT
  WHERE PO_GRN_DT.order_no = OLD.order_no
  AND PO_GRN_DT.ORDER_DATE = OLD.order_date
  AND PO_GRN_DT.supp_code = OLD.SUPP_CODE
  AND PO_GRN_DT.item_code = OLD.ITEM_CODE
  INTO :ROWSNUM;
  if (ROWSNUM > 0) then
  BEGIN
     exception ex_po_order_dt;
  END

  /* Trigger Text */
end
^

/* Trigger: TD_PO_ORDER_HD */
CREATE TRIGGER TD_PO_ORDER_HD FOR PO_ORDER_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* DELETE trigger on PO_ORDER_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
    /* PO_ORDER_HD R/54 PO_ORDER_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from PO_ORDER_DT
      where
        /*  PO_ORDER_DT.SUPP_CODE = OLD.SUPP_CODE and
            PO_ORDER_DT.ORDER_DATE = OLD.ORDER_DATE and
            PO_ORDER_DT.ORDER_NO = OLD.ORDER_NO */
        PO_ORDER_DT.SUPP_CODE = OLD.SUPP_CODE and
        PO_ORDER_DT.ORDER_DATE = OLD.ORDER_DATE and
        PO_ORDER_DT.ORDER_NO = OLD.ORDER_NO into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
END
^

/* Trigger: TD_PO_SUPPLIER */
CREATE TRIGGER TD_PO_SUPPLIER FOR PO_SUPPLIER
ACTIVE BEFORE DELETE POSITION 0
as
DECLARE VARIABLE ROWSNUM INTEGER;
declare variable PO_ROWS smallint;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* IC_UOM R/42 IC_MAT_STK_HD ON PARENT DELETE RESTRICT */
    select count(*)
      from ap_creditor
      where
        /*  IC_MAT_STK_HD.UOM_CD = OLD.UOM_CD */
        ap_creditor.creditor_acct = OLD.SUPPLIER_CD into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION e_delete_po_supplier;
    END

    select count(*)
    from po_order_hd
    where supp_code =old.supplier_cd
    into :po_rows;
    if (po_rows > 0) then
    begin
        EXCEPTION e_delete_po_supplier;
    end


end
^

/* Trigger: TD_SO_CUSTOMERS */
CREATE TRIGGER TD_SO_CUSTOMERS FOR SO_CUSTOMERS
ACTIVE BEFORE DELETE POSITION 0
as
DECLARE VARIABLE ROWSNUM INTEGER;

BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
    /* IC_UOM R/42 IC_MAT_STK_HD ON PARENT DELETE RESTRICT */
    select count(*)
      from ar_debtor
      where
        /*  IC_MAT_STK_HD.UOM_CD = OLD.UOM_CD */
      debtor_acct = OLD.CUSTOMER_CD into ROWSNUM;

    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION e_delete_so_customer;
    END


end
^

/* Trigger: TD_SO_DET_DT_ORDER */
CREATE TRIGGER TD_SO_DET_DT_ORDER FOR SO_DET_DT_ORDER
ACTIVE AFTER DELETE POSITION 0
AS
declare   VARIABLE ROWSNUM SMALLINT;
begin

 select count(*)
      from so_det_dt_melt
      where
        /*  PL_FN_RECEIVE_DT.DOC_NO = OLD.DOC_NO and
            PL_FN_RECEIVE_DT.DOC_DATE = OLD.DOC_DATE and
            PL_FN_RECEIVE_DT.MELT_NO = OLD.MELT_NO and
            PL_FN_RECEIVE_DT.ITEM_CODE = OLD.ITEM_CODE */
       DELIVERY_NO = OLD.delivery_no and
       DELIVERY_DATE = OLD.delivery_date and
       BATCH_NO = OLD.batch_no
      into :ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END

end
^

/* Trigger: TD_SO_DET_HD */
CREATE TRIGGER TD_SO_DET_HD FOR SO_DET_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Feb 17 12:32:41 2003 */
  /* DELETE trigger on SO_DET_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Feb 17 12:32:41 2003 */
    /* SO_DET_HD R/90 SO_DET_DT ON PARENT DELETE CASCADE */
    delete from SO_DET_DT
      where
        /*  SO_DET_DT.DELIVERY_NO = OLD.DELIVERY_NO and
            SO_DET_DT.DELIVERY_DATE = OLD.DELIVERY_DATE and
            SO_DET_DT.CUST_CODE = OLD.CUST_CODE */
        SO_DET_DT.DELIVERY_NO = OLD.DELIVERY_NO and
        SO_DET_DT.DELIVERY_DATE = OLD.DELIVERY_DATE and
        SO_DET_DT.CUST_CODE = OLD.CUST_CODE;


         delete from SO_DET_DT_ORDER
      where
        /*  SO_DET_DT.DELIVERY_NO = OLD.DELIVERY_NO and
            SO_DET_DT.DELIVERY_DATE = OLD.DELIVERY_DATE and
            SO_DET_DT.CUST_CODE = OLD.CUST_CODE */
       SO_DET_DT_ORDER.DELIVERY_NO = OLD.DELIVERY_NO and
       SO_DET_DT_ORDER.DELIVERY_DATE = OLD.DELIVERY_DATE and
       SO_DET_DT_ORDER.CUST_CODE = OLD.CUST_CODE;


  /* ERwin Builtin Mon Feb 17 12:32:41 2003 */
END
^

/* Trigger: TD_SO_INVOICE_HD */
CREATE TRIGGER TD_SO_INVOICE_HD FOR SO_INVOICE_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* DELETE trigger on SO_INVOICE_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
    /* SO_INVOICE_HD R/19 SO_INVOICE_DT ON PARENT DELETE CASCADE */
    delete from SO_INVOICE_DT
      where
        /*  SO_INVOICE_DT.DOC_NO = OLD.DOC_NO and
            SO_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
            SO_INVOICE_DT.CUST_CODE = OLD.CUST_CODE */
        SO_INVOICE_DT.DOC_NO = OLD.DOC_NO and
        SO_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
        SO_INVOICE_DT.CUST_CODE = OLD.CUST_CODE;


  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
END
^

/* Trigger: TD_SO_ORDER_DT */
CREATE TRIGGER TD_SO_ORDER_DT FOR SO_ORDER_DT
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Tue Mar 04 12:08:50 2003 */
  /* DELETE trigger on SO_ORDER_DT */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Tue Mar 04 12:08:50 2003 */
    /* SO_ORDER_DT R/92 SO_ORDER_SCH_DT ON PARENT DELETE RESTRICT */
    select count(*)
      from SO_ORDER_SCH_DT
      where
        /*  SO_ORDER_SCH_DT.CUST_CODE = OLD.CUST_CODE and
            SO_ORDER_SCH_DT.ORDER_NO = OLD.ORDER_NO and
            SO_ORDER_SCH_DT.ORDER_DATE = OLD.ORDER_DATE and
            SO_ORDER_SCH_DT.ITEM_CODE = OLD.ITEM_CODE and
            SO_ORDER_SCH_DT.LINE_NO = OLD.LINE_NO */
        SO_ORDER_SCH_DT.CUST_CODE = OLD.CUST_CODE and
        SO_ORDER_SCH_DT.ORDER_NO = OLD.ORDER_NO and
        SO_ORDER_SCH_DT.ORDER_DATE = OLD.ORDER_DATE and
        SO_ORDER_SCH_DT.ITEM_CODE = OLD.ITEM_CODE and
        SO_ORDER_SCH_DT.LINE_NO = OLD.LINE_NO into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_DELETE_RESTRICT;
    END


  /* ERwin Builtin Tue Mar 04 12:08:50 2003 */
END
^

/* Trigger: TD_SO_ORDER_HD */
CREATE TRIGGER TD_SO_ORDER_HD FOR SO_ORDER_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* DELETE trigger on SO_ORDER_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
    /* SO_ORDER_HD R/20 SO_ORDER_DT ON PARENT DELETE CASCADE */
    delete from SO_ORDER_DT
      where
        /*  SO_ORDER_DT.CUST_CODE = OLD.CUST_CODE and
            SO_ORDER_DT.ORDER_NO = OLD.ORDER_NO and
            SO_ORDER_DT.ORDER_DATE = OLD.ORDER_DATE */
        SO_ORDER_DT.CUST_CODE = OLD.CUST_CODE and
        SO_ORDER_DT.ORDER_NO = OLD.ORDER_NO and
        SO_ORDER_DT.ORDER_DATE = OLD.ORDER_DATE;


  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
END
^

/* Trigger: TD_SO_ORDER_REVISION_DT */
CREATE TRIGGER TD_SO_ORDER_REVISION_DT FOR SO_ORDER_REVISION_DT
INACTIVE AFTER DELETE POSITION 0
AS
begin
  delete from so_order_sch_dt
  where order_no = old.order_no
  and order_date = old.order_date
  and cust_code = old.cust_code  ;

end
^

/* Trigger: TD_SO_ORDER_REVISION_HD */
CREATE TRIGGER TD_SO_ORDER_REVISION_HD FOR SO_ORDER_REVISION_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Thu Mar 27 10:52:42 2003 */
  /* DELETE trigger on SO_ORDER_REVISION_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Thu Mar 27 10:52:42 2003 */
    /* SO_ORDER_REVISION_HD R/96 SO_ORDER_REVISION_DT ON PARENT DELETE CASCADE */
    delete from SO_ORDER_REVISION_DT
      where
        /*  SO_ORDER_REVISION_DT.DOC_DATE = OLD.DOC_DATE and
            SO_ORDER_REVISION_DT.DOC_NO = OLD.DOC_NO */
        SO_ORDER_REVISION_DT.DOC_DATE = OLD.DOC_DATE and
        SO_ORDER_REVISION_DT.DOC_NO = OLD.DOC_NO;


  /* ERwin Builtin Thu Mar 27 10:52:42 2003 */
END
^

/* Trigger: TD_SO_QUOTATION_HD */
CREATE TRIGGER TD_SO_QUOTATION_HD FOR SO_QUOTATION_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Feb 17 12:43:23 2003 */
  /* DELETE trigger on SO_QUOTATION_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
    /* ERwin Builtin Mon Feb 17 12:43:23 2003 */
    /* SO_QUOTATION_HD R/21 SO_QUOTATION_DT ON PARENT DELETE CASCADE */
    delete from SO_QUOTATION_DT
      where
        /*  SO_QUOTATION_DT.CUST_CODE = OLD.CUST_CODE and
            SO_QUOTATION_DT.DOC_NO = OLD.DOC_NO and
            SO_QUOTATION_DT.DOC_DATE = OLD.DOC_DATE */
        SO_QUOTATION_DT.CUST_CODE = OLD.CUST_CODE and
        SO_QUOTATION_DT.DOC_NO = OLD.DOC_NO and
        SO_QUOTATION_DT.DOC_DATE = OLD.DOC_DATE;


  /* ERwin Builtin Mon Feb 17 12:43:23 2003 */
END
^

/* Trigger: TD_SO_SALES_ITEM_HD */
CREATE TRIGGER TD_SO_SALES_ITEM_HD FOR SO_SALES_ITEM_HD
ACTIVE AFTER DELETE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* DELETE trigger on SO_SALES_ITEM_HD */
/*DECLARE VARIABLE ROWSNUM INTEGER;*/
DECLARE VARIABLE numrows1 INTEGER;

BEGIN
    /* ERwin Builtin Tue Feb 04 08:17:03 2003 */
    /* SO_SALES_ITEM_HD R/89 SO_SALES_ITEM_REQ_SHEET ON PARENT DELETE RESTRICT */


     /**Count into sale stock */
     select count(*)
     from so_sales_item_stock
     where so_sales_item_stock.ITEM_CODE = OLD.ITEM_CODE and
        so_sales_item_stock.UOM_CD = OLD.UOM_CD and
        so_sales_item_stock.CUST_CODE = OLD.CUST_CODE into numrows1;
    IF (numrows1 > 0) THEN
    BEGIN
      EXCEPTION E_SALES_STOCK_EXIST;
    END
    select count(*)
    from so_ledger
     where so_ledger.ITEM_CODE = OLD.ITEM_CODE and
        so_ledger.UOM_CD = OLD.UOM_CD and
        so_ledger.CUST_CODE = OLD.CUST_CODE into numrows1;
    IF (numrows1 > 0) THEN
    BEGIN
      EXCEPTION E_SALE_LEDGER_EXIST;
    END

    select count(*)
    from so_order_dt
     where so_order_dt.ITEM_CODE = OLD.ITEM_CODE and
        so_order_dt.UOM = OLD.UOM_CD and
        so_order_dt.CUST_CODE = OLD.CUST_CODE into numrows1;
    IF (numrows1 > 0) THEN
    BEGIN
      EXCEPTION E_SO_ORDER_DT_EXIST;
    END


    select count(*)
    from so_quotation_dt
     where so_quotation_dt.ITEM_CODE = OLD.ITEM_CODE and
        so_quotation_dt.UOM = OLD.UOM_CD and
        so_quotation_dt.CUST_CODE = OLD.CUST_CODE into numrows1;
    IF (numrows1 > 0) THEN
    BEGIN
      EXCEPTION E_SO_QUOTATION_DT_EXIST;
    END

    if (numrows1 =0) then
    begin

      delete  from SO_SALES_ITEM_REQ_SHEET
      where
        /*  SO_SALES_ITEM_REQ_SHEET.ITEM_CODE = OLD.ITEM_CODE and
            SO_SALES_ITEM_REQ_SHEET.UOM_CD = OLD.UOM_CD and
            SO_SALES_ITEM_REQ_SHEET.CUST_CODE = OLD.CUST_CODE */
        SO_SALES_ITEM_REQ_SHEET.ITEM_CODE = OLD.ITEM_CODE and
        SO_SALES_ITEM_REQ_SHEET.UOM_CD = OLD.UOM_CD and
        SO_SALES_ITEM_REQ_SHEET.CUST_CODE = OLD.CUST_CODE;

        /***NOTE THAT SO_SALES_ITEM_DT IS OBSOLETE TABLE*/
      delete from SO_SALES_ITEM_DT
      where
        /*  SO_SALES_ITEM_DT.ITEM_CODE = OLD.ITEM_CODE and
            SO_SALES_ITEM_DT.UOM_CD = OLD.UOM_CD and
            SO_SALES_ITEM_DT.CUST_CODE = OLD.CUST_CODE */
        SO_SALES_ITEM_DT.ITEM_CODE = OLD.ITEM_CODE and
        SO_SALES_ITEM_DT.UOM_CD = OLD.UOM_CD and
        SO_SALES_ITEM_DT.CUST_CODE = OLD.CUST_CODE;
    end





  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
END
^

/* Trigger: TI_AP_CREDITOR */
CREATE TRIGGER TI_AP_CREDITOR FOR AP_CREDITOR
ACTIVE AFTER INSERT POSITION 0
as
declare variable ROWSNUM smallint  ;
begin
        select count(*) from pO_SUPPLIER  
        where CREDITOR_ACCT = new.creditor_acct
        into :ROWSNUM;
if (ROWSNUM=0 )then
begin

    INSERT INTO PO_SUPPLIER (SUPPLIER_CD,CREDITOR_ACCT,NAME,ADDRESS1,ADDRESS2,ADDRESS3,
           TELEPHONE,FAX_NO,CONTRACT_PERSON,UPDATE_USER,UPDATE_DATE,province,postcode,TAX_CD)
   VALUES (NEW.CREDITOR_ACCT,NEW.creditor_acct,NEW.name,NEW.address1,NEW.address2,NEW.address3,
          NEW.telphone,NEW.fax_no,'',NULL,NULL,new.province,new.postcode,new.tax_cd);
end



  /* Trigger Text */
end
^

/* Trigger: TI_AR_DEBTOR */
CREATE TRIGGER TI_AR_DEBTOR FOR AR_DEBTOR
ACTIVE AFTER INSERT POSITION 0
as
/*** User define Trigger 2002/10/28 AON***/
declare variable ROWSNUM smallint;
begin
   select count(*)
   from so_customers 
   where debtor_acct = new.debtor_acct
   into :ROWSNUM;
if (ROWSNUM =0) then
begin
  INSERT INTO SO_CUSTOMERS (CUSTOMER_CD,NAME,ADDRESS1,ADDRESS2,ADDRESS3,TELEPHONE,FAX_NO,
 CONTRACT_PERSON,UPDATE_USER,UPDATE_DATE,DEBTOR_ACCT,tax_cd,postcode,province)
  VALUES
   (  NEW.debtor_acct,NEW.name,NEW.address1,NEW.address2,NEW.address3,
         NEW.telphone,NEW.fax_no,'',NEW.update_user,NEW.update_date,NEW.debtor_acct,NEW.tax_cd,NEW.postcode,NEW.province);
end
  /* Trigger Text */
end
^

/* Trigger: TI_IC_MAT_STK_DT */
CREATE TRIGGER TI_IC_MAT_STK_DT FOR IC_MAT_STK_DT
ACTIVE AFTER INSERT POSITION 0
as
declare variable USED_DEFAULT_ELEMENT VARCHAR(1);

declare variable lot_CD varchar(15);
declare variable purchase_date timestamp;
declare variable ROWSNUM smallint;
declare variable rowss smallint;
begin
   Lot_cd =   NEW.LOT_CD;
   purchase_date = new.purchase_date;
   SELECT max(DEFAULT_ELEMENT_DETAIL)
   FROM IC_MAT_STK_HD
   WHERE STOCK_CD = NEW.stock_cd
   AND GROUP_ID = NEW.GROUP_ID
   AND UOM_CD = NEW.uom_cd
   INTO :USED_DEFAULT_ELEMENT ;
   IF (USED_DEFAULT_ELEMENT IS NULL) THEN  USED_DEFAULT_ELEMENT ='N';
   if (USED_DEFAULT_ELEMENT ='Y') then
   BEGIN
      SELECT COUNT(*)
      FROM ic_mat_default_element
      WHERE STOCK_CD = NEW.stock_cd
      AND GROUP_ID = NEW.GROUP_ID
      AND UOM_CD = NEW.uom_cd
      INTO :ROWSNUM;
      if (ROWSNUM > 0) then
      BEGIN
           select count(*)
           from IC_MAT_ELEMENT
            WHERE STOCK_CD = NEW.stock_cd
            AND GROUP_ID = NEW.GROUP_ID
            AND UOM_CD = NEW.uom_cd
            AND LOT_CD = NEW.LOT_CD
           into :rowss;
          if (rowss = 0) then
          begin
           INSERT INTO IC_MAT_ELEMENT
           ( STOCK_CD ,
            GROUP_ID ,
            UOM_CD ,
            LOT_CD,
            PURCHASE_DATE,
            ACCT_CD,
            ELE1_PERC ,
            ELE2_PERC ,
            ELE3_PERC ,
            ELE4_PERC ,
            ELE5_PERC ,
            ELE6_PERC ,
            ELE7_PERC ,
            ELE8_PERC ,
            ELE9_PERC ,
            ELE10_PERC ,
            ELE11_PERC ,
            ELE12_PERC ,
            ELE13_PERC )
            SELECT STOCK_CD ,
            GROUP_ID ,
            UOM_CD ,
            :LOT_CD,
            :purchase_date,
            NEW.acct_code,
            ELE1_PERC ,
            ELE2_PERC ,
            ELE3_PERC ,
            ELE4_PERC ,
            ELE5_PERC ,
            ELE6_PERC ,
            ELE7_PERC ,
            ELE8_PERC ,
            ELE9_PERC ,
            ELE10_PERC ,
            ELE11_PERC ,
            ELE12_PERC ,
            ELE13_PERC
            FROM ic_mat_default_element
            WHERE STOCK_CD = NEW.stock_cd
            AND GROUP_ID = NEW.GROUP_ID
            AND UOM_CD = NEW.uom_cd ;
          end /*if rowss not already exists in ic_mat__element*/
      END
      else
     begin
          exception e_no_default_elemement;
     end

   END



  /* Trigger Text */
end
^

/* Trigger: TI_PL_REQ_DT_AI0 */
CREATE TRIGGER TI_PL_REQ_DT_AI0 FOR PL_REQ_DT
INACTIVE AFTER INSERT POSITION 0
AS
begin
    INSERT into IC_STOCK_RESERVED  VALUES(NEW.doc_no,NEW.DOC_DATE,NEW.lot_no,NEW.purchase_date,
    NEW.ref_no,NEW.ref_date,NEW.item_code,NEW.group_id,NEW.uom,NEW.qty,'jrx',current_timestamp);
end
^

/* Trigger: TI_SALES_ITEM_HD */
CREATE TRIGGER TI_SALES_ITEM_HD FOR SO_SALES_ITEM_HD
ACTIVE AFTER INSERT POSITION 0
as
declare variable ROWSNUM integer;
declare variable cust_name varchar(60);
begin

  SELECT COUNT(*)
  FROM SO_SALES_ITEM_REQ_SHEET
  WHERE ITEM_CODE = NEW.ITEM_CODE
  AND CUST_CODE = NEW.cust_code
  AND UOM_CD = NEW.uom_cd
  INTO :ROWSNUM;
    --  exception e_no_row;
  if (ROWSNUM =0) then
  BEGIN
     SELECT MAX(NAME) FROM SO_CUSTOMERS
     WHERE CUSTOMER_CD =NEW.CUST_CODE
     INTO:CUST_NAME ;



    -- execute procedure x_update_element_label NEW.CUST_CODE,NEW.item_code,'N';
     --suspend;

      INSERT INTO SO_SALES_ITEM_REQ_SHEET
      (ITEM_CODE,UOM_CD,CUST_CODE,MAX_ELE1,MAX_ELE2,MAX_ELE3,MAX_ELE4,MAX_ELE5,MAX_ELE6,MAX_ELE7,MAX_ELE8,MAX_ELE9,MAX_ELE10,MAX_ELE11,MAX_ELE12,MAX_ELE13,MAX_ELE14,MAX_ELE15,MIN_ELE1,MIN_ELE2,MIN_ELE3,MIN_ELE4,MIN_ELE5,MIN_ELE6,MIN_ELE7,MIN_ELE8,MIN_ELE9,MIN_ELE10,MIN_ELE11,MIN_ELE12,MIN_ELE13,MIN_ELE14,MIN_ELE15,ELABEL1,ELABEL2,ELABEL3,ELABEL4,ELABEL5,ELABEL6,ELABEL7,ELABEL8,ELABEL9,ELABEL10,ELABEL11,ELABEL12,ELABEL13,ELABEL14,ELABEL15,CUST_NAME)
       VALUES (NEW.ITEM_CODE,NEW.UOM_CD,NEW.CUST_CODE,
       0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,
       0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,
       '','','','','','','','','','','','','','','',:CUST_NAME);

       execute procedure x_update_element_label NEW.CUST_CODE,NEW.item_code,'N';

  END

end
^

/* Trigger: TU_AP_CREDITOR */
CREATE TRIGGER TU_AP_CREDITOR FOR AP_CREDITOR
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* UPDATE trigger on AP_CREDITOR */

BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* AP_CREDITOR R/32 AP_LEDGER ON PARENT UPDATE CASCADE */
  /*IF
     OLD.CREDITOR_ACCT <> NEW.CREDITOR_ACCT or
       OLD.CURRENCY_CODE <> NEW.CURRENCY_CODE or 
       OLD.CREDITOR_TYPE <> NEW.CREDITOR_TYPE
    (OLD.CREDITOR_ACCT <> NEW.CREDITOR_ACCT or 
     OLD.CURRENCY_CODE <> NEW.CURRENCY_CODE or 
     OLD.CREDITOR_TYPE <> NEW.CREDITOR_TYPE or
     OLD.NAME <> NEW.NAME  OR
     OLD.PROVINCE <> NEW.PROVINCE OR
     OLD.POSTCODE <> NEW.POSTCODE
     ) THEN                                   */
  BEGIN
    update AP_LEDGER
      set
        /*  AP_LEDGER.CREDITOR_ACCT = NEW.CREDITOR_ACCT,
            AP_LEDGER.CURRENCY_CODE = NEW.CURRENCY_CODE,
            AP_LEDGER.CREDITOR_TYPE = NEW.CREDITOR_TYPE */
        AP_LEDGER.CREDITOR_ACCT = NEW.CREDITOR_ACCT,
        AP_LEDGER.CURRENCY_CODE = NEW.CURRENCY_CODE,
        AP_LEDGER.CREDITOR_TYPE = NEW.CREDITOR_TYPE
      where
        /*  AP_LEDGER.CREDITOR_ACCT = OLD.CREDITOR_ACCT and
            AP_LEDGER.CURRENCY_CODE = OLD.CURRENCY_CODE and
            AP_LEDGER.CREDITOR_TYPE = OLD.CREDITOR_TYPE */
        AP_LEDGER.CREDITOR_ACCT = OLD.CREDITOR_ACCT and
        AP_LEDGER.CURRENCY_CODE = OLD.CURRENCY_CODE and
        AP_LEDGER.CREDITOR_TYPE = OLD.CREDITOR_TYPE;
    UPDATE PO_SUPPLIER
    SET PO_SUPPLIER.creditor_acct = NEW.creditor_acct ,
        PO_SUPPLIER.supplier_cd = NEW.creditor_acct,
        PO_SUPPLIER.name = NEW.name,
        PO_SUPPLIER.address1 =NEW.address1,
        PO_SUPPLIER.address2 = NEW.address2,
        PO_SUPPLIER.address3=NEW.address3,
        PO_SUPPLIER.postcode = NEW.POSTCODE,
        PO_SUPPLIER.province = NEW.province ,
        PO_SUPPLIER.TELEPHONE = NEW.telphone,
        PO_SUPPLIER.fax_no = NEW.fax_no,
        PO_SUPPLIER.tax_cd = NEW.tax_cd
    WHERE PO_SUPPLIER.CREDITOR_ACCT = OLD.creditor_acct;

    UPDATE po_order_hd
    SET SUPP_CODE = NEW.creditor_acct
    where supp_code = OLD.creditor_acct;
    
    UPDATE po_grn_hd
    SET SUPP_CODE = NEW.creditor_acct,
        NAME = NEW.name
    where supp_code = OLD.creditor_acct;

  END


  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TU_AP_CREDITOR_TYPE */
CREATE TRIGGER TU_AP_CREDITOR_TYPE FOR AP_CREDITOR_TYPE
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* UPDATE trigger on AP_CREDITOR_TYPE */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* AP_CREDITOR_TYPE R/38 AP_LEDGER ON PARENT UPDATE CASCADE */
  IF
    /* OLD.CREDITOR_TYPE <> NEW.CREDITOR_TYPE */
    (OLD.CREDITOR_TYPE <> NEW.CREDITOR_TYPE) THEN
  BEGIN
    update AP_LEDGER
      set
        /*  AP_LEDGER.CREDITOR_TYPE = NEW.CREDITOR_TYPE */
        AP_LEDGER.CREDITOR_TYPE = NEW.CREDITOR_TYPE
      where
        /*  AP_LEDGER.CREDITOR_TYPE = OLD.CREDITOR_TYPE */
        AP_LEDGER.CREDITOR_TYPE = OLD.CREDITOR_TYPE;
  END

  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* AP_CREDITOR_TYPE R/31 AP_CREDITOR ON PARENT UPDATE CASCADE */
  IF
    /* OLD.CREDITOR_TYPE <> NEW.CREDITOR_TYPE */
    (OLD.CREDITOR_TYPE <> NEW.CREDITOR_TYPE) THEN
  BEGIN
    update AP_CREDITOR
      set
        /*  AP_CREDITOR.CREDITOR_TYPE = NEW.CREDITOR_TYPE */
        AP_CREDITOR.CREDITOR_TYPE = NEW.CREDITOR_TYPE
      where
        /*  AP_CREDITOR.CREDITOR_TYPE = OLD.CREDITOR_TYPE */
        AP_CREDITOR.CREDITOR_TYPE = OLD.CREDITOR_TYPE;
  END


  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TU_AP_INVOICE_HD */
CREATE TRIGGER TU_AP_INVOICE_HD FOR AP_INVOICE_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* UPDATE trigger on AP_INVOICE_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* AP_INVOICE_HD R/65 AP_INVOICE_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.CREDITOR_ACCT <> NEW.CREDITOR_ACCT or 
       OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE or 
       OLD.TRX_TYPE <> NEW.TRX_TYPE */
    (OLD.CREDITOR_ACCT <> NEW.CREDITOR_ACCT or 
     OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE or 
     OLD.TRX_TYPE <> NEW.TRX_TYPE) THEN
  BEGIN
    update AP_INVOICE_DT
      set
        /*  AP_INVOICE_DT.CREDITOR_ACCT = NEW.CREDITOR_ACCT,
            AP_INVOICE_DT.DOC_NO = NEW.DOC_NO,
            AP_INVOICE_DT.DOC_DATE = NEW.DOC_DATE,
            AP_INVOICE_DT.TRX_TYPE = NEW.TRX_TYPE */
        AP_INVOICE_DT.CREDITOR_ACCT = NEW.CREDITOR_ACCT,
        AP_INVOICE_DT.DOC_NO = NEW.DOC_NO,
        AP_INVOICE_DT.DOC_DATE = NEW.DOC_DATE,
        AP_INVOICE_DT.TRX_TYPE = NEW.TRX_TYPE
      where
        /*  AP_INVOICE_DT.CREDITOR_ACCT = OLD.CREDITOR_ACCT and
            AP_INVOICE_DT.DOC_NO = OLD.DOC_NO and
            AP_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
            AP_INVOICE_DT.TRX_TYPE = OLD.TRX_TYPE */
        AP_INVOICE_DT.CREDITOR_ACCT = OLD.CREDITOR_ACCT and
        AP_INVOICE_DT.DOC_NO = OLD.DOC_NO and
        AP_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
        AP_INVOICE_DT.TRX_TYPE = OLD.TRX_TYPE;
  END


  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TU_AP_PAY_HD */
CREATE TRIGGER TU_AP_PAY_HD FOR AP_PAY_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* UPDATE trigger on AP_PAY_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* AP_PAY_HD R/66 AP_PAY_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.CREDITOR_ACCT <> NEW.CREDITOR_ACCT or 
       OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE */
    (OLD.CREDITOR_ACCT <> NEW.CREDITOR_ACCT or 
     OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE) THEN
  BEGIN
    update AP_PAY_DT
      set
        /*  AP_PAY_DT.CREDITOR_ACCT = NEW.CREDITOR_ACCT,
            AP_PAY_DT.DOC_NO = NEW.DOC_NO,
            AP_PAY_DT.DOC_DATE = NEW.DOC_DATE */
        AP_PAY_DT.CREDITOR_ACCT = NEW.CREDITOR_ACCT,
        AP_PAY_DT.DOC_NO = NEW.DOC_NO,
        AP_PAY_DT.DOC_DATE = NEW.DOC_DATE
      where
        /*  AP_PAY_DT.CREDITOR_ACCT = OLD.CREDITOR_ACCT and
            AP_PAY_DT.DOC_NO = OLD.DOC_NO and
            AP_PAY_DT.DOC_DATE = OLD.DOC_DATE */
        AP_PAY_DT.CREDITOR_ACCT = OLD.CREDITOR_ACCT and
        AP_PAY_DT.DOC_NO = OLD.DOC_NO and
        AP_PAY_DT.DOC_DATE = OLD.DOC_DATE;
  END


  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TU_AR_CREDIT_NOTE_HD */
CREATE TRIGGER TU_AR_CREDIT_NOTE_HD FOR AR_CREDIT_NOTE_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* UPDATE trigger on AR_INVOICE_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* AR_INVOICE_HD R/65 AR_INVOICE_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.DEBTOR_ACCT <> NEW.DEBTOR_ACCT or 
       OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE or 
       OLD.TRX_TYPE <> NEW.TRX_TYPE */
    (OLD.DEBTOR_ACCT <> NEW.DEBTOR_ACCT or 
     OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE or 
     OLD.TRX_TYPE <> NEW.TRX_TYPE) THEN
  BEGIN
    update AR_CREDIT_NOTE_DT
      set

        AR_CREDIT_NOTE_DT.DEBTOR_ACCT = NEW.DEBTOR_ACCT,
        AR_CREDIT_NOTE_DT.DOC_NO = NEW.DOC_NO,
        AR_CREDIT_NOTE_DT.DOC_DATE = NEW.DOC_DATE,
        AR_CREDIT_NOTE_DT.TRX_TYPE = NEW.TRX_TYPE
      where

        AR_CREDIT_NOTE_DT.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
        AR_CREDIT_NOTE_DT.DOC_NO = OLD.DOC_NO and
        AR_CREDIT_NOTE_DT.DOC_DATE = OLD.DOC_DATE and
        AR_CREDIT_NOTE_DT.TRX_TYPE = OLD.TRX_TYPE;
  END



END
^

/* Trigger: TU_AR_DEBTOR */
CREATE TRIGGER TU_AR_DEBTOR FOR AR_DEBTOR
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* UPDATE trigger on AR_DEBTOR */

BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* AR_DEBTOR R/16 AR_LEDGER ON PARENT UPDATE CASCADE */
  /*IF
     OLD.DEBTOR_ACCT <> NEW.DEBTOR_ACCT or
       OLD.CURRENCY_CODE <> NEW.CURRENCY_CODE or 
       OLD.DEBTOR_TYPE <> NEW.DEBTOR_TYPE
    (OLD.DEBTOR_ACCT <> NEW.DEBTOR_ACCT or 
     OLD.CURRENCY_CODE <> NEW.CURRENCY_CODE or 
     OLD.DEBTOR_TYPE <> NEW.DEBTOR_TYPE or
     old.name <> new.name or
     old.province <> new.province or
     old.postcode <> new.postcode) THEN */
  BEGIN
    update AR_LEDGER
      set
        /*  AR_LEDGER.DEBTOR_ACCT = NEW.DEBTOR_ACCT,
            AR_LEDGER.CURRENCY_CODE = NEW.CURRENCY_CODE,
            AR_LEDGER.DEBTOR_TYPE = NEW.DEBTOR_TYPE */
        AR_LEDGER.DEBTOR_ACCT = NEW.DEBTOR_ACCT,
        AR_LEDGER.CURRENCY_CODE = NEW.CURRENCY_CODE,
        AR_LEDGER.DEBTOR_TYPE = NEW.DEBTOR_TYPE
      where
        /*  AR_LEDGER.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
            AR_LEDGER.CURRENCY_CODE = OLD.CURRENCY_CODE and
            AR_LEDGER.DEBTOR_TYPE = OLD.DEBTOR_TYPE */
        AR_LEDGER.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
        AR_LEDGER.CURRENCY_CODE = OLD.CURRENCY_CODE and
        AR_LEDGER.DEBTOR_TYPE = OLD.DEBTOR_TYPE;


     update so_customers
     set
     SO_CUSTOMERS.debtor_acct = NEW.debtor_acct,
     SO_CUSTOMERS.customer_cd = NEW.DEBTOR_ACCT,
     SO_CUSTOMERS.name= NEW.name,
     SO_CUSTOMERS.address1 = NEW.address1,
     SO_CUSTOMERS.address2 = NEW.ADDRESS2,
     SO_CUSTOMERS.address3 = NEW.address3 ,
     SO_CUSTOMERS.POSTCODE = NEW.POSTCODE,
     SO_CUSTOMERS.PROVINCE = NEW.PROVINCE,
     SO_CUSTOMERS.telephone = NEW.telphone,
     SO_CUSTOMERS.fax_no = NEW.FAX_NO,
     SO_CUSTOMERS.tax_cd = NEW.tax_cd
     Where SO_CUSTOMERS.debtor_acct = OLD.debtor_acct;

     update so_order_hd
     set
     so_order_hd.name= NEW.name,
     so_order_hd.address1 = NEW.address1,
     so_order_hd.address2 = NEW.ADDRESS2,
     so_order_hd.address3 = NEW.address3 ,
     so_order_hd.currency_cd = NEW.currency_code
     Where SO_ORDER_HD.cust_code = OLD.debtor_acct;

     update so_quotation_hd
     set
     so_quotation_hd.name= NEW.name,
     so_quotation_hd.address1 = NEW.address1,
     so_quotation_hd.address2 = NEW.ADDRESS2,
     so_quotation_hd.address3 = NEW.address3 ,
     so_quotation_hd.currency_cd = NEW.currency_code
     Where so_quotation_hd.cust_code = OLD.debtor_acct;




  END


  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TU_AR_DEBTOR_TYPE */
CREATE TRIGGER TU_AR_DEBTOR_TYPE FOR AR_DEBTOR_TYPE
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* UPDATE trigger on AR_DEBTOR_TYPE */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* AR_DEBTOR_TYPE R/40 AR_LEDGER ON PARENT UPDATE CASCADE */
  IF
    /* OLD.DEBTOR_TYPE <> NEW.DEBTOR_TYPE */
    (OLD.DEBTOR_TYPE <> NEW.DEBTOR_TYPE) THEN
  BEGIN
    update AR_LEDGER
      set
        /*  AR_LEDGER.DEBTOR_TYPE = NEW.DEBTOR_TYPE */
        AR_LEDGER.DEBTOR_TYPE = NEW.DEBTOR_TYPE
      where
        /*  AR_LEDGER.DEBTOR_TYPE = OLD.DEBTOR_TYPE */
        AR_LEDGER.DEBTOR_TYPE = OLD.DEBTOR_TYPE;
  END

  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* AR_DEBTOR_TYPE R/29 AR_DEBTOR ON PARENT UPDATE CASCADE */
  IF
    /* OLD.DEBTOR_TYPE <> NEW.DEBTOR_TYPE */
    (OLD.DEBTOR_TYPE <> NEW.DEBTOR_TYPE) THEN
  BEGIN
    update AR_DEBTOR
      set
        /*  AR_DEBTOR.DEBTOR_TYPE = NEW.DEBTOR_TYPE */
        AR_DEBTOR.DEBTOR_TYPE = NEW.DEBTOR_TYPE
      where
        /*  AR_DEBTOR.DEBTOR_TYPE = OLD.DEBTOR_TYPE */
        AR_DEBTOR.DEBTOR_TYPE = OLD.DEBTOR_TYPE;
  END


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TU_AR_INVOICE_HD */
CREATE TRIGGER TU_AR_INVOICE_HD FOR AR_INVOICE_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* UPDATE trigger on AR_INVOICE_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* AR_INVOICE_HD R/65 AR_INVOICE_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.DEBTOR_ACCT <> NEW.DEBTOR_ACCT or 
       OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE or 
       OLD.TRX_TYPE <> NEW.TRX_TYPE */
    (OLD.DEBTOR_ACCT <> NEW.DEBTOR_ACCT or 
     OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE or 
     OLD.TRX_TYPE <> NEW.TRX_TYPE) THEN
  BEGIN
    update AR_INVOICE_DT
      set
        /*  AR_INVOICE_DT.DEBTOR_ACCT = NEW.DEBTOR_ACCT,
            AR_INVOICE_DT.DOC_NO = NEW.DOC_NO,
            AR_INVOICE_DT.DOC_DATE = NEW.DOC_DATE,
            AR_INVOICE_DT.TRX_TYPE = NEW.TRX_TYPE */
        AR_INVOICE_DT.DEBTOR_ACCT = NEW.DEBTOR_ACCT,
        AR_INVOICE_DT.DOC_NO = NEW.DOC_NO,
        AR_INVOICE_DT.DOC_DATE = NEW.DOC_DATE,
        AR_INVOICE_DT.TRX_TYPE = NEW.TRX_TYPE
      where
        /*  AR_INVOICE_DT.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
            AR_INVOICE_DT.DOC_NO = OLD.DOC_NO and
            AR_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
            AR_INVOICE_DT.TRX_TYPE = OLD.TRX_TYPE */
        AR_INVOICE_DT.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
        AR_INVOICE_DT.DOC_NO = OLD.DOC_NO and
        AR_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
        AR_INVOICE_DT.TRX_TYPE = OLD.TRX_TYPE;
  END


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TU_AR_PAY_HD */
CREATE TRIGGER TU_AR_PAY_HD FOR AR_PAY_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* UPDATE trigger on AR_PAY_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* AR_PAY_HD R/66 AR_PAY_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.DEBTOR_ACCT <> NEW.DEBTOR_ACCT or 
       OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE */
    (OLD.DEBTOR_ACCT <> NEW.DEBTOR_ACCT or 
     OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE) THEN
  BEGIN
    update AR_PAY_DT
      set
        /*  AR_PAY_DT.DEBTOR_ACCT = NEW.DEBTOR_ACCT,
            AR_PAY_DT.DOC_NO = NEW.DOC_NO,
            AR_PAY_DT.DOC_DATE = NEW.DOC_DATE */
        AR_PAY_DT.DEBTOR_ACCT = NEW.DEBTOR_ACCT,
        AR_PAY_DT.DOC_NO = NEW.DOC_NO,
        AR_PAY_DT.DOC_DATE = NEW.DOC_DATE
      where
        /*  AR_PAY_DT.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
            AR_PAY_DT.DOC_NO = OLD.DOC_NO and
            AR_PAY_DT.DOC_DATE = OLD.DOC_DATE */
        AR_PAY_DT.DEBTOR_ACCT = OLD.DEBTOR_ACCT and
        AR_PAY_DT.DOC_NO = OLD.DOC_NO and
        AR_PAY_DT.DOC_DATE = OLD.DOC_DATE;
  END


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TU_AR_RECEIPT_HD */
CREATE TRIGGER TU_AR_RECEIPT_HD FOR AR_RECEIPT_HD
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  if ((NEW.doc_no <> OLD.doc_no) or (NEW.doc_date <> OLD.DOC_DATE) or
  (NEW.debtor_acct <> OLD.debtor_acct)  )then
  BEGIN
     UPDATE AR_RECEIPT_DT
     SET DOC_NO = NEW.doc_no,
     DOC_DATE = NEW.DOC_DATE,
     DEBTOR_ACCT = NEW.DEBTOR_ACCT
     WHERE DOC_NO = OLD.DOC_NO
     AND DOC_DATE = OLD.DOC_DATE
     AND DEBTOR_ACCT = OLD.DEBTOR_ACCT;
  END
end
^

/* Trigger: TU_CURRENCY */
CREATE TRIGGER TU_CURRENCY FOR CURRENCY
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* UPDATE trigger on CURRENCY */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* CURRENCY R/34 AP_LEDGER ON PARENT UPDATE CASCADE */
  IF
    /* OLD.CURRENCY_CODE <> NEW.CURRENCY_CODE */
    (OLD.CURRENCY_CODE <> NEW.CURRENCY_CODE) THEN
  BEGIN
    update AP_LEDGER
      set
        /*  AP_LEDGER.CURRENCY_CODE = NEW.CURRENCY_CODE */
        AP_LEDGER.CURRENCY_CODE = NEW.CURRENCY_CODE
      where
        /*  AP_LEDGER.CURRENCY_CODE = OLD.CURRENCY_CODE */
        AP_LEDGER.CURRENCY_CODE = OLD.CURRENCY_CODE;
  END

  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* CURRENCY R/26 AR_DEBTOR ON PARENT UPDATE CASCADE */
  IF
    /* OLD.CURRENCY_CODE <> NEW.CURRENCY_CODE */
    (OLD.CURRENCY_CODE <> NEW.CURRENCY_CODE) THEN
  BEGIN
    update AR_DEBTOR
      set
        /*  AR_DEBTOR.CURRENCY_CODE = NEW.CURRENCY_CODE */
        AR_DEBTOR.CURRENCY_CODE = NEW.CURRENCY_CODE
      where
        /*  AR_DEBTOR.CURRENCY_CODE = OLD.CURRENCY_CODE */
        AR_DEBTOR.CURRENCY_CODE = OLD.CURRENCY_CODE;

  END
  BEGIN
    UPDATE so_order_hd
    SET
        SO_ORDER_HD.currency_descs = NEW.descs
    where
        SO_ORDER_HD.currency_cd = NEW.currency_code;
  END
  BEGIN
    UPDATE so_quotation_hd
    SET
        SO_QUOTATION_HD.currency_descs = NEW.descs
    where
        SO_QUOTATION_HD.currency_cd = NEW.currency_code;
  END


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TU_IC_GROUP */
CREATE TRIGGER TU_IC_GROUP FOR IC_GROUP
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* UPDATE trigger on IC_GROUP */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* IC_GROUP R/43 IC_MAT_STK_HD ON PARENT UPDATE CASCADE */
  IF
    /* OLD.GROUP_ID <> NEW.GROUP_ID */
    (OLD.GROUP_ID <> NEW.GROUP_ID) THEN
  BEGIN
    update IC_MAT_STK_HD
      set
        /*  IC_MAT_STK_HD.GROUP_ID = NEW.GROUP_ID */
        IC_MAT_STK_HD.GROUP_ID = NEW.GROUP_ID
      where
        /*  IC_MAT_STK_HD.GROUP_ID = OLD.GROUP_ID */
        IC_MAT_STK_HD.GROUP_ID = OLD.GROUP_ID;
  END


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TU_IC_MAT_DEFAULT_ELEMENT */
CREATE TRIGGER TU_IC_MAT_DEFAULT_ELEMENT FOR IC_MAT_DEFAULT_ELEMENT
ACTIVE AFTER UPDATE POSITION 0
AS
begin
   UPDATE IC_MAT_ELEMENT
   SET
       IC_MAT_ELEMENT.ele1_perc = NEW.ele1_perc,
       IC_MAT_ELEMENT.ele2_perc = NEW.ele2_perc,
       IC_MAT_ELEMENT.ele3_perc = NEW.ele3_perc,
       IC_MAT_ELEMENT.ele4_perc = NEW.ele4_perc,
       IC_MAT_ELEMENT.ele5_perc = NEW.ele5_perc,
       IC_MAT_ELEMENT.ele6_perc = NEW.ele6_perc,
       IC_MAT_ELEMENT.ele7_perc = NEW.ele7_perc,
       IC_MAT_ELEMENT.ele8_perc = NEW.ele8_perc,
       IC_MAT_ELEMENT.ele9_perc = NEW.ele9_perc,
       IC_MAT_ELEMENT.ele10_perc = NEW.ele10_perc,
       IC_MAT_ELEMENT.ele11_perc = NEW.ele11_perc,
       IC_MAT_ELEMENT.ele12_perc = NEW.ele12_perc,
       IC_MAT_ELEMENT.ele13_perc = NEW.ele13_perc
   WHERE IC_MAT_ELEMENT.stock_cd = NEW.stock_cd
   AND IC_MAT_ELEMENT.uom_cd = NEW.uom_cd
   AND IC_MAT_ELEMENT.group_id = NEW.GROUP_ID  ;

  /* Trigger text */
end
^

/* Trigger: TU_IC_MAT_STK_DT */
CREATE TRIGGER TU_IC_MAT_STK_DT FOR IC_MAT_STK_DT
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Jan 06 13:18:39 2003 */
  /* UPDATE trigger on IC_MAT_STK_DT */
/*DECLARE VARIABLE ROWSNUM INTEGER;   */
BEGIN
  /* ERwin Builtin Mon Jan 06 13:18:39 2003 */
  /* IC_MAT_STK_DT R/79 IC_MAT_ELEMENT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.STOCK_CD <> NEW.STOCK_CD or 
       OLD.GROUP_ID <> NEW.GROUP_ID or 
       OLD.UOM_CD <> NEW.UOM_CD or 
       OLD.LOT_CD <> NEW.LOT_CD */
    (OLD.STOCK_CD <> NEW.STOCK_CD or 
     OLD.GROUP_ID <> NEW.GROUP_ID or 
     OLD.UOM_CD <> NEW.UOM_CD or 
     OLD.LOT_CD <> NEW.LOT_CD) THEN
  BEGIN
     BEGIN
       update IC_MAT_ELEMENT
       set
        /*  IC_MAT_ELEMENT.STOCK_CD = NEW.STOCK_CD,
            IC_MAT_ELEMENT.GROUP_ID = NEW.GROUP_ID,
            IC_MAT_ELEMENT.UOM_CD = NEW.UOM_CD,
            IC_MAT_ELEMENT.LOT_CD = NEW.LOT_CD */
         IC_MAT_ELEMENT.STOCK_CD = NEW.STOCK_CD,
         IC_MAT_ELEMENT.GROUP_ID = NEW.GROUP_ID,
         IC_MAT_ELEMENT.UOM_CD = NEW.UOM_CD,
         IC_MAT_ELEMENT.LOT_CD = NEW.LOT_CD
       where
        /*  IC_MAT_ELEMENT.STOCK_CD = OLD.STOCK_CD and
            IC_MAT_ELEMENT.GROUP_ID = OLD.GROUP_ID and
            IC_MAT_ELEMENT.UOM_CD = OLD.UOM_CD and
            IC_MAT_ELEMENT.LOT_CD = OLD.LOT_CD */
         IC_MAT_ELEMENT.STOCK_CD = OLD.STOCK_CD and
         IC_MAT_ELEMENT.GROUP_ID = OLD.GROUP_ID and
         IC_MAT_ELEMENT.UOM_CD = OLD.UOM_CD and
         IC_MAT_ELEMENT.LOT_CD = OLD.LOT_CD;
     END

     BEGIN
         UPDATE IC_MAT_STK_DT_LINK
         SET IC_MAT_STK_DT_LINK.STOCK_CD = NEW.STOCK_CD,
             IC_MAT_STK_DT_LINK.GROUP_ID = NEW.GROUP_ID,
             IC_MAT_STK_DT_LINK.UOM_CD = NEW.UOM_CD,
             IC_MAT_STK_DT_LINK.LOT_CD = NEW.LOT_CD
         WHERE
             IC_MAT_STK_DT_LINK.STOCK_CD = OLD.STOCK_CD AND
             IC_MAT_STK_DT_LINK.GROUP_ID = OLD.GROUP_ID AND
             IC_MAT_STK_DT_LINK.UOM_CD = OLD.UOM_CD AND
             IC_MAT_STK_DT_LINK.LOT_CD = OLD.LOT_CD;
     END
  END


  /* ERwin Builtin Mon Jan 06 13:18:39 2003 */
END
^

/* Trigger: TU_IC_MAT_STK_DT_LINK */
CREATE TRIGGER TU_IC_MAT_STK_DT_LINK FOR IC_MAT_STK_DT_LINK
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  if (old.unit_cost <> new.unit_cost) then
  begin
    update ic_balance_forward
    set unit_cost = new.unit_cost,
       total_cost = onhand_qty*new.unit_cost
    where lot_cd = old.lot_cd
    and purchase_date = old.purchase_date
    and ref_no = old.ref_no
    and ref_date = old.ref_date
    and stock_cd = old.stock_cd
    and group_id = old.group_id;
  end
  /* Trigger text */
end
^

/* Trigger: TU_IC_MAT_STK_HD */
CREATE TRIGGER TU_IC_MAT_STK_HD FOR IC_MAT_STK_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* UPDATE trigger on IC_MAT_STK_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* IC_MAT_STK_HD R/73 SO_SALES_ITEM_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.STOCK_CD <> NEW.STOCK_CD or 
       OLD.GROUP_ID <> NEW.GROUP_ID or 
       OLD.UOM_CD <> NEW.UOM_CD */
    (OLD.STOCK_CD <> NEW.STOCK_CD or 
     OLD.GROUP_ID <> NEW.GROUP_ID or 
     OLD.UOM_CD <> NEW.UOM_CD) THEN
  BEGIN
    update SO_SALES_ITEM_DT
      set
        /*  SO_SALES_ITEM_DT.STOCK_CD = NEW.STOCK_CD,
            SO_SALES_ITEM_DT.GROUP_ID = NEW.GROUP_ID,
            SO_SALES_ITEM_DT.UOM_CD = NEW.UOM_CD */
        SO_SALES_ITEM_DT.STOCK_CD = NEW.STOCK_CD,
        SO_SALES_ITEM_DT.GROUP_ID = NEW.GROUP_ID,
        SO_SALES_ITEM_DT.UOM_CD = NEW.UOM_CD
      where
        /*  SO_SALES_ITEM_DT.STOCK_CD = OLD.STOCK_CD and
            SO_SALES_ITEM_DT.GROUP_ID = OLD.GROUP_ID and
            SO_SALES_ITEM_DT.UOM_CD = OLD.UOM_CD */
        SO_SALES_ITEM_DT.STOCK_CD = OLD.STOCK_CD and
        SO_SALES_ITEM_DT.GROUP_ID = OLD.GROUP_ID and
        SO_SALES_ITEM_DT.UOM_CD = OLD.UOM_CD;
  END

  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* IC_MAT_STK_HD R/69 IC_STOCKCARD ON PARENT UPDATE CASCADE */
  IF
    /* OLD.STOCK_CD <> NEW.STOCK_CD or 
       OLD.GROUP_ID <> NEW.GROUP_ID or 
       OLD.UOM_CD <> NEW.UOM_CD */
    (OLD.STOCK_CD <> NEW.STOCK_CD or 
     OLD.GROUP_ID <> NEW.GROUP_ID or 
     OLD.UOM_CD <> NEW.UOM_CD) THEN
  BEGIN
    update IC_STOCKCARD
      set
        /*  IC_STOCKCARD.STOCK_CD = NEW.STOCK_CD,
            IC_STOCKCARD.GROUP_ID = NEW.GROUP_ID,
            IC_STOCKCARD.UOM_CD = NEW.UOM_CD */
        IC_STOCKCARD.STOCK_CD = NEW.STOCK_CD,
        IC_STOCKCARD.GROUP_ID = NEW.GROUP_ID,
        IC_STOCKCARD.UOM_CD = NEW.UOM_CD
      where
        /*  IC_STOCKCARD.STOCK_CD = OLD.STOCK_CD and
            IC_STOCKCARD.GROUP_ID = OLD.GROUP_ID and
            IC_STOCKCARD.UOM_CD = OLD.UOM_CD */
        IC_STOCKCARD.STOCK_CD = OLD.STOCK_CD and
        IC_STOCKCARD.GROUP_ID = OLD.GROUP_ID and
        IC_STOCKCARD.UOM_CD = OLD.UOM_CD;
  END

  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* IC_MAT_STK_HD R/44 IC_MAT_STK_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.STOCK_CD <> NEW.STOCK_CD or 
       OLD.GROUP_ID <> NEW.GROUP_ID or 
       OLD.UOM_CD <> NEW.UOM_CD */
    (OLD.STOCK_CD <> NEW.STOCK_CD or 
     OLD.GROUP_ID <> NEW.GROUP_ID or 
     OLD.UOM_CD <> NEW.UOM_CD) THEN
  BEGIN
    update IC_MAT_STK_DT
      set
        /*  IC_MAT_STK_DT.STOCK_CD = NEW.STOCK_CD,
            IC_MAT_STK_DT.GROUP_ID = NEW.GROUP_ID,
            IC_MAT_STK_DT.UOM_CD = NEW.UOM_CD */
        IC_MAT_STK_DT.STOCK_CD = NEW.STOCK_CD,
        IC_MAT_STK_DT.GROUP_ID = NEW.GROUP_ID,
        IC_MAT_STK_DT.UOM_CD = NEW.UOM_CD
      where
        /*  IC_MAT_STK_DT.STOCK_CD = OLD.STOCK_CD and
            IC_MAT_STK_DT.GROUP_ID = OLD.GROUP_ID and
            IC_MAT_STK_DT.UOM_CD = OLD.UOM_CD */
        IC_MAT_STK_DT.STOCK_CD = OLD.STOCK_CD and
        IC_MAT_STK_DT.GROUP_ID = OLD.GROUP_ID and
        IC_MAT_STK_DT.UOM_CD = OLD.UOM_CD;
  END
  /*UPDATE IC_MAT_ELEMENT AND IC_MAT_DEFAULT ELEMENT*/
  IF
    /* OLD.STOCK_CD <> NEW.STOCK_CD or 
       OLD.GROUP_ID <> NEW.GROUP_ID or 
       OLD.UOM_CD <> NEW.UOM_CD */
    (OLD.STOCK_CD <> NEW.STOCK_CD or 
     OLD.GROUP_ID <> NEW.GROUP_ID or 
     OLD.UOM_CD <> NEW.UOM_CD) THEN
  BEGIN
    update IC_MAT_ELEMENT
      set
        /*  IC_MAT_STK_DT.STOCK_CD = NEW.STOCK_CD,
            IC_MAT_STK_DT.GROUP_ID = NEW.GROUP_ID,
            IC_MAT_STK_DT.UOM_CD = NEW.UOM_CD */
        IC_MAT_ELEMENT.STOCK_CD = NEW.STOCK_CD,
        IC_MAT_ELEMENT.GROUP_ID = NEW.GROUP_ID,
        IC_MAT_ELEMENT.UOM_CD = NEW.UOM_CD
      where
        /*  IC_MAT_STK_DT.STOCK_CD = OLD.STOCK_CD and
            IC_MAT_STK_DT.GROUP_ID = OLD.GROUP_ID and
            IC_MAT_STK_DT.UOM_CD = OLD.UOM_CD */
        IC_MAT_ELEMENT.STOCK_CD = OLD.STOCK_CD and
        IC_MAT_ELEMENT.GROUP_ID = OLD.GROUP_ID and
        IC_MAT_ELEMENT.UOM_CD = OLD.UOM_CD;

      update IC_MAT_DEFAULT_ELEMENT
      set
        /*  IC_MAT_STK_DT.STOCK_CD = NEW.STOCK_CD,
            IC_MAT_STK_DT.GROUP_ID = NEW.GROUP_ID,
            IC_MAT_STK_DT.UOM_CD = NEW.UOM_CD */
        IC_MAT_DEFAULT_ELEMENT.STOCK_CD = NEW.STOCK_CD,
        IC_MAT_DEFAULT_ELEMENT.GROUP_ID = NEW.GROUP_ID,
        IC_MAT_DEFAULT_ELEMENT.UOM_CD = NEW.UOM_CD
      where
        /*  IC_MAT_STK_DT.STOCK_CD = OLD.STOCK_CD and
            IC_MAT_STK_DT.GROUP_ID = OLD.GROUP_ID and
            IC_MAT_STK_DT.UOM_CD = OLD.UOM_CD */
        IC_MAT_DEFAULT_ELEMENT.STOCK_CD = OLD.STOCK_CD and
        IC_MAT_DEFAULT_ELEMENT.GROUP_ID = OLD.GROUP_ID and
        IC_MAT_DEFAULT_ELEMENT.UOM_CD = OLD.UOM_CD;

  END
  /*UPDATE PO INFORMALTION*/
   IF
    /* OLD.STOCK_CD <> NEW.STOCK_CD or 
       OLD.GROUP_ID <> NEW.GROUP_ID or 
       OLD.UOM_CD <> NEW.UOM_CD */
    (OLD.STOCK_CD <> NEW.STOCK_CD or 
     OLD.GROUP_ID <> NEW.GROUP_ID or 
     OLD.UOM_CD <> NEW.UOM_CD) THEN
  BEGIN

    UPDATE PO_ORDER_DT
     SET PO_ORDER_DT.ITEM_CODE = NEW.STOCK_CD,
      PO_ORDER_DT.GROUP_ID = NEW.GROUP_ID,
       PO_ORDER_DT.uom = NEW.UOM_CD
     WHERE   PO_ORDER_DT.ITEM_CODE = OLD.STOCK_CD AND
       PO_ORDER_DT.GROUP_ID  =OLD.GROUP_ID AND
      PO_ORDER_DT.uom= OLD.UOM_CD ;

     UPDATE PO_GRN_DT
     SET PO_GRN_DT.ITEM_CODE = NEW.STOCK_CD,
      PO_GRN_DT.GROUP_ID = NEW.GROUP_ID,
      PO_GRN_DT.uom = NEW.UOM_CD
     WHERE   PO_GRN_DT.ITEM_CODE = OLD.STOCK_CD AND
       PO_GRN_DT.GROUP_ID  =OLD.GROUP_ID AND
      PO_GRN_DT.uom= OLD.UOM_CD ;


        UPDATE PL_REQ_DT
     SET PL_REQ_DT.ITEM_CODE = NEW.STOCK_CD,
      PL_REQ_DT.GROUP_ID = NEW.GROUP_ID,
      PL_REQ_DT.uom = NEW.UOM_CD
     WHERE   PL_REQ_DT.ITEM_CODE  = OLD.STOCK_CD AND
       PL_REQ_DT.GROUP_ID =OLD.GROUP_ID AND
      PL_REQ_DT.uom= OLD.UOM_CD ;

     UPDATE ic_stock_adjust_dt
     SET ic_stock_adjust_dt.ITEM_CODE = NEW.STOCK_CD,
      ic_stock_adjust_dt.GROUP_ID = NEW.GROUP_ID,
      ic_stock_adjust_dt.uom_CD = NEW.UOM_CD
     WHERE   ic_stock_adjust_dt.ITEM_CODE = OLD.STOCK_CD AND
      ic_stock_adjust_dt.GROUP_ID  =OLD.GROUP_ID AND
      ic_stock_adjust_dt.uom_cd= OLD.UOM_CD ;


  END



  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TU_IC_STOCK_ADJUST_DT */
CREATE TRIGGER TU_IC_STOCK_ADJUST_DT FOR IC_STOCK_ADJUST_DT
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Thu Apr 24 13:09:59 2003 */
  /* UPDATE trigger on IC_STOCK_ADJUST_DT */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Thu Apr 24 13:09:59 2003 */
  /* IC_STOCK_ADJUST_DT R/81 IC_STOCK_ADJUST_LOGS ON PARENT UPDATE RESTRICT */
  IF
    /* OLD.ITEM_CODE <> NEW.ITEM_CODE or 
       OLD.UOM_CD <> NEW.UOM_CD or 
       OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE or 
       OLD.GROUP_ID <> NEW.GROUP_ID or 
       OLD.LOT_NO <> NEW.LOT_NO */
    (OLD.ITEM_CODE <> NEW.ITEM_CODE or 
     OLD.UOM_CD <> NEW.UOM_CD or 
     OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE or 
     OLD.GROUP_ID <> NEW.GROUP_ID or 
     OLD.LOT_NO <> NEW.LOT_NO) THEN
  BEGIN
    select count(*)
      from IC_STOCK_ADJUST_LOGS
      where
        /*  IC_STOCK_ADJUST_LOGS.ITEM_CODE = OLD.ITEM_CODE and
            IC_STOCK_ADJUST_LOGS.UOM_CD = OLD.UOM_CD and
            IC_STOCK_ADJUST_LOGS.DOC_NO = OLD.DOC_NO and
            IC_STOCK_ADJUST_LOGS.DOC_DATE = OLD.DOC_DATE and
            IC_STOCK_ADJUST_LOGS.GROUP_ID = OLD.GROUP_ID and
            IC_STOCK_ADJUST_LOGS.LOT_NO = OLD.LOT_NO */
        IC_STOCK_ADJUST_LOGS.ITEM_CODE = OLD.ITEM_CODE and
        IC_STOCK_ADJUST_LOGS.UOM_CD = OLD.UOM_CD and
        IC_STOCK_ADJUST_LOGS.DOC_NO = OLD.DOC_NO and
        IC_STOCK_ADJUST_LOGS.DOC_DATE = OLD.DOC_DATE and
        IC_STOCK_ADJUST_LOGS.GROUP_ID = OLD.GROUP_ID and
        IC_STOCK_ADJUST_LOGS.LOT_NO = OLD.LOT_NO into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_UPDATE_RESTRICT;
    END
  END

  /* ERwin Builtin Thu Apr 24 13:09:59 2003 */
  /* IC_STOCK_ADJUST_DT R/80 IC_STOCK_ADJUST_LOGS ON PARENT UPDATE RESTRICT */
  IF
    /* OLD.ITEM_CODE <> NEW.ITEM_CODE or 
       OLD.UOM_CD <> NEW.UOM_CD or 
       OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE or 
       OLD.GROUP_ID <> NEW.GROUP_ID or 
       OLD.LOT_NO <> NEW.LOT_NO */
    (OLD.ITEM_CODE <> NEW.ITEM_CODE or 
     OLD.UOM_CD <> NEW.UOM_CD or 
     OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE or 
     OLD.GROUP_ID <> NEW.GROUP_ID or 
     OLD.LOT_NO <> NEW.LOT_NO) THEN
  BEGIN
    select count(*)
      from IC_STOCK_ADJUST_LOGS
      where
        /*  IC_STOCK_ADJUST_LOGS.ITEM_CODE = OLD.ITEM_CODE and
            IC_STOCK_ADJUST_LOGS.UOM_CD = OLD.UOM_CD and
            IC_STOCK_ADJUST_LOGS.DOC_NO = OLD.DOC_NO and
            IC_STOCK_ADJUST_LOGS.DOC_DATE = OLD.DOC_DATE and
            IC_STOCK_ADJUST_LOGS.GROUP_ID = OLD.GROUP_ID and
            IC_STOCK_ADJUST_LOGS.LOT_NO = OLD.LOT_NO */
        IC_STOCK_ADJUST_LOGS.ITEM_CODE = OLD.ITEM_CODE and
        IC_STOCK_ADJUST_LOGS.UOM_CD = OLD.UOM_CD and
        IC_STOCK_ADJUST_LOGS.DOC_NO = OLD.DOC_NO and
        IC_STOCK_ADJUST_LOGS.DOC_DATE = OLD.DOC_DATE and
        IC_STOCK_ADJUST_LOGS.GROUP_ID = OLD.GROUP_ID and
        IC_STOCK_ADJUST_LOGS.LOT_NO = OLD.LOT_NO into ROWSNUM;
    IF (ROWSNUM > 0) THEN
    BEGIN
      EXCEPTION ERWIN_PARENT_UPDATE_RESTRICT;
    END
  END


  /* ERwin Builtin Thu Apr 24 13:09:59 2003 */
END
^

/* Trigger: TU_IC_STOCK_ADJUST_HD */
CREATE TRIGGER TU_IC_STOCK_ADJUST_HD FOR IC_STOCK_ADJUST_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Thu Apr 24 12:36:49 2003 */
  /* UPDATE trigger on IC_STOCK_ADJUST_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Thu Apr 24 12:36:49 2003 */
  /* IC_STOCK_ADJUST_HD R/79 IC_STOCK_ADJUST_DT ON PARENT UPDATE RESTRICT */
  IF
    /* OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE */
    (OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE) THEN
  BEGIN
      UPDATE
      IC_STOCK_ADJUST_DT
     SET IC_STOCK_ADJUST_DT.DOC_NO = NEW.DOC_NO,
        IC_STOCK_ADJUST_DT.DOC_DATE = NEW.DOC_DATE
      where
        /*  IC_STOCK_ADJUST_DT.DOC_NO = OLD.DOC_NO and
            IC_STOCK_ADJUST_DT.DOC_DATE = OLD.DOC_DATE */
        IC_STOCK_ADJUST_DT.DOC_NO = OLD.DOC_NO and
        IC_STOCK_ADJUST_DT.DOC_DATE = OLD.DOC_DATE;
  END




  /* ERwin Builtin Thu Apr 24 12:36:49 2003 */
END
^

/* Trigger: TU_IC_UOM */
CREATE TRIGGER TU_IC_UOM FOR IC_UOM
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* UPDATE trigger on IC_UOM */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
  /* IC_UOM R/42 IC_MAT_STK_HD ON PARENT UPDATE CASCADE */
  IF
    /* OLD.UOM_CD <> NEW.UOM_CD */
    (OLD.UOM_CD <> NEW.UOM_CD) THEN
  BEGIN
    update IC_MAT_STK_HD
      set
        /*  IC_MAT_STK_HD.UOM_CD = NEW.UOM_CD */
        IC_MAT_STK_HD.UOM_CD = NEW.UOM_CD
      where
        /*  IC_MAT_STK_HD.UOM_CD = OLD.UOM_CD */
        IC_MAT_STK_HD.UOM_CD = OLD.UOM_CD;
  END


  /* ERwin Builtin Mon Nov 11 16:42:53 2002 */
END
^

/* Trigger: TU_PL_DISPATCH_HD */
CREATE TRIGGER TU_PL_DISPATCH_HD FOR PL_DISPATCH_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 17 14:19:28 2003 */
  /* UPDATE trigger on PL_DISPATCH_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 17 14:19:28 2003 */
  /* PL_DISPATCH_HD R/79 PL_DISPATCH_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE */
    (OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE) THEN
  BEGIN
    update PL_DISPATCH_DT
      set
        /*  PL_DISPATCH_DT.DOC_NO = NEW.DOC_NO,
            PL_DISPATCH_DT.DOC_DATE = NEW.DOC_DATE */
        PL_DISPATCH_DT.DOC_NO = NEW.DOC_NO,
        PL_DISPATCH_DT.DOC_DATE = NEW.DOC_DATE
      where
        /*  PL_DISPATCH_DT.DOC_NO = OLD.DOC_NO and
            PL_DISPATCH_DT.DOC_DATE = OLD.DOC_DATE */
        PL_DISPATCH_DT.DOC_NO = OLD.DOC_NO and
        PL_DISPATCH_DT.DOC_DATE = OLD.DOC_DATE;
  END


  /* ERwin Builtin Mon Nov 17 14:19:28 2003 */
END
^

/* Trigger: TU_PL_DROSS_HD */
CREATE TRIGGER TU_PL_DROSS_HD FOR PL_DROSS_HD
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  if( (OLD.melt_no <> NEW.melt_no) OR
  (OLD.receive_doc <> NEW.receive_doc) OR
  (OLD.receive_date <> NEW.receive_date))then
  BEGIN
    update pl_dross_dt
    set pl_dross_dt.melt_no = new.melt_no,
       pl_dross_dt.receive_doc = new.receive_doc,
       pl_dross_dt.receive_date = new.receive_date
   where melt_no = old.melt_no
   and receive_Doc= old.receive_doc
   and receive_date = old.receive_date;
   END
  /* Trigger text */
end
^

/* Trigger: TU_PL_FNG_ADJ_HD */
CREATE TRIGGER TU_PL_FNG_ADJ_HD FOR PL_FNG_ADJ_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Fri Aug 08 09:30:39 2003 */
  /* UPDATE trigger on PL_FNG_ADJ_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Fri Aug 08 09:30:39 2003 */
  /* PL_FNG_ADJ_HD R/78 PL_FNG_ADJ_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE */
    (OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE) THEN
  BEGIN
    update PL_FNG_ADJ_DT
      set
        /*  PL_FNG_ADJ_DT.DOC_NO = NEW.DOC_NO,
            PL_FNG_ADJ_DT.DOC_DATE = NEW.DOC_DATE */
        PL_FNG_ADJ_DT.DOC_NO = NEW.DOC_NO,
        PL_FNG_ADJ_DT.DOC_DATE = NEW.DOC_DATE
      where
        /*  PL_FNG_ADJ_DT.DOC_NO = OLD.DOC_NO and
            PL_FNG_ADJ_DT.DOC_DATE = OLD.DOC_DATE */
        PL_FNG_ADJ_DT.DOC_NO = OLD.DOC_NO and
        PL_FNG_ADJ_DT.DOC_DATE = OLD.DOC_DATE;
  END


  /* ERwin Builtin Fri Aug 08 09:30:39 2003 */
END
^

/* Trigger: TU_PL_FNG_RET_HD */
CREATE TRIGGER TU_PL_FNG_RET_HD FOR PL_FNG_RET_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Fri Aug 08 09:31:38 2003 */
  /* UPDATE trigger on PL_FNG_RET_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Fri Aug 08 09:31:38 2003 */
  /* PL_FNG_RET_HD R/77 PL_FNG_RET_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE or 
       OLD.CUST_CODE <> NEW.CUST_CODE or 
       OLD.MELT_NO <> NEW.MELT_NO */
    (OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE or 
     OLD.CUST_CODE <> NEW.CUST_CODE or 
     OLD.MELT_NO <> NEW.MELT_NO) THEN
  BEGIN
    update PL_FNG_RET_DT
      set
        /*  PL_FNG_RET_DT.DOC_NO = NEW.DOC_NO,
            PL_FNG_RET_DT.DOC_DATE = NEW.DOC_DATE,
            PL_FNG_RET_DT.CUST_CODE = NEW.CUST_CODE,
            PL_FNG_RET_DT.MELT_NO = NEW.MELT_NO */
        PL_FNG_RET_DT.DOC_NO = NEW.DOC_NO,
        PL_FNG_RET_DT.DOC_DATE = NEW.DOC_DATE,
        PL_FNG_RET_DT.CUST_CODE = NEW.CUST_CODE,
        PL_FNG_RET_DT.MELT_NO = NEW.MELT_NO
      where
        /*  PL_FNG_RET_DT.DOC_NO = OLD.DOC_NO and
            PL_FNG_RET_DT.DOC_DATE = OLD.DOC_DATE and
            PL_FNG_RET_DT.CUST_CODE = OLD.CUST_CODE and
            PL_FNG_RET_DT.MELT_NO = OLD.MELT_NO */
        PL_FNG_RET_DT.DOC_NO = OLD.DOC_NO and
        PL_FNG_RET_DT.DOC_DATE = OLD.DOC_DATE and
        PL_FNG_RET_DT.CUST_CODE = OLD.CUST_CODE and
        PL_FNG_RET_DT.MELT_NO = OLD.MELT_NO;
  END


  /* ERwin Builtin Fri Aug 08 09:31:38 2003 */
END
^

/* Trigger: TU_PL_FN_RECEIVE_HD */
CREATE TRIGGER TU_PL_FN_RECEIVE_HD FOR PL_FN_RECEIVE_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Tue Apr 29 17:07:45 2003 */
  /* UPDATE trigger on PL_FN_RECEIVE_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Tue Apr 29 17:07:45 2003 */
  /* PL_FN_RECEIVE_HD R/77 PL_FN_RECEIVE_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE or 
       OLD.MELT_NO <> NEW.MELT_NO or 
       OLD.ITEM_CODE <> NEW.ITEM_CODE */
    (OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE or 
     OLD.MELT_NO <> NEW.MELT_NO or 
     OLD.ITEM_CODE <> NEW.ITEM_CODE) THEN
  BEGIN
    update PL_FN_RECEIVE_DT
      set
        /*  PL_FN_RECEIVE_DT.DOC_NO = NEW.DOC_NO,
            PL_FN_RECEIVE_DT.DOC_DATE = NEW.DOC_DATE,
            PL_FN_RECEIVE_DT.MELT_NO = NEW.MELT_NO,
            PL_FN_RECEIVE_DT.ITEM_CODE = NEW.ITEM_CODE */
        PL_FN_RECEIVE_DT.DOC_NO = NEW.DOC_NO,
        PL_FN_RECEIVE_DT.DOC_DATE = NEW.DOC_DATE,
        PL_FN_RECEIVE_DT.MELT_NO = NEW.MELT_NO,
        PL_FN_RECEIVE_DT.ITEM_CODE = NEW.ITEM_CODE
      where
        /*  PL_FN_RECEIVE_DT.DOC_NO = OLD.DOC_NO and
            PL_FN_RECEIVE_DT.DOC_DATE = OLD.DOC_DATE and
            PL_FN_RECEIVE_DT.MELT_NO = OLD.MELT_NO and
            PL_FN_RECEIVE_DT.ITEM_CODE = OLD.ITEM_CODE */
        PL_FN_RECEIVE_DT.DOC_NO = OLD.DOC_NO and
        PL_FN_RECEIVE_DT.DOC_DATE = OLD.DOC_DATE and
        PL_FN_RECEIVE_DT.MELT_NO = OLD.MELT_NO and
        PL_FN_RECEIVE_DT.ITEM_CODE = OLD.ITEM_CODE;
  END


  /* ERwin Builtin Tue Apr 29 17:07:45 2003 */
END
^

/* Trigger: TU_PL_PRO_PLAN_DT */
CREATE TRIGGER TU_PL_PRO_PLAN_DT FOR PL_PRO_PLAN_DT
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Tue Mar 11 12:29:28 2003 */
  /* UPDATE trigger on PL_PRO_PLAN_DT */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN

  /* ERwin Builtin Tue Mar 11 12:29:28 2003 */
  /* PL_PRO_PLAN_DT R/93 PL_PRO_PLAN_DISP_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.PLAN_DATE <> NEW.PLAN_DATE or 
       OLD.PLAN_DOC <> NEW.PLAN_DOC or 
       OLD.TRX_TYPE <> NEW.TRX_TYPE or 
       OLD.CUST_CODE <> NEW.CUST_CODE or 
       OLD.ORDER_NO <> NEW.ORDER_NO or 
       OLD.ORDER_DATE <> NEW.ORDER_DATE or 
       OLD.ITEM_CODE <> NEW.ITEM_CODE or 
       OLD.MELT_NO <> NEW.MELT_NO */
    (OLD.PLAN_DATE <> NEW.PLAN_DATE or 
     OLD.PLAN_DOC <> NEW.PLAN_DOC or 
     OLD.TRX_TYPE <> NEW.TRX_TYPE or 
     OLD.CUST_CODE <> NEW.CUST_CODE or 
     OLD.ORDER_NO <> NEW.ORDER_NO or 
     OLD.ORDER_DATE <> NEW.ORDER_DATE or 
     OLD.ITEM_CODE <> NEW.ITEM_CODE or 
     OLD.MELT_NO <> NEW.MELT_NO) THEN
  BEGIN
    update PL_PRO_PLAN_DISP_DT
      set
        /*  PL_PRO_PLAN_DISP_DT.PLAN_DATE = NEW.PLAN_DATE,
            PL_PRO_PLAN_DISP_DT.PLAN_DOC = NEW.PLAN_DOC,
            PL_PRO_PLAN_DISP_DT.TRX_TYPE = NEW.TRX_TYPE,
            PL_PRO_PLAN_DISP_DT.CUST_CODE = NEW.CUST_CODE,
            PL_PRO_PLAN_DISP_DT.ORDER_NO = NEW.ORDER_NO,
            PL_PRO_PLAN_DISP_DT.ORDER_DATE = NEW.ORDER_DATE,
            PL_PRO_PLAN_DISP_DT.ITEM_CODE = NEW.ITEM_CODE,
            PL_PRO_PLAN_DISP_DT.MELT_NO = NEW.MELT_NO */
        PL_PRO_PLAN_DISP_DT.PLAN_DATE = NEW.PLAN_DATE,
        PL_PRO_PLAN_DISP_DT.PLAN_DOC = NEW.PLAN_DOC,
        PL_PRO_PLAN_DISP_DT.TRX_TYPE = NEW.TRX_TYPE,
        PL_PRO_PLAN_DISP_DT.CUST_CODE = NEW.CUST_CODE,
        PL_PRO_PLAN_DISP_DT.ORDER_NO = NEW.ORDER_NO,
        PL_PRO_PLAN_DISP_DT.ORDER_DATE = NEW.ORDER_DATE,
        PL_PRO_PLAN_DISP_DT.ITEM_CODE = NEW.ITEM_CODE,
        PL_PRO_PLAN_DISP_DT.MELT_NO = NEW.MELT_NO
      where
        /*  PL_PRO_PLAN_DISP_DT.PLAN_DATE = OLD.PLAN_DATE and
            PL_PRO_PLAN_DISP_DT.PLAN_DOC = OLD.PLAN_DOC and
            PL_PRO_PLAN_DISP_DT.TRX_TYPE = OLD.TRX_TYPE and
            PL_PRO_PLAN_DISP_DT.CUST_CODE = OLD.CUST_CODE and
            PL_PRO_PLAN_DISP_DT.ORDER_NO = OLD.ORDER_NO and
            PL_PRO_PLAN_DISP_DT.ORDER_DATE = OLD.ORDER_DATE and
            PL_PRO_PLAN_DISP_DT.ITEM_CODE = OLD.ITEM_CODE and
            PL_PRO_PLAN_DISP_DT.MELT_NO = OLD.MELT_NO */
        PL_PRO_PLAN_DISP_DT.PLAN_DATE = OLD.PLAN_DATE and
        PL_PRO_PLAN_DISP_DT.PLAN_DOC = OLD.PLAN_DOC and
        PL_PRO_PLAN_DISP_DT.TRX_TYPE = OLD.TRX_TYPE and
        PL_PRO_PLAN_DISP_DT.CUST_CODE = OLD.CUST_CODE and
        PL_PRO_PLAN_DISP_DT.ORDER_NO = OLD.ORDER_NO and
        PL_PRO_PLAN_DISP_DT.ORDER_DATE = OLD.ORDER_DATE and
        PL_PRO_PLAN_DISP_DT.ITEM_CODE = OLD.ITEM_CODE and
        PL_PRO_PLAN_DISP_DT.MELT_NO = OLD.MELT_NO;
  END

  /*new update to pl_dispatch_dt*/
  update pl_dispatch_dt
  set melt_no = new.melt_no  ,
      order_no = new.order_no,
      order_date =new.order_date,
      item_code = new.item_code,
      cust_code = new.cust_code
  where melt_no = old.melt_no ;


   /*8 Jan,2011 update to rawmat sheet hd as well*/
  update pl_rawmat_sheet_hd
  set melt_no = new.melt_no  ,
    item_code = new.item_code,
    cust_code = new.cust_code
  where melt_no = old.melt_no ;



  /* ERwin Builtin Tue Mar 11 12:29:28 2003 */
END
^

/* Trigger: TU_PL_PRO_PLAN_HD */
CREATE TRIGGER TU_PL_PRO_PLAN_HD FOR PL_PRO_PLAN_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Wed Nov 27 13:47:52 2002 */
  /* UPDATE trigger on PL_PRO_PLAN_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Wed Nov 27 13:47:52 2002 */
  /* PL_PRO_PLAN_HD R/68 PL_PRO_PLAN_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.PLAN_DATE <> NEW.PLAN_DATE or 
       OLD.PLAN_DOC <> NEW.PLAN_DOC or 
       OLD.TRX_TYPE <> NEW.TRX_TYPE */
    (OLD.PLAN_DATE <> NEW.PLAN_DATE or 
     OLD.PLAN_DOC <> NEW.PLAN_DOC or 
     OLD.TRX_TYPE <> NEW.TRX_TYPE) THEN
  BEGIN
    update PL_PRO_PLAN_DT
      set
        /*  PL_PRO_PLAN_DT.PLAN_DATE = NEW.PLAN_DATE,
            PL_PRO_PLAN_DT.PLAN_DOC = NEW.PLAN_DOC,
            PL_PRO_PLAN_DT.TRX_TYPE = NEW.TRX_TYPE */
        PL_PRO_PLAN_DT.PLAN_DATE = NEW.PLAN_DATE,
        PL_PRO_PLAN_DT.PLAN_DOC = NEW.PLAN_DOC,
        PL_PRO_PLAN_DT.TRX_TYPE = NEW.TRX_TYPE
      where
        /*  PL_PRO_PLAN_DT.PLAN_DATE = OLD.PLAN_DATE and
            PL_PRO_PLAN_DT.PLAN_DOC = OLD.PLAN_DOC and
            PL_PRO_PLAN_DT.TRX_TYPE = OLD.TRX_TYPE */
        PL_PRO_PLAN_DT.PLAN_DATE = OLD.PLAN_DATE and
        PL_PRO_PLAN_DT.PLAN_DOC = OLD.PLAN_DOC and
        PL_PRO_PLAN_DT.TRX_TYPE = OLD.TRX_TYPE;
  END


  /* ERwin Builtin Wed Nov 27 13:47:52 2002 */
END
^

/* Trigger: TU_PL_RAWMAT_PLAN_HD */
CREATE TRIGGER TU_PL_RAWMAT_PLAN_HD FOR PL_RAWMAT_PLAN_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Tue Jan 07 10:48:27 2003 */
  /* UPDATE trigger on PL_RAWMAT_PLAN_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Tue Jan 07 10:48:27 2003 */
  /* PL_RAWMAT_PLAN_HD R/81 PL_RAWMAT_PLAN_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.PLAN_DOC <> NEW.PLAN_DOC or 
       OLD.PLAN_DATE <> NEW.PLAN_DATE */
    (OLD.PLAN_DOC <> NEW.PLAN_DOC or 
     OLD.PLAN_DATE <> NEW.PLAN_DATE) THEN
  BEGIN
    update PL_RAWMAT_PLAN_DT
      set
        /*  PL_RAWMAT_PLAN_DT.PLAN_DOC = NEW.PLAN_DOC,
            PL_RAWMAT_PLAN_DT.PLAN_DATE = NEW.PLAN_DATE */
        PL_RAWMAT_PLAN_DT.PLAN_DOC = NEW.PLAN_DOC,
        PL_RAWMAT_PLAN_DT.PLAN_DATE = NEW.PLAN_DATE
      where
        /*  PL_RAWMAT_PLAN_DT.PLAN_DOC = OLD.PLAN_DOC and
            PL_RAWMAT_PLAN_DT.PLAN_DATE = OLD.PLAN_DATE */
        PL_RAWMAT_PLAN_DT.PLAN_DOC = OLD.PLAN_DOC and
        PL_RAWMAT_PLAN_DT.PLAN_DATE = OLD.PLAN_DATE;
  END


  /* ERwin Builtin Tue Jan 07 10:48:27 2003 */
END
^

/* Trigger: TU_PL_RAWMAT_SHEET_HD */
CREATE TRIGGER TU_PL_RAWMAT_SHEET_HD FOR PL_RAWMAT_SHEET_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Tue Feb 25 11:25:40 2003 */
  /* UPDATE trigger on PL_RAWMAT_SHEET_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Tue Feb 25 11:25:40 2003 */
  /* PL_RAWMAT_SHEET_HD R/82 PL_RAWMAT_SHEET_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.PLAN_DOC <> NEW.PLAN_DOC or 
       OLD.PLAN_DATE <> NEW.PLAN_DATE or 
       OLD.MELT_NO <> NEW.MELT_NO or 
       OLD.ITEM_CODE <> NEW.ITEM_CODE or 
       OLD.CUST_CODE <> NEW.CUST_CODE */
    (OLD.PLAN_DOC <> NEW.PLAN_DOC or 
     OLD.PLAN_DATE <> NEW.PLAN_DATE or 
     OLD.MELT_NO <> NEW.MELT_NO or 
     OLD.ITEM_CODE <> NEW.ITEM_CODE or 
     OLD.CUST_CODE <> NEW.CUST_CODE) THEN
  BEGIN
    update PL_RAWMAT_SHEET_DT
      set
        /*  PL_RAWMAT_SHEET_DT.PLAN_DOC = NEW.PLAN_DOC,
            PL_RAWMAT_SHEET_DT.PLAN_DATE = NEW.PLAN_DATE,
            PL_RAWMAT_SHEET_DT.MELT_NO = NEW.MELT_NO,
            PL_RAWMAT_SHEET_DT.ITEM_CODE = NEW.ITEM_CODE,
            PL_RAWMAT_SHEET_DT.CUST_CODE = NEW.CUST_CODE */
        PL_RAWMAT_SHEET_DT.PLAN_DOC = NEW.PLAN_DOC,
        PL_RAWMAT_SHEET_DT.PLAN_DATE = NEW.PLAN_DATE,
        PL_RAWMAT_SHEET_DT.MELT_NO = NEW.MELT_NO,
        PL_RAWMAT_SHEET_DT.ITEM_CODE = NEW.ITEM_CODE,
        PL_RAWMAT_SHEET_DT.CUST_CODE = NEW.CUST_CODE
      where
        /*  PL_RAWMAT_SHEET_DT.PLAN_DOC = OLD.PLAN_DOC and
            PL_RAWMAT_SHEET_DT.PLAN_DATE = OLD.PLAN_DATE and
            PL_RAWMAT_SHEET_DT.MELT_NO = OLD.MELT_NO and
            PL_RAWMAT_SHEET_DT.ITEM_CODE = OLD.ITEM_CODE and
            PL_RAWMAT_SHEET_DT.CUST_CODE = OLD.CUST_CODE */
        PL_RAWMAT_SHEET_DT.PLAN_DOC = OLD.PLAN_DOC and
        PL_RAWMAT_SHEET_DT.PLAN_DATE = OLD.PLAN_DATE and
        PL_RAWMAT_SHEET_DT.MELT_NO = OLD.MELT_NO and
        PL_RAWMAT_SHEET_DT.ITEM_CODE = OLD.ITEM_CODE and
        PL_RAWMAT_SHEET_DT.CUST_CODE = OLD.CUST_CODE;


      update PL_RAWMAT_SHEET_ITEM_REQ
      set
        /*  PL_RAWMAT_SHEET_DT.PLAN_DOC = NEW.PLAN_DOC,
            PL_RAWMAT_SHEET_DT.PLAN_DATE = NEW.PLAN_DATE,
            PL_RAWMAT_SHEET_DT.MELT_NO = NEW.MELT_NO,
            PL_RAWMAT_SHEET_DT.ITEM_CODE = NEW.ITEM_CODE,
            PL_RAWMAT_SHEET_DT.CUST_CODE = NEW.CUST_CODE */
        PL_RAWMAT_SHEET_ITEM_REQ.PLAN_DOC = NEW.PLAN_DOC,
        PL_RAWMAT_SHEET_ITEM_REQ.PLAN_DATE = NEW.PLAN_DATE,
        PL_RAWMAT_SHEET_ITEM_REQ.MELT_NO = NEW.MELT_NO,
        PL_RAWMAT_SHEET_ITEM_REQ.ITEM_CODE = NEW.ITEM_CODE,
        PL_RAWMAT_SHEET_ITEM_REQ.CUST_CODE = NEW.CUST_CODE
      where
        /*  PL_RAWMAT_SHEET_DT.PLAN_DOC = OLD.PLAN_DOC and
            PL_RAWMAT_SHEET_DT.PLAN_DATE = OLD.PLAN_DATE and
            PL_RAWMAT_SHEET_DT.MELT_NO = OLD.MELT_NO and
            PL_RAWMAT_SHEET_DT.ITEM_CODE = OLD.ITEM_CODE and
            PL_RAWMAT_SHEET_DT.CUST_CODE = OLD.CUST_CODE */
        PL_RAWMAT_SHEET_ITEM_REQ.PLAN_DOC = OLD.PLAN_DOC and
        PL_RAWMAT_SHEET_ITEM_REQ.PLAN_DATE = OLD.PLAN_DATE and
        PL_RAWMAT_SHEET_ITEM_REQ.MELT_NO = OLD.MELT_NO and
        PL_RAWMAT_SHEET_ITEM_REQ.ITEM_CODE = OLD.ITEM_CODE and
        PL_RAWMAT_SHEET_ITEM_REQ.CUST_CODE = OLD.CUST_CODE;
  END


  /* ERwin Builtin Tue Feb 25 11:25:40 2003 */
END
^

/* Trigger: TU_PL_REQ_DT_AU0 */
CREATE TRIGGER TU_PL_REQ_DT_AU0 FOR PL_REQ_DT
INACTIVE AFTER UPDATE POSITION 0
AS
begin
  UPDATE IC_STOCK_RESERVED
  SET QTY = NEW.qty
  WHERE DOC_NO = NEW.DOC_NO
  AND DOC_DATE = NEW.DOC_DATE
  AND LOT_CD = NEW.lot_no
  AND PURCHASE_DATE = NEW.purchase_date
  AND REF_NO = NEW.REF_NO
  AND REF_DATE = NEW.REF_DATE
  AND STOCK_CD = NEW.item_code
  AND GROUP_ID = NEW.group_id
  AND UOM_CD = NEW.uom ;
end
^

/* Trigger: TU_PL_REQ_HD */
CREATE TRIGGER TU_PL_REQ_HD FOR PL_REQ_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Dec 02 11:09:01 2002 */
  /* UPDATE trigger on PL_REQ_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Dec 02 11:09:01 2002 */
  /* PL_REQ_HD R/75 PL_REQ_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE or 
       OLD.TRX_TYPE <> NEW.TRX_TYPE */
    (OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE or 
     OLD.TRX_TYPE <> NEW.TRX_TYPE) THEN
  BEGIN
    update PL_REQ_DT
      set
        /*  PL_REQ_DT.DOC_NO = NEW.DOC_NO,
            PL_REQ_DT.DOC_DATE = NEW.DOC_DATE,
            PL_REQ_DT.TRX_TYPE = NEW.TRX_TYPE */
        PL_REQ_DT.DOC_NO = NEW.DOC_NO,
        PL_REQ_DT.DOC_DATE = NEW.DOC_DATE,
        PL_REQ_DT.TRX_TYPE = NEW.TRX_TYPE
      where
        /*  PL_REQ_DT.DOC_NO = OLD.DOC_NO and
            PL_REQ_DT.DOC_DATE = OLD.DOC_DATE and
            PL_REQ_DT.TRX_TYPE = OLD.TRX_TYPE */
        PL_REQ_DT.DOC_NO = OLD.DOC_NO and
        PL_REQ_DT.DOC_DATE = OLD.DOC_DATE and
        PL_REQ_DT.TRX_TYPE = OLD.TRX_TYPE;




         update IC_STOCK_RESERVED
      set
        /*  PL_REQ_DT.DOC_NO = NEW.DOC_NO,
            PL_REQ_DT.DOC_DATE = NEW.DOC_DATE,
            PL_REQ_DT.TRX_TYPE = NEW.TRX_TYPE */
        IC_STOCK_RESERVED.DOC_NO = NEW.DOC_NO,
        IC_STOCK_RESERVED.DOC_DATE = NEW.DOC_DATE
       where
        /*  PL_REQ_DT.DOC_NO = OLD.DOC_NO and
            PL_REQ_DT.DOC_DATE = OLD.DOC_DATE and
            PL_REQ_DT.TRX_TYPE = OLD.TRX_TYPE */
         IC_STOCK_RESERVED.DOC_NO = OLD.DOC_NO and
       IC_STOCK_RESERVED.DOC_DATE  = OLD.DOC_DATE ;

  END


  /* ERwin Builtin Mon Dec 02 11:09:01 2002 */
END
^

/* Trigger: TU_PO_GRN_HD */
CREATE TRIGGER TU_PO_GRN_HD FOR PO_GRN_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* UPDATE trigger on PO_GRN_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* PO_GRN_HD R/56 PO_GRN_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.SUPP_CODE <> NEW.SUPP_CODE or 
       OLD.GRN_DATE <> NEW.GRN_DATE or 
       OLD.GRN_NO <> NEW.GRN_NO */
    (OLD.SUPP_CODE <> NEW.SUPP_CODE or 
     OLD.GRN_DATE <> NEW.GRN_DATE or 
     OLD.GRN_NO <> NEW.GRN_NO) THEN
  BEGIN
    update PO_GRN_DT
      set
        /*  PO_GRN_DT.SUPP_CODE = NEW.SUPP_CODE,
            PO_GRN_DT.GRN_DATE = NEW.GRN_DATE,
            PO_GRN_DT.GRN_NO = NEW.GRN_NO */
        PO_GRN_DT.SUPP_CODE = NEW.SUPP_CODE,
        PO_GRN_DT.GRN_DATE = NEW.GRN_DATE,
        PO_GRN_DT.GRN_NO = NEW.GRN_NO
      where
        /*  PO_GRN_DT.SUPP_CODE = OLD.SUPP_CODE and
            PO_GRN_DT.GRN_DATE = OLD.GRN_DATE and
            PO_GRN_DT.GRN_NO = OLD.GRN_NO */
        PO_GRN_DT.SUPP_CODE = OLD.SUPP_CODE and
        PO_GRN_DT.GRN_DATE = OLD.GRN_DATE and
        PO_GRN_DT.GRN_NO = OLD.GRN_NO;
  END


  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
END
^

/* Trigger: TU_PO_ORDER_HD */
CREATE TRIGGER TU_PO_ORDER_HD FOR PO_ORDER_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* UPDATE trigger on PO_ORDER_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN

  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* PO_ORDER_HD R/54 PO_ORDER_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.SUPP_CODE <> NEW.SUPP_CODE or 
       OLD.ORDER_DATE <> NEW.ORDER_DATE or 
       OLD.ORDER_NO <> NEW.ORDER_NO */
    (OLD.SUPP_CODE <> NEW.SUPP_CODE or 
     OLD.ORDER_DATE <> NEW.ORDER_DATE or 
     OLD.ORDER_NO <> NEW.ORDER_NO) THEN
  BEGIN
    update PO_ORDER_DT
      set
        /*  PO_ORDER_DT.SUPP_CODE = NEW.SUPP_CODE,
            PO_ORDER_DT.ORDER_DATE = NEW.ORDER_DATE,
            PO_ORDER_DT.ORDER_NO = NEW.ORDER_NO */
        PO_ORDER_DT.SUPP_CODE = NEW.SUPP_CODE,
        PO_ORDER_DT.ORDER_DATE = NEW.ORDER_DATE,
        PO_ORDER_DT.ORDER_NO = NEW.ORDER_NO
      where
        /*  PO_ORDER_DT.SUPP_CODE = OLD.SUPP_CODE and
            PO_ORDER_DT.ORDER_DATE = OLD.ORDER_DATE and
            PO_ORDER_DT.ORDER_NO = OLD.ORDER_NO */
        PO_ORDER_DT.SUPP_CODE = OLD.SUPP_CODE and
        PO_ORDER_DT.ORDER_DATE = OLD.ORDER_DATE and
        PO_ORDER_DT.ORDER_NO = OLD.ORDER_NO;
  END


  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
END
^

/* Trigger: TU_SO_CUSTOMERS */
CREATE TRIGGER TU_SO_CUSTOMERS FOR SO_CUSTOMERS
ACTIVE AFTER UPDATE POSITION 0
as
begin
   UPDATE SO_SALES_ITEM_REQ_SHEET
   SET  CUST_NAME = NEW.name       ,
        CUST_CODE = NEW.customer_cd
   WHERE CUST_CODE = OLD.customer_cd;
  /* Trigger Text */
end
^

/* Trigger: TU_SO_DET_DT_MELT */
CREATE TRIGGER TU_SO_DET_DT_MELT FOR SO_DET_DT_MELT
ACTIVE AFTER UPDATE POSITION 0
AS
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* AP_INVOICE_HD R/65 AP_INVOICE_DT ON PARENT UPDATE CASCADE */
  IF   (OLD.delivery_no <> NEW.delivery_no  OR
     OLD.delivery_DATE <> NEW.delivery_DATE or
     OLD.MELT_NO <> NEW.MELT_NO or
     OLD.REF_NO <> NEW.ref_no OR
      OLD.REF_DATE <> NEW.ref_DATE OR
       OLD.BATCH_NO <> NEW.BATCH_NO )THEN
  BEGIN
    update SO_DET_DT_LINK
      set
          delivery_no = NEW.delivery_no   ,
        delivery_DATE = NEW.delivery_DATE  ,
        MELT_NO = NEW.MELT_NO ,
        REF_NO = NEW.ref_no ,
        REF_DATE = NEW.ref_DATE,
        BATCH_NO = NEW.BATCH_NO
      where
       delivery_no = OLD.delivery_no   AND
        delivery_DATE = OLD.delivery_DATE  AND
        MELT_NO = OLD.MELT_NO AND
        REF_NO = OLD.ref_no AND
        REF_DATE = OLD.ref_DATE AND
        BATCH_NO = OLD.BATCH_NO    ;
  END


  /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
END
^

/* Trigger: TU_SO_DET_DT_ORDER */
CREATE TRIGGER TU_SO_DET_DT_ORDER FOR SO_DET_DT_ORDER
ACTIVE AFTER UPDATE POSITION 0
AS
begin
 /* ERwin Builtin Mon Nov 11 16:42:52 2002 */
  /* AP_INVOICE_HD R/65 AP_INVOICE_DT ON PARENT UPDATE CASCADE */
  IF   (OLD.delivery_no <> NEW.delivery_no  OR
     OLD.delivery_DATE <> NEW.delivery_DATE or
       OLD.BATCH_NO <> NEW.BATCH_NO )THEN
  BEGIN
    update SO_DET_DT_MELT
      set
        delivery_no = NEW.delivery_no   ,
        delivery_DATE = NEW.delivery_DATE  ,
        BATCH_NO = NEW.BATCH_NO
      where
         delivery_no = OLD.delivery_no   and
        delivery_DATE = OLD.delivery_DATE  and
        BATCH_NO = OLD.BATCH_NO ;
  END

end
^

/* Trigger: TU_SO_DET_HD */
CREATE TRIGGER TU_SO_DET_HD FOR SO_DET_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Feb 17 12:32:41 2003 */
  /* UPDATE trigger on SO_DET_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Feb 17 12:32:41 2003 */
  /* SO_DET_HD R/90 SO_DET_DT ON PARENT UPDATE RESTRICT */
  IF
    /* OLD.DELIVERY_NO <> NEW.DELIVERY_NO or 
       OLD.DELIVERY_DATE <> NEW.DELIVERY_DATE or 
       OLD.CUST_CODE <> NEW.CUST_CODE */
    (OLD.DELIVERY_NO <> NEW.DELIVERY_NO or 
     OLD.DELIVERY_DATE <> NEW.DELIVERY_DATE or 
     OLD.CUST_CODE <> NEW.CUST_CODE) THEN
  BEGIN
   update  SO_DET_DT
   set SO_DET_DT.DELIVERY_NO = NEW.DELIVERY_NO ,
    SO_DET_DT.DELIVERY_DATE = NEW.DELIVERY_DATE ,
    SO_DET_DT.CUST_CODE = NEW.CUST_CODE
      where
        /*  SO_DET_DT.DELIVERY_NO = OLD.DELIVERY_NO and
            SO_DET_DT.DELIVERY_DATE = OLD.DELIVERY_DATE and
            SO_DET_DT.CUST_CODE = OLD.CUST_CODE */
        SO_DET_DT.DELIVERY_NO = OLD.DELIVERY_NO and
        SO_DET_DT.DELIVERY_DATE = OLD.DELIVERY_DATE and
        SO_DET_DT.CUST_CODE = OLD.CUST_CODE ;



          update  SO_DET_DT_ORDER
   set  SO_DET_DT_ORDER.DELIVERY_NO = NEW.DELIVERY_NO ,
     SO_DET_DT_ORDER.DELIVERY_DATE = NEW.DELIVERY_DATE ,
    SO_DET_DT_ORDER.CUST_CODE = NEW.CUST_CODE
      where
        /*  SO_DET_DT.DELIVERY_NO = OLD.DELIVERY_NO and
            SO_DET_DT.DELIVERY_DATE = OLD.DELIVERY_DATE and
            SO_DET_DT.CUST_CODE = OLD.CUST_CODE */
        SO_DET_DT_ORDER.DELIVERY_NO = OLD.DELIVERY_NO and
        SO_DET_DT_ORDER.DELIVERY_DATE = OLD.DELIVERY_DATE and
        SO_DET_DT_ORDER.CUST_CODE = OLD.CUST_CODE ;
  END


  /* ERwin Builtin Mon Feb 17 12:32:41 2003 */
END
^

/* Trigger: TU_SO_INVOICE_HD */
CREATE TRIGGER TU_SO_INVOICE_HD FOR SO_INVOICE_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* UPDATE trigger on SO_INVOICE_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* SO_INVOICE_HD R/19 SO_INVOICE_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE or 
       OLD.CUST_CODE <> NEW.CUST_CODE */
    (OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE or 
     OLD.CUST_CODE <> NEW.CUST_CODE) THEN
  BEGIN
    update SO_INVOICE_DT
      set
        /*  SO_INVOICE_DT.DOC_NO = NEW.DOC_NO,
            SO_INVOICE_DT.DOC_DATE = NEW.DOC_DATE,
            SO_INVOICE_DT.CUST_CODE = NEW.CUST_CODE */
        SO_INVOICE_DT.DOC_NO = NEW.DOC_NO,
        SO_INVOICE_DT.DOC_DATE = NEW.DOC_DATE,
        SO_INVOICE_DT.CUST_CODE = NEW.CUST_CODE
      where
        /*  SO_INVOICE_DT.DOC_NO = OLD.DOC_NO and
            SO_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
            SO_INVOICE_DT.CUST_CODE = OLD.CUST_CODE */
        SO_INVOICE_DT.DOC_NO = OLD.DOC_NO and
        SO_INVOICE_DT.DOC_DATE = OLD.DOC_DATE and
        SO_INVOICE_DT.CUST_CODE = OLD.CUST_CODE;
  END


  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
END
^

/* Trigger: TU_SO_ORDER_DT */
CREATE TRIGGER TU_SO_ORDER_DT FOR SO_ORDER_DT
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Tue Mar 04 12:08:50 2003 */
  /* UPDATE trigger on SO_ORDER_DT */

declare variable ORDER_AMT FLOAT;
declare variable stock_usaged_dt_count smallint;
BEGIN
  /* ERwin Builtin Tue Mar 04 12:08:50 2003 */
  /* SO_ORDER_DT R/92 SO_ORDER_SCH_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.CUST_CODE <> NEW.CUST_CODE or 
       OLD.ORDER_NO <> NEW.ORDER_NO or 
       OLD.ORDER_DATE <> NEW.ORDER_DATE or 
       OLD.ITEM_CODE <> NEW.ITEM_CODE or 
       OLD.LINE_NO <> NEW.LINE_NO */
    (OLD.CUST_CODE <> NEW.CUST_CODE or 
     OLD.ORDER_NO <> NEW.ORDER_NO or 
     OLD.ORDER_DATE <> NEW.ORDER_DATE or 
     OLD.ITEM_CODE <> NEW.ITEM_CODE or 
     OLD.LINE_NO <> NEW.LINE_NO) THEN
  BEGIN
    update SO_ORDER_SCH_DT
      set
        /*  SO_ORDER_SCH_DT.CUST_CODE = NEW.CUST_CODE,
            SO_ORDER_SCH_DT.ORDER_NO = NEW.ORDER_NO,
            SO_ORDER_SCH_DT.ORDER_DATE = NEW.ORDER_DATE,
            SO_ORDER_SCH_DT.ITEM_CODE = NEW.ITEM_CODE,
            SO_ORDER_SCH_DT.LINE_NO = NEW.LINE_NO */
        SO_ORDER_SCH_DT.CUST_CODE = NEW.CUST_CODE,
        SO_ORDER_SCH_DT.ORDER_NO = NEW.ORDER_NO,
        SO_ORDER_SCH_DT.ORDER_DATE = NEW.ORDER_DATE,
        SO_ORDER_SCH_DT.ITEM_CODE = NEW.ITEM_CODE,
        SO_ORDER_SCH_DT.LINE_NO = NEW.LINE_NO
      where
        /*  SO_ORDER_SCH_DT.CUST_CODE = OLD.CUST_CODE and
            SO_ORDER_SCH_DT.ORDER_NO = OLD.ORDER_NO and
            SO_ORDER_SCH_DT.ORDER_DATE = OLD.ORDER_DATE and
            SO_ORDER_SCH_DT.ITEM_CODE = OLD.ITEM_CODE and
            SO_ORDER_SCH_DT.LINE_NO = OLD.LINE_NO */
        SO_ORDER_SCH_DT.CUST_CODE = OLD.CUST_CODE and
        SO_ORDER_SCH_DT.ORDER_NO = OLD.ORDER_NO and
        SO_ORDER_SCH_DT.ORDER_DATE = OLD.ORDER_DATE and
        SO_ORDER_SCH_DT.ITEM_CODE = OLD.ITEM_CODE and
        SO_ORDER_SCH_DT.LINE_NO = OLD.LINE_NO;
    /**Updaet Order Header Amount**/
         select sum(total_amt)
         from so_order_dt
          where order_no = new.order_no
         and order_date = new.order_date
         and cust_code = new.cust_code
         into :order_amt ;
        
        
        
         update so_order_hd
         set order_amt =:order_amt
         where order_no = new.order_no
         and order_date = new.order_date
         and cust_code = new.cust_code;

         select count(*)
         from so_order_dt
         where order_no =new.order_no
         and order_date = new.order_date
         and cust_code =new.cust_code
         and stock_usaged_flag ='N'
         INTO :stock_usaged_dt_count;
         if (stock_usaged_dt_count =0) then
         begin
             update so_order_hd
             set stock_usaged_flag ='Y'
             where order_no =new.order_no
            and order_date = new.order_date
            and cust_code =new.cust_code
            and stock_usaged_flag ='N' ;


         end
         ELSE
         BEGIN
             update so_order_hd
             set stock_usaged_flag ='Y'
             where order_no =new.order_no
             and order_date = new.order_date
             and cust_code =new.cust_code ;

         END




  END


  /* ERwin Builtin Tue Mar 04 12:08:50 2003 */
END
^

/* Trigger: TU_SO_ORDER_HD */
CREATE TRIGGER TU_SO_ORDER_HD FOR SO_ORDER_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* UPDATE trigger on SO_ORDER_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
  /* SO_ORDER_HD R/20 SO_ORDER_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.CUST_CODE <> NEW.CUST_CODE or 
       OLD.ORDER_NO <> NEW.ORDER_NO or 
       OLD.ORDER_DATE <> NEW.ORDER_DATE */
    (OLD.CUST_CODE <> NEW.CUST_CODE or 
     OLD.ORDER_NO <> NEW.ORDER_NO or 
     OLD.ORDER_DATE <> NEW.ORDER_DATE) THEN
  BEGIN
    update SO_ORDER_DT
      set
        /*  SO_ORDER_DT.CUST_CODE = NEW.CUST_CODE,
            SO_ORDER_DT.ORDER_NO = NEW.ORDER_NO,
            SO_ORDER_DT.ORDER_DATE = NEW.ORDER_DATE */
        SO_ORDER_DT.CUST_CODE = NEW.CUST_CODE,
        SO_ORDER_DT.ORDER_NO = NEW.ORDER_NO,
        SO_ORDER_DT.ORDER_DATE = NEW.ORDER_DATE
      where
        /*  SO_ORDER_DT.CUST_CODE = OLD.CUST_CODE and
            SO_ORDER_DT.ORDER_NO = OLD.ORDER_NO and
            SO_ORDER_DT.ORDER_DATE = OLD.ORDER_DATE */
        SO_ORDER_DT.CUST_CODE = OLD.CUST_CODE and
        SO_ORDER_DT.ORDER_NO = OLD.ORDER_NO and
        SO_ORDER_DT.ORDER_DATE = OLD.ORDER_DATE;
  END


  /* ERwin Builtin Mon Nov 11 16:42:54 2002 */
END
^

/* Trigger: TU_SO_ORDER_REVISION_HD */
CREATE TRIGGER TU_SO_ORDER_REVISION_HD FOR SO_ORDER_REVISION_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Thu Mar 27 10:52:42 2003 */
  /* UPDATE trigger on SO_ORDER_REVISION_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Thu Mar 27 10:52:42 2003 */
  /* SO_ORDER_REVISION_HD R/96 SO_ORDER_REVISION_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.DOC_DATE <> NEW.DOC_DATE or 
       OLD.DOC_NO <> NEW.DOC_NO */
    (OLD.DOC_DATE <> NEW.DOC_DATE or 
     OLD.DOC_NO <> NEW.DOC_NO) THEN
  BEGIN
    update SO_ORDER_REVISION_DT
      set
        /*  SO_ORDER_REVISION_DT.DOC_DATE = NEW.DOC_DATE,
            SO_ORDER_REVISION_DT.DOC_NO = NEW.DOC_NO */
        SO_ORDER_REVISION_DT.DOC_DATE = NEW.DOC_DATE,
        SO_ORDER_REVISION_DT.DOC_NO = NEW.DOC_NO
      where
        /*  SO_ORDER_REVISION_DT.DOC_DATE = OLD.DOC_DATE and
            SO_ORDER_REVISION_DT.DOC_NO = OLD.DOC_NO */
        SO_ORDER_REVISION_DT.DOC_DATE = OLD.DOC_DATE and
        SO_ORDER_REVISION_DT.DOC_NO = OLD.DOC_NO;
  END


  /* ERwin Builtin Thu Mar 27 10:52:42 2003 */
END
^

/* Trigger: TU_SO_ORDER_SCH_DT */
CREATE TRIGGER TU_SO_ORDER_SCH_DT FOR SO_ORDER_SCH_DT
ACTIVE AFTER UPDATE POSITION 0
AS
begin
   UPDATE pl_dispatch_dt
   SET DELIVERY_DATE = NEW.schedule_date,
       DET_QTY = NEW.schedule_qty,
       REMARKS = NEW.remarks
   WHERE pl_dispatch_dt.cust_code = old.cust_code
   and pl_dispatch_dt.order_no = old.order_no
   and pl_dispatch_dt.order_date = old.order_date
   and pl_dispatch_dt.item_code = old.item_code
   and pl_dispatch_dt.delivery_date = old.schedule_date;
  /* Trigger text */
end
^

/* Trigger: TU_SO_QUOTATION_DT */
CREATE TRIGGER TU_SO_QUOTATION_DT FOR SO_QUOTATION_DT
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Tue Mar 04 12:08:50 2003 */
  /* UPDATE trigger on SO_doc_DT */

declare variable doc_AMT FLOAT;
BEGIN
         select sum(total_amt)
         from so_quotation_dt
          where doc_no = new.doc_no
         and doc_date = new.doc_date
         and cust_code = new.cust_code
         into :doc_amt ;
        
        
        
         update so_quotation_hd
         set doc_amt =:doc_amt
         where doc_no = new.doc_no
         and doc_date = new.doc_date
         and cust_code = new.cust_code;



  /* ERwin Builtin Tue Mar 04 12:08:50 2003 */
END
^

/* Trigger: TU_SO_QUOTATION_HD */
CREATE TRIGGER TU_SO_QUOTATION_HD FOR SO_QUOTATION_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Mon Feb 17 12:43:23 2003 */
  /* UPDATE trigger on SO_QUOTATION_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Mon Feb 17 12:43:23 2003 */
  /* SO_QUOTATION_HD R/21 SO_QUOTATION_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.CUST_CODE <> NEW.CUST_CODE or 
       OLD.DOC_NO <> NEW.DOC_NO or 
       OLD.DOC_DATE <> NEW.DOC_DATE */
    (OLD.CUST_CODE <> NEW.CUST_CODE or 
     OLD.DOC_NO <> NEW.DOC_NO or 
     OLD.DOC_DATE <> NEW.DOC_DATE) THEN
  BEGIN
    update SO_QUOTATION_DT
      set
        /*  SO_QUOTATION_DT.CUST_CODE = NEW.CUST_CODE,
            SO_QUOTATION_DT.DOC_NO = NEW.DOC_NO,
            SO_QUOTATION_DT.DOC_DATE = NEW.DOC_DATE */
        SO_QUOTATION_DT.CUST_CODE = NEW.CUST_CODE,
        SO_QUOTATION_DT.DOC_NO = NEW.DOC_NO,
        SO_QUOTATION_DT.DOC_DATE = NEW.DOC_DATE
      where
        /*  SO_QUOTATION_DT.CUST_CODE = OLD.CUST_CODE and
            SO_QUOTATION_DT.DOC_NO = OLD.DOC_NO and
            SO_QUOTATION_DT.DOC_DATE = OLD.DOC_DATE */
        SO_QUOTATION_DT.CUST_CODE = OLD.CUST_CODE and
        SO_QUOTATION_DT.DOC_NO = OLD.DOC_NO and
        SO_QUOTATION_DT.DOC_DATE = OLD.DOC_DATE;
  END


  /* ERwin Builtin Mon Feb 17 12:43:23 2003 */
END
^

/* Trigger: TU_SO_SALES_ITEM_HD */
CREATE TRIGGER TU_SO_SALES_ITEM_HD FOR SO_SALES_ITEM_HD
ACTIVE AFTER UPDATE POSITION 0
AS
  /* ERwin Builtin Wed Apr 30 11:19:17 2003 */
  /* UPDATE trigger on SO_SALES_ITEM_HD */
DECLARE VARIABLE ROWSNUM INTEGER;
BEGIN
  /* ERwin Builtin Wed Apr 30 11:19:17 2003 */
  /* SO_SALES_ITEM_HD R/82 SO_SALES_ITEM_STOCK ON PARENT UPDATE CASCADE */
  IF
    /* OLD.ITEM_CODE <> NEW.ITEM_CODE or 
       OLD.UOM_CD <> NEW.UOM_CD or 
       OLD.CUST_CODE <> NEW.CUST_CODE */
    (OLD.ITEM_CODE <> NEW.ITEM_CODE or 
     OLD.UOM_CD <> NEW.UOM_CD or 
     OLD.CUST_CODE <> NEW.CUST_CODE) THEN
  BEGIN
    update SO_SALES_ITEM_STOCK
      set
        /*  SO_SALES_ITEM_STOCK.ITEM_CODE = NEW.ITEM_CODE,
            SO_SALES_ITEM_STOCK.UOM_CD = NEW.UOM_CD,
            SO_SALES_ITEM_STOCK.CUST_CODE = NEW.CUST_CODE */
        SO_SALES_ITEM_STOCK.ITEM_CODE = NEW.ITEM_CODE,
        SO_SALES_ITEM_STOCK.UOM_CD = NEW.UOM_CD,
        SO_SALES_ITEM_STOCK.CUST_CODE = NEW.CUST_CODE
      where
        /*  SO_SALES_ITEM_STOCK.ITEM_CODE = OLD.ITEM_CODE and
            SO_SALES_ITEM_STOCK.UOM_CD = OLD.UOM_CD and
            SO_SALES_ITEM_STOCK.CUST_CODE = OLD.CUST_CODE */
        SO_SALES_ITEM_STOCK.ITEM_CODE = OLD.ITEM_CODE and
        SO_SALES_ITEM_STOCK.UOM_CD = OLD.UOM_CD and
        SO_SALES_ITEM_STOCK.CUST_CODE = OLD.CUST_CODE;
  END

  /* ERwin Builtin Wed Apr 30 11:19:17 2003 */
  /* SO_SALES_ITEM_HD R/41 SO_SALES_ITEM_DT ON PARENT UPDATE CASCADE */
  IF
    /* OLD.ITEM_CODE <> NEW.ITEM_CODE or 
       OLD.UOM_CD <> NEW.UOM_CD or 
       OLD.CUST_CODE <> NEW.CUST_CODE */
    (OLD.ITEM_CODE <> NEW.ITEM_CODE or 
     OLD.UOM_CD <> NEW.UOM_CD or 
     OLD.CUST_CODE <> NEW.CUST_CODE) THEN
  BEGIN
    update SO_SALES_ITEM_DT
      set
        /*  SO_SALES_ITEM_DT.ITEM_CODE = NEW.ITEM_CODE,
            SO_SALES_ITEM_DT.UOM_CD = NEW.UOM_CD,
            SO_SALES_ITEM_DT.CUST_CODE = NEW.CUST_CODE */
        SO_SALES_ITEM_DT.ITEM_CODE = NEW.ITEM_CODE,
        SO_SALES_ITEM_DT.UOM_CD = NEW.UOM_CD,
        SO_SALES_ITEM_DT.CUST_CODE = NEW.CUST_CODE
      where
        /*  SO_SALES_ITEM_DT.ITEM_CODE = OLD.ITEM_CODE and
            SO_SALES_ITEM_DT.UOM_CD = OLD.UOM_CD and
            SO_SALES_ITEM_DT.CUST_CODE = OLD.CUST_CODE */
        SO_SALES_ITEM_DT.ITEM_CODE = OLD.ITEM_CODE and
        SO_SALES_ITEM_DT.UOM_CD = OLD.UOM_CD and
        SO_SALES_ITEM_DT.CUST_CODE = OLD.CUST_CODE;


        UPDATE pl_pro_plan_dt
        set pl_pro_plan_dt.item_code = new.item_code,
            pl_pro_plan_dt.cust_code = new.cust_code
        where
            pl_pro_plan_dt.item_code = old.item_code
        and    pl_pro_plan_dt.cust_code = old.cust_code;

        update pl_rawmat_sheet_hd
        set pl_rawmat_sheet_hd.item_code = new.item_code,
            pl_rawmat_sheet_hd.cust_code = new.cust_code
        where pl_rawmat_sheet_hd.item_code = old.item_code
        and pl_rawmat_sheet_hd.cust_code = old.cust_code  ;




  END


  /* ERwin Builtin Wed Apr 30 11:19:17 2003 */
END
^

SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

ALTER PROCEDURE CLONETARGET (
    REPLNO INTEGER,
    DBNO INTEGER,
    TGTDBNO INTEGER,
    NEWREPLNO INTEGER,
    NEWDBNO INTEGER,
    NEWTGTDBNO INTEGER)
AS
  DECLARE VARIABLE C INTEGER;
  DECLARE VARIABLE OLDRLNNO INTEGER;
  DECLARE VARIABLE NEWRLNNO INTEGER;
BEGIN
  select count(*) from subscribeddb where replno = :newreplno and dbno = :newtgtdbno into :c;
  if (c = 0) then 
  begin
    insert into subscribeddb(replno,dbno,username,psword,userrole)
    select :newreplno,:newtgtdbno,username,psword,userrole from subscribeddb where replno = :replno and dbno = :tgtdbno;
  end
  FOR SELECT RELATIONNO FROM RELATIONS WHERE REPLNO = :REPLNO AND DBNO = :DBNO AND TGTDBNO = :TGTDBNO INTO :OLDRLNNO DO 
  BEGIN
    NEWRLNNO = GEN_ID(RELATIONGEN,1);
    INSERT INTO RELATIONS (REPLNO, DBNO, TGTDBNO, RELATIONNO, RELATIONNAME, COMMENTS, DISABLED, TIMEFIELDNAME, CONDITION, TARGETNAME, TARGETTYPE)
    SELECT :NEWREPLNO,:NEWDBNO,:NEWTGTDBNO,:NEWRLNNO,RELATIONNAME, COMMENTS, DISABLED, TIMEFIELDNAME, CONDITION, TARGETNAME, TARGETTYPE FROM RELATIONS
      WHERE REPLNO = :REPLNO AND DBNO = :DBNO AND TGTDBNO = :TGTDBNO AND RELATIONNO = :OLDRLNNO;
    INSERT INTO RELATIONKEYFIELDS (REPLNO, DBNO, RELATIONNO, TGTDBNO, FIELDNO, FIELDNAME, TARGETNAME, COMMENTS)
    SELECT :NEWREPLNO , :NEWDBNO , :NEWRLNNO , :NEWTGTDBNO, FIELDNO, FIELDNAME, TARGETNAME, COMMENTS FROM RELATIONKEYFIELDS
      WHERE REPLNO = :REPLNO AND DBNO = :DBNO AND TGTDBNO = :TGTDBNO AND RELATIONNO = :OLDRLNNO;
    INSERT INTO RELATIONREPLFIELDS (REPLNO, DBNO, RELATIONNO, TGTDBNO, FIELDNO, FIELDNAME, TARGETNAME, COMMENTS)
    SELECT :NEWREPLNO, :NEWDBNO, :NEWRLNNO, :NEWTGTDBNO, FIELDNO, FIELDNAME, TARGETNAME, COMMENTS FROM RELATIONREPLFIELDS
      WHERE REPLNO = :REPLNO AND DBNO = :DBNO AND TGTDBNO = :TGTDBNO AND RELATIONNO = :OLDRLNNO;
  END   EXIT;
END^


ALTER PROCEDURE NEW_PROCEDURE (
    AFLAG SMALLINT,
    AYEAR INTEGER,
    AMONTH INTEGER)
RETURNS (
    PURCHASETAX_AMOUNT INTEGER,
    PURCHASEBASE_AMOUNT FLOAT,
    SALETAX_AMOUNT FLOAT,
    SALEBASE_AMOUNT FLOAT,
    REVENUE_AMOUNT FLOAT,
    TAXDIFF_AMOUNT FLOAT)
AS
begin
 if (:aflag = 0) then
 BEGIN
     SELECT SUM(MBASE_AMT),SUM(MTAX_AMT) FROM ar_ledger
    WHERE CLASS ='I'
    AND FMONTH =:AMONTH
    AND FYEAR =:AYEAR
    AND MTAX_AMT >0
    INTO :salebase_amount ,:saletax_amount;
    
    
    SELECT SUM(MBASE_AMT),SUM(MTAX_AMT) FROM AP_LEDGER
    WHERE CLASS ='P'
    AND FMONTH =:AMONTH
    AND FYEAR =:AYEAR
  --  AND MTAX_AMT >0
    INTO :purchasebase_amount,:purchasebase_amount;
END
ELSE
BEGIN
   SELECT SUM(MBASE_AMT),SUM(MTAX_AMT) FROM ar_ledger
    WHERE CLASS ='I'
    AND FMONTH =:AMONTH
    AND FYEAR =:AYEAR
    AND MTAX_AMT >0
    INTO :salebase_amount ,:saletax_amount;
    
    
    SELECT SUM(MBASE_AMT),SUM(MTAX_AMT) FROM AP_LEDGER
    WHERE CLASS ='P'
    AND FMONTH =:AMONTH
    AND FYEAR =:AYEAR
   -- AND MTAX_AMT >0
    INTO :purchasebase_amount,:purchasebase_amount;
END

 revenue_amount =   :salebase_amount -:purchasebase_amount;
 taxdiff_amount = :saletax_amount - :purchasetax_amount;


  suspend;
end^


ALTER PROCEDURE PO_SUPPLIER_UPDATE
AS
declare variable CREDITOR_ACCT VARCHAR(10);
  declare variable NAME VARCHAR(60);
  declare variable ADDRESS1 VARCHAR(60);
  declare variable ADDRESS2 VARCHAR(60);
  declare variable ADDRESS3 VARCHAR(60);
  declare variable TELEPHONE VARCHAR(30);
  declare variable FAX_NO VARCHAR(30);
  declare variable TAX_CD VARCHAR(2);
  declare variable POSTCODE VARCHAR(10);
  declare variable PROVINCE VARCHAR(30);

BEGIN
  FOR SELECT CREDITOR_ACCT,NAME,ADDRESS1,ADDRESS2,ADDRESS3,
             TELPHONE,FAX_NO,TAX_CD,POSTCODE,PROVINCE
      FROM AP_CREDITOR
      INTO :CREDITOR_ACCT,:NAME,:ADDRESS1,:ADDRESS2,:ADDRESS3,
           :TELEPHONE,:FAX_NO,:TAX_CD,:POSTCODE,:PROVINCE
  DO
    BEGIN
          UPDATE PO_SUPPLIER
          SET ADDRESS1 = :ADDRESS1,
              ADDRESS2 = :ADDRESS2,
              ADDRESS3 = :ADDRESS3,
              TELEPHONE = :TELEPHONE,
              FAX_NO = :FAX_NO,
              TAX_CD = :TAX_CD,
              POSTCODE = :POSTCODE,
              PROVINCE = :PROVINCE
          WHERE CREDITOR_ACCT = :CREDITOR_ACCT;
    END
END^


ALTER PROCEDURE POST_SODET_TOAR (
    VDOC_NO VARCHAR(15),
    VDOC_DATE TIMESTAMP,
    VCUST_CODE VARCHAR(10))
AS
declare variable DOC_NO varchar(15);
declare variable DOC_DATE timestamp;
declare variable REF_NO varchar(15);
declare variable REF_DATE timestamp;
declare variable DESCS varchar(60);
declare variable UPDATE_USER varchar(10);
declare variable UPDATE_DATE timestamp;
declare variable CUST_CODE varchar(10);
declare variable ITEM_CODE varchar(15);
declare variable QTY float;
declare variable UNIT_COST float;
declare variable TOTAL_AMT float;
declare variable TAX_AMT float;
declare variable TAX_CD varchar(2);
declare variable LINE_NO integer;
declare variable DESCS1 varchar(60);
declare variable UOM_CD varchar(4);
declare variable MODE varchar(1);
begin
  BEGIN
  MODE ='O';
  SELECT DELIVERY_NO,DELIVERY_DATE,CUST_CODE,UPDATE_USER,
             UPDATE_DATE,REF_NO,REF_DATE,DESCS
      FROM SO_DET_HD
      WHERE  DELIVERY_NO = :VDOC_NO
         AND DELIVERY_DATE = :VDOC_DATE
         AND CUST_CODE = :VCUST_CODE

      INTO   :DOC_NO,:DOC_DATE,:CUST_CODE,:UPDATE_USER,:UPDATE_DATE,
             :REF_NO,:REF_DATE,:DESCS1;

      INSERT INTO SO_INVOICE_HD (DOC_NO,DOC_DATE,DESCS,TAX_INV_NO,CUST_CODE,DOC_AMT,REF_NO,REF_DATE,STATUS,UPDATE_USER,UPDATE_DATE,TAX_INV_DATE)
      VALUES (:DOC_NO,:DOC_DATE,:DESCS1,'',:CUST_CODE,0.00,:REF_NO,:REF_DATE,'N',:UPDATE_USER,:UPDATE_DATE,:DOC_DATE);
  END
  /*FETCH FROM SO DET HD TO SO INVOICE HD*/


  LINE_NO = 0;
  FOR SELECT D.DELIVERY_NO,D.ITEM_CODE,D.DESCS,D.DELIVERY_DATE,D.CUST_CODE,D.DET_QTY,D.UNIT_COST,D.TOTAL_AMT,D.TAX_AMT,D.TAX_CD,UOM
      FROM SO_DET_DT D, SO_DET_HD H
      WHERE D.DELIVERY_NO = H.DELIVERY_NO
        AND D.DELIVERY_DATE = H.DELIVERY_DATE
        AND D.CUST_CODE = H.CUST_CODE
        AND H.STATUS <> 'X'
        AND D.DELIVERY_NO = :VDOC_NO
        AND D.DELIVERY_DATE = :VDOC_DATE
        AND D.CUST_CODE = :VCUST_CODE

      INTO :DOC_NO, :ITEM_CODE,:DESCS,:DOC_DATE, :CUST_CODE, :QTY, :UNIT_COST, :TOTAL_AMT,:TAX_AMT,:TAX_CD,:UOM_CD
  DO
  BEGIN
      LINE_NO = LINE_NO+1;

      INSERT INTO SO_INVOICE_DT (DOC_NO,DOC_DATE,ITEM_CODE,CUST_CODE,LINE_NO,ITEM_DESCS,QTY,UNIT_COST,TOTAL_AMT,BASE_AMT,TAX_AMT,DISCS_AMT,TAX_CD,DISCS_CD)
      VALUES (:DOC_NO,:DOC_DATE,:ITEM_CODE,:CUST_CODE,:LINE_NO,:DESCS,:QTY,:UNIT_COST,:TOTAL_AMT,:QTY*:UNIT_COST,:TAX_AMT,0.00,:TAX_CD,'');


      INSERT INTO SO_LEDGER (DOC_NO,DOC_DATE,ITEM_CODE,CUST_CODE,LINE_NO,DESCS,QTY,UNIT_COST,TOTAL_AMT,BASE_AMT,TAX_AMT,DISCS_AMT,TAX_CD,DISCS_CD,UOM_CD,MODE)
      VALUES (:DOC_NO,:DOC_DATE,:ITEM_CODE,:CUST_CODE,:LINE_NO,:DESCS,:QTY,:UNIT_COST,:TOTAL_AMT,:QTY*:UNIT_COST,:TAX_AMT,0.00,:TAX_CD,'',:UOM_CD,:MODE);


  END
  /*END FOR DO*/
  
  BEGIN
      UPDATE SO_DET_HD
      SET STATUS = 'X'
      WHERE DELIVERY_NO = :VDOC_NO
      AND   DELIVERY_DATE = :VDOC_DATE
      AND   CUST_CODE = :VCUST_CODE;
  END
  /*UPDATE STATUS ON SO DELIVERY HD*/

  suspend;
end^


ALTER PROCEDURE REPL$NOTIFY (
    THETYPE INTEGER)
AS
BEGIN
  IF (THETYPE = 1) THEN
    POST_EVENT 'RELOAD';
  ELSE IF (THETYPE = 2) THEN
    POST_EVENT 'REPLNOW';
  ELSE IF (THETYPE = 4) THEN
    POST_EVENT 'EXITNOW';
  ELSE IF (THETYPE = 7) THEN
    POST_EVENT 'REPLSTATS';
END^


ALTER PROCEDURE SALEORDER_REVISION (
    VDATE_FROM TIMESTAMP,
    VDATE_TO TIMESTAMP,
    VDOC_NO VARCHAR(15),
    VDOC_DATE TIMESTAMP)
AS
declare variable ORDER_NO VARCHAR(15);
    declare variable ORDER_DATE TIMESTAMP;
    declare variable ITEM_CODE VARCHAR(15);
    declare variable CUST_CODE VARCHAR(10);
    declare variable LINE_NO SMALLINT;
    declare variable UOM VARCHAR(4);
    declare variable UNIT_COST FLOAT;
    declare variable TOTAL_AMT FLOAT;
    declare variable QTY FLOAT;
    declare variable REF_NO VARCHAR(15);
    declare variable REF_DATE TIMESTAMP;
BEGIN
   FOR
     SELECT SO_ORDER_HD.ORDER_NO, SO_ORDER_HD.ORDER_DATE, SO_ORDER_HD.REF_NO,
     SO_ORDER_HD.REF_DATE , SO_ORDER_DT.ITEM_CODE,SO_ORDER_DT.CUST_CODE,SO_ORDER_DT.LINE_NO,
     SO_ORDER_DT.UOM,SO_ORDER_DT.UNIT_COST,SO_ORDER_DT.TOTAL_AMT,SO_ORDER_DT.QTY
     FROM  SO_ORDER_DT , SO_ORDER_HD
     WHERE
      SO_ORDER_HD.order_no = SO_ORDER_DT.ORDER_NO
      AND
      SO_ORDER_HD.ORDER_DATE = SO_ORDER_DT.ORDER_DATE
      AND
      SO_ORDER_HD.cust_code = SO_ORDER_DT.cust_code
      AND
      SO_ORDER_HD.ORDER_DATE BETWEEN :VDATE_FROM AND :VDATE_TO
      AND
      SO_ORDER_DT.DET_QTY < QTY  AND   SO_ORDER_DT.STATUS = 'A'

     INTO :ORDER_NO, :ORDER_DATE,:REF_NO,:REF_DATE, :ITEM_CODE, :CUST_CODE, :LINE_NO, :UOM,
          :UNIT_COST, :TOTAL_AMT, :QTY
   DO
      INSERT INTO SO_ORDER_REVISION_DT (ORDER_NO,ORDER_DATE,REF_NO,REF_DATE,ITEM_CODE,CUST_CODE,
             DOC_DATE,DOC_NO,LINE_NO,UOM,UNIT_COST,TOTAL_AMT,NEW_ORDER_FLAG,QTY)
      VALUES (:ORDER_NO,:ORDER_DATE,:REF_NO,:REF_DATE,:ITEM_CODE,:CUST_CODE,:VDOC_DATE,:VDOC_NO,
              :LINE_NO,:UOM,:UNIT_COST,:TOTAL_AMT,'N',:QTY);
   SUSPEND;
END^


ALTER PROCEDURE SO_CUSTOMERS_UPDATE
AS
declare variable NAME VARCHAR(60);
  declare variable ADDRESS1 VARCHAR(60);
  declare variable ADDRESS2 VARCHAR(60);
  declare variable ADDRESS3 VARCHAR(60);
  declare variable TELEPHONE VARCHAR(30);
  declare variable FAX_NO VARCHAR(30);
  declare variable TAX_CD VARCHAR(2);
  declare variable POSTCODE VARCHAR(10);
  declare variable PROVINCE VARCHAR(30);
  declare variable DEBTOR_ACCT VARCHAR(10);

BEGIN
  FOR SELECT NAME,ADDRESS1,ADDRESS2,ADDRESS3,DEBTOR_ACCT,
             TELPHONE,FAX_NO,TAX_CD,POSTCODE,PROVINCE
      FROM AR_DEBTOR
      INTO :NAME,:ADDRESS1,:ADDRESS2,:ADDRESS3,:DEBTOR_ACCT,
           :TELEPHONE,:FAX_NO,:TAX_CD,:POSTCODE,:PROVINCE

  DO
     BEGIN
        
          UPDATE SO_CUSTOMERS
          SET ADDRESS1 = :ADDRESS1,
              ADDRESS2 = :ADDRESS2,
              ADDRESS3 = :ADDRESS3,
              TELEPHONE = :TELEPHONE,
              FAX_NO = :FAX_NO,
              TAX_CD = :TAX_CD,
              POSTCODE = :POSTCODE,
              PROVINCE = :PROVINCE
          WHERE DEBTOR_ACCT = :DEBTOR_ACCT;
     END
END^


ALTER PROCEDURE SO_SALES_ITEM_REQ_SHEET_I
AS
declare variable ITEM_CODE VARCHAR(15);
declare variable CUST_CODE VARCHAR(10);
declare variable UOM_CD VARCHAR(4);
declare variable    MIN_FLOAT_POINT1 SMALLINT;
declare variable    MIN_FLOAT_POINT2 SMALLINT;
declare variable    MIN_FLOAT_POINT3 SMALLINT;
declare variable    MIN_FLOAT_POINT4 SMALLINT;
declare variable    MIN_FLOAT_POINT5 SMALLINT;
declare variable    MIN_FLOAT_POINT6 SMALLINT;
declare variable    MIN_FLOAT_POINT7 SMALLINT;
declare variable    MIN_FLOAT_POINT8 SMALLINT;
declare variable    MIN_FLOAT_POINT9 SMALLINT;
declare variable    MIN_FLOAT_POINT10 SMALLINT;
declare variable    MIN_FLOAT_POINT11 SMALLINT;
declare variable    MIN_FLOAT_POINT12 SMALLINT;
declare variable    MIN_FLOAT_POINT13 SMALLINT;
declare variable    MAX_FLOAT_POINT1 SMALLINT;
declare variable    MAX_FLOAT_POINT2 SMALLINT;
declare variable    MAX_FLOAT_POINT3 SMALLINT;
declare variable    MAX_FLOAT_POINT4 SMALLINT;
declare variable    MAX_FLOAT_POINT5 SMALLINT;
declare variable    MAX_FLOAT_POINT6 SMALLINT;
declare variable    MAX_FLOAT_POINT7 SMALLINT;
declare variable    MAX_FLOAT_POINT8 SMALLINT;
declare variable    MAX_FLOAT_POINT9 SMALLINT;
declare variable    MAX_FLOAT_POINT10 SMALLINT;
declare variable    MAX_FLOAT_POINT11 SMALLINT;
declare variable    MAX_FLOAT_POINT12 SMALLINT;
declare variable    MAX_FLOAT_POINT13 SMALLINT;
declare variable    MIN_MASK1 VARCHAR(30);
declare variable    MIN_MASK2 VARCHAR(30);
declare variable    MIN_MASK3 VARCHAR(30);
declare variable    MIN_MASK4 VARCHAR(30);
declare variable    MIN_MASK5 VARCHAR(30);
declare variable    MIN_MASK6 VARCHAR(30);
declare variable    MIN_MASK7 VARCHAR(30);
declare variable    MIN_MASK8 VARCHAR(30);
declare variable    MIN_MASK9 VARCHAR(30);
declare variable    MIN_MASK10 VARCHAR(30);
declare variable    MIN_MASK11 VARCHAR(30);
declare variable    MIN_MASK12 VARCHAR(30);
declare variable    MIN_MASK13 VARCHAR(30);
declare variable    MAX_MASK1 VARCHAR(30);
declare variable    MAX_MASK2 VARCHAR(30);
declare variable    MAX_MASK3 VARCHAR(30);
declare variable    MAX_MASK4 VARCHAR(30);
declare variable    MAX_MASK5 VARCHAR(30);
declare variable    MAX_MASK6 VARCHAR(30);
declare variable    MAX_MASK7 VARCHAR(30);
declare variable    MAX_MASK8 VARCHAR(30);
declare variable    MAX_MASK9 VARCHAR(30);
declare variable    MAX_MASK10 VARCHAR(30);
declare variable    MAX_MASK11 VARCHAR(30);
declare variable    MAX_MASK12 VARCHAR(30);
declare variable    MAX_MASK13 VARCHAR(30);

BEGIN
   FOR SELECT
   ITEM_CODE ,
   CUST_CODE,
   UOM_CD,
   MIN_FLOAT_POINT1,
   MIN_FLOAT_POINT2,
   MIN_FLOAT_POINT3,
   MIN_FLOAT_POINT4,
   MIN_FLOAT_POINT5,
   MIN_FLOAT_POINT6,
   MIN_FLOAT_POINT7,
   MIN_FLOAT_POINT8,
   MIN_FLOAT_POINT9,
   MIN_FLOAT_POINT10,
   MIN_FLOAT_POINT11,
   MIN_FLOAT_POINT12,
   MIN_FLOAT_POINT13,
   MAX_FLOAT_POINT1,
   MAX_FLOAT_POINT2,
   MAX_FLOAT_POINT3,
   MAX_FLOAT_POINT4,
   MAX_FLOAT_POINT5,
   MAX_FLOAT_POINT6,
   MAX_FLOAT_POINT7,
   MAX_FLOAT_POINT8,
   MAX_FLOAT_POINT9,
   MAX_FLOAT_POINT10,
   MAX_FLOAT_POINT11,
   MAX_FLOAT_POINT12,
   MAX_FLOAT_POINT13,
   MIN_MASK1,MIN_MASK2,
   MIN_MASK3,MIN_MASK4,
   MIN_MASK5,MIN_MASK6,
   MIN_MASK7,MIN_MASK8,
   MIN_MASK9,MIN_MASK10,
   MIN_MASK11,
   MIN_MASK12,
   MIN_MASK13,
   MAX_MASK1,
   MAX_MASK2,
   MAX_MASK3,
   MAX_MASK4,
   MAX_MASK5,
   MAX_MASK6,
   MAX_MASK7,
   MAX_MASK8,
   MAX_MASK9,
   MAX_MASK10,
   MAX_MASK11,
   MAX_MASK12,
   MAX_MASK13
   FROM SO_SALES_ITEM_REQ_SHEET_TEMP
   INTO ITEM_CODE,:CUST_CODE,:UOM_CD,:MIN_FLOAT_POINT1,:MIN_FLOAT_POINT2,:MIN_FLOAT_POINT3,
   :MIN_FLOAT_POINT4,:MIN_FLOAT_POINT5,:MIN_FLOAT_POINT6,
   :MIN_FLOAT_POINT7,:MIN_FLOAT_POINT8,:MIN_FLOAT_POINT9,
   :MIN_FLOAT_POINT10,:MIN_FLOAT_POINT11,:MIN_FLOAT_POINT12,
   :MIN_FLOAT_POINT13,:MAX_FLOAT_POINT1,:MAX_FLOAT_POINT2,
   :MAX_FLOAT_POINT3,:MAX_FLOAT_POINT4,:MAX_FLOAT_POINT5,
   :MAX_FLOAT_POINT6,:MAX_FLOAT_POINT7,:MAX_FLOAT_POINT8,
   :MAX_FLOAT_POINT9,:MAX_FLOAT_POINT10,:MAX_FLOAT_POINT11,
   :MAX_FLOAT_POINT12,:MAX_FLOAT_POINT13,
   :MIN_MASK1,:MIN_MASK2,:MIN_MASK3,:MIN_MASK4,:MIN_MASK5,
   :MIN_MASK6,:MIN_MASK7,:MIN_MASK8,:MIN_MASK9,:MIN_MASK10,
   :MIN_MASK11,:MIN_MASK12,:MIN_MASK13,:MAX_MASK1,:MAX_MASK2,
   :MAX_MASK3,:MAX_MASK4,:MAX_MASK5,:MAX_MASK6,:MAX_MASK7,
   :MAX_MASK8,:MAX_MASK9,:MAX_MASK10,:MAX_MASK11,:MAX_MASK12,:MAX_MASK13
  DO
  BEGIN
   UPDATE SO_SALES_ITEM_REQ_SHEET
   SET MIN_FLOAT_POINT1 = :MAX_FLOAT_POINT1,
   MIN_FLOAT_POINT2= :MAX_FLOAT_POINT2,
   MIN_FLOAT_POINT3= :MAX_FLOAT_POINT3,
   MIN_FLOAT_POINT4= :MAX_FLOAT_POINT4,
   MIN_FLOAT_POINT5= :MAX_FLOAT_POINT5,
   MIN_FLOAT_POINT6= :MAX_FLOAT_POINT6,
   MIN_FLOAT_POINT7= :MAX_FLOAT_POINT7,
   MIN_FLOAT_POINT8= :MAX_FLOAT_POINT8,
   MIN_FLOAT_POINT9= :MAX_FLOAT_POINT9,
   MIN_FLOAT_POINT10= :MAX_FLOAT_POINT10,
   MIN_FLOAT_POINT11= :MAX_FLOAT_POINT11,
   MIN_FLOAT_POINT12= :MAX_FLOAT_POINT12,
   MIN_FLOAT_POINT13= :MAX_FLOAT_POINT13,
   MAX_FLOAT_POINT1= :MIN_FLOAT_POINT1,
   MAX_FLOAT_POINT2= :MIN_FLOAT_POINT2,
   MAX_FLOAT_POINT3= :MIN_FLOAT_POINT3,
   MAX_FLOAT_POINT4= :MIN_FLOAT_POINT4,
   MAX_FLOAT_POINT5= :MIN_FLOAT_POINT5,
   MAX_FLOAT_POINT6= :MIN_FLOAT_POINT6,
   MAX_FLOAT_POINT7= :MIN_FLOAT_POINT7,
   MAX_FLOAT_POINT8= :MIN_FLOAT_POINT8,
   MAX_FLOAT_POINT9= :MIN_FLOAT_POINT9,
   MAX_FLOAT_POINT10= :MIN_FLOAT_POINT10,
   MAX_FLOAT_POINT11= :MIN_FLOAT_POINT11,
   MAX_FLOAT_POINT12= :MIN_FLOAT_POINT12,
   MAX_FLOAT_POINT13= :MIN_FLOAT_POINT13,
   MIN_MASK1= :MAX_MASK1,
   MIN_MASK2= :MAX_MASK2,
   MIN_MASK3= :MAX_MASK3,
   MIN_MASK4=:MAX_MASK4,
   MIN_MASK5=:MAX_MASK5,
   MIN_MASK6=:MAX_MASK6,
   MIN_MASK7=:MAX_MASK7,
   MIN_MASK8=:MAX_MASK8,
   MIN_MASK9=:MAX_MASK9,
   MIN_MASK10=:MAX_MASK10,
   MIN_MASK11=:MAX_MASK11,
   MIN_MASK12=:MAX_MASK12,
   MIN_MASK13=:MAX_MASK13,
   MAX_MASK1=:MIN_MASK1,
   MAX_MASK2=:MAX_MASK2,
   MAX_MASK3=:MAX_MASK3,
   MAX_MASK4=:MAX_MASK4,
   MAX_MASK5=:MAX_MASK5,
   MAX_MASK6=:MAX_MASK6,
   MAX_MASK7=:MAX_MASK7,
   MAX_MASK8=:MAX_MASK8,
   MAX_MASK9=:MAX_MASK9,
   MAX_MASK10=:MAX_MASK10,
   MAX_MASK11=:MAX_MASK11,
   MAX_MASK12=:MAX_MASK12,
   MAX_MASK13=:MAX_MASK13
   WHERE ITEM_CODE =:ITEM_CODE
   AND CUST_CODE =:CUST_CODE
   AND UOM_CD =:UOM_CD;
  END
 SUSPEND;

END^


ALTER PROCEDURE X_AP_POST_PAYMENT (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AUPDATE_USER VARCHAR(10))
AS
begin
 Insert into  ap_ledger (
    doc_no,       doc_date,     ref_no,  ref_date,  descs,
    fmonth,    creditor_acct,    fyear,
    currency_code,    creditor_type,      currency_rate,
    mbase_amt,    mtax_amt,    mdoc_amt,
    fbase_amt,    ftax_amt,    fdoc_amt,
    malloc_amt,    falloc_amt,    mbal_amt,
    tax_inv_no,    trx_type,    dr_cr_mode,
    fbal_amt,    class,    bank_cd,
    update_user,    update_date   )
   select h.doc_no,     h.doc_date,       d.invoice_no,  d.invoice_date,h.descs,
   extract(month from  h.doc_date),h.creditor_acct, extract(year from h.doc_date),
h.currency_code , cr.creditor_type  ,1,
base_amount, tax_amount, total_amount,
base_amount, tax_amount, total_amount,
0,0,0 ,
d.invoice_no,h.trx_type,'C',
BASE_AMOUNT,'P',H.bank_code,
:aupdate_user,current_timestamp

      from ap_payment_dt  d , ap_payment_hd h   , ap_creditor cr
      where h.doc_no = d.doc_no
      and h.doc_date = d.doc_date
      and h.creditor_acct = d.creditor_acct
      and h.creditor_acct = cr.creditor_acct
      AND H.DOC_NO =:adoc_no
      AND H.DOC_DATE =:adoc_date
      AND H.STATUS ='N'   ;


      update ap_payment_hd 
      SET STATUS ='X'
      WHERE   DOC_NO =:adoc_no
      AND DOC_DATE =:adoc_date  ;
   --   and   h.doc_date >='9/1/2013'
     --and h.doc_date <='9/30/2013'

  suspend;
end^


ALTER PROCEDURE X_AR_POST_CREDIT_NOTE (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    ADEBTOR VARCHAR(10),
    AUPDATE_USER VARCHAR(10),
    AMODE VARCHAR(2))
AS
DECLARE VARIABLE CURRENCY_CODE VARCHAR(10);
DECLARE VARIABLE DEBTOR_TYPE VARCHAR(10);
DECLARE VARIABLE FYEAR INTEGER;
DECLARE VARIABLE FOUND_RECORD INTEGER;
DECLARE VARIABLE FMONTH INTEGER;
DECLARE VARIABLE TAX DOUBLE PRECISION;
DECLARE VARIABLE AMOUNT DOUBLE PRECISION;
DECLARE VARIABLE GRAND_TOTAL DOUBLE PRECISION;
DECLARE VARIABLE INVOICE_NO VARCHAR(15);
DECLARE VARIABLE INVOICE_DATE TIMESTAMP;
DECLARE VARIABLE DESCS VARCHAR(60);
DECLARE VARIABLE TRX_TYPE VARCHAR(2);
DECLARE VARIABLE REQUIRE_REFERENCE VARCHAR(1);
DECLARE VARIABLE ORDER_NO VARCHAR(15);
DECLARE VARIABLE ORDER_DATE TIMESTAMP;
DECLARE VARIABLE CLASS VARCHAR(1);
DECLARE VARIABLE DRCR VARCHAR(1);

BEGIN
  /* AR INVOICE POST ACTION
     ACTION INSERT DATA INOT AL_LEDGER AND UPDATE STATUS IN AR_INVOICE_HEADER
   */

    select count(*)
   FROM AR_CREDIT_NOTE_DT d ,ar_CREDIT_NOTE_HD h
  WHERE  d.debtor_acct = h.debtor_acct
  and d.doc_no = h.doc_no
  and d.doc_date = h.doc_date
  and  h.DEBTOR_ACCT = :aDEBTOR
  and h.DOC_NO    = :aDOC_NO
  and h.DOC_DATE  = :aDOC_DATE
  and h.status ='N'
  into :FOUND_RECORD  ;
  if (found_record =0) then
  begin
    exception e_no_row;
    exit;
  end
  FYEAR = extract(YEAR FROM aDOC_DATE);
  FMONTH = EXTRACT(MONTH FROM aDOC_DATE);

  SELECT   DEBTOR_TYPE ,CURRENCY_CODE
  FROM AR_DEBTOR
  WHERE DEBTOR_ACCT = :aDEBTOR
  INTO  :DEBTOR_TYPE,:CURRENCY_CODE ;
  --17 Nov,2010 get mode from transaction type
  select max(mode) from transactiontype
  where trx_type =:amode
  into :DRCR;
  class = :DRCR;
  FOR SELECT SUM(D.variant_amount),SUM(D.tax_amount),SUM(D.total_amount),COUNT(h.DEBTOR_ACCT) ,
  D.invoice_no,D.INVOICE_DATE ,max(h.descs) ,MAX(H.trx_type),MAX(D.invoice_no),MAX(D.INVOICE_DATE)
  FROM AR_CREDIT_NOTE_DT d ,ar_CREDIT_NOTE_HD h
  WHERE  d.debtor_acct = h.debtor_acct
  and d.doc_no = h.doc_no
  and d.doc_date = h.doc_date
  and  h.DEBTOR_ACCT = :aDEBTOR
  and h.DOC_NO    = :aDOC_NO
  and h.DOC_DATE  = :aDOC_DATE
  and h.status ='N'
  GROUP BY   h.DEBTOR_ACCT,h.DOC_NO,h.DOC_DATE   ,d.INVOICE_NO,d.INVOICE_DATE
  INTO :AMOUNT,:TAX,:GRAND_TOTAL,:FOUND_RECORD,:INVOICE_NO,:INVOICE_date ,:descs  ,:TRX_TYPE   ,
  :ORDER_NO ,:ORDER_DATE
  do
  begin
    IF (DRCR ='C') THEN
    BEGIN
      AMOUNT = (:AMOUNT*-1) ;
      TAX = (:TAX *-1);
      GRAND_TOTAL =(:GRAND_TOTAL*-1)  ;
    END
    INSERT INTO AR_LEDGER (
    DEBT_ACCT,DOC_NO, DOC_DATE,DEBTOR_ACCT,REF_NO,ref_date,FMONTH,DEBTOR_TYPE,TRX_TYPE,FYEAR,CURRENCY_CODE,CURRENCY_RATE ,MBASE_AMT,
    MTAX_AMT, MDOC_AMT,FBASE_AMT,FTAX_AMT, FDOC_AMT,MALLOC_AMT,FALLOC_AMT,MBAL_AMT, TAX_INV_NO ,CLASS,DR_CR_MODE,FBAL_AMT,
    BANK_CD, UPDATE_USER,UPDATE_DATE,DESCS)
    VALUES(
    :aDEBTOR,
    :aDOC_NO,
    :aDOC_DATE,
    :aDEBTOR,
    :INVOICE_no,
    :INVOICE_date,
    :FMONTH,
    :DEBTOR_TYPE,
    :TRX_TYPE,
    :FYEAR,
    :CURRENCY_CODE,
    0 ,
    :AMOUNT,
    :TAX,
    :GRAND_TOTAL,
    :AMOUNT,
    :TAX,
    :GRAND_TOTAL,
    0,
    0,
    :GRAND_TOTAL,
    :aDOC_NO,
    :CLASS,
    :DRCR,
    :GRAND_TOTAL,
    'NULL',
   :aupdate_user,
    CURRENT_TIMESTAMP,
    :descs
    );


     UPDATE AR_LEDGER LG
    SET  LG.malloc_amt = malloc_amt - :AMOUNT,
         LG.falloc_amt = falloc_amt -:AMOUNT ,
         LG.fbal_amt = FBAL_AMT + :AMOUNT  ,
         LG.mbal_amt = mBAL_AMT + :AMOUNT
    WHERE DOC_NO  =:INVOICE_NO
    AND DOC_DATE =:INVOICE_DATE ;

    --17 NOV,2010 Reverse  amount from
    UPDATE ar_invoice_dt
    SET BASE_AMt = BASE_AMT + :AMOUNT ,
    tax_AMT = tax_amt +:tax,
    DOC_AMT = DOC_amt + :GRAND_TOTAL
    WHERE DOC_NO  =:INVOICE_NO
    AND DOC_DATE =:INVOICE_DATE ;

    UPDATE ar_credit_note_hd  SET STATUS = 'X'
    WHERE
    DEBTOR_ACCT = :aDEBTOR AND
    DOC_NO    = :aDOC_NO AND
    DOC_DATE  = :aDOC_DATE  and
    STATUS ='N' ;



   END

   suspend;


end^


ALTER PROCEDURE X_AR_POST_INVOICE (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    ADEBTOR VARCHAR(10),
    AUPDATE_USER VARCHAR(10))
AS
DECLARE VARIABLE CURRENCY_CODE VARCHAR(10);
DECLARE VARIABLE DEBTOR_TYPE VARCHAR(10);
DECLARE VARIABLE FYEAR INTEGER;
DECLARE VARIABLE FOUND_RECORD INTEGER;
DECLARE VARIABLE FMONTH INTEGER;
DECLARE VARIABLE TAX DOUBLE PRECISION;
DECLARE VARIABLE AMOUNT DOUBLE PRECISION;
DECLARE VARIABLE GRAND_TOTAL DOUBLE PRECISION;
DECLARE VARIABLE DELIVERY_NO VARCHAR(15);
DECLARE VARIABLE DELIVERY_DATE TIMESTAMP;
DECLARE VARIABLE DESCS VARCHAR(60);
DECLARE VARIABLE TRX_TYPE VARCHAR(2);
DECLARE VARIABLE REQUIRE_REFERENCE VARCHAR(1);
DECLARE VARIABLE ORDER_NO VARCHAR(15);
DECLARE VARIABLE ORDER_DATE TIMESTAMP;
BEGIN
  /* AR INVOICE POST ACTION
     ACTION INSERT DATA INOT AL_LEDGER AND UPDATE STATUS IN AR_INVOICE_HEADER
   */
  FYEAR = extract(YEAR FROM aDOC_DATE);
  FMONTH = EXTRACT(MONTH FROM aDOC_DATE);

  SELECT   DEBTOR_TYPE ,CURRENCY_CODE
  FROM AR_DEBTOR
  WHERE DEBTOR_ACCT = :aDEBTOR
  INTO  :DEBTOR_TYPE,:CURRENCY_CODE ;

  FOR SELECT SUM(BASE_AMT),SUM(TAX_AMT),SUM(DOC_AMT),COUNT(h.DEBTOR_ACCT) ,
  D.delivery_no,D.delivery_date ,max(h.descs) ,MAX(H.trx_type),MAX(D.order_no),MAX(D.order_date)
  FROM AR_INVOICE_DT d ,ar_invoice_hd   h
  WHERE  d.debtor_acct = h.debtor_acct
  and d.doc_no = h.doc_no
  and d.doc_date = h.doc_date
  and  h.DEBTOR_ACCT = :aDEBTOR
  and h.DOC_NO    = :aDOC_NO
  and h.DOC_DATE  = :aDOC_DATE
  GROUP BY   h.DEBTOR_ACCT,h.DOC_NO,h.DOC_DATE   ,d.delivery_no,d.delivery_date
  INTO :AMOUNT,:TAX,:GRAND_TOTAL,:FOUND_RECORD,:delivery_no,:delivery_date ,:descs  ,:TRX_TYPE   ,
  :ORDER_NO ,:ORDER_DATE
  do
  begin
    SELECT MAX(REQUIRE_REFERENCE)
    FROM TRANSACTIONTYPE
    WHERE TRX_TYPE =:TRX_TYPE
    INTO :REQUIRE_REFERENCE;
    if (REQUIRE_REFERENCE is null) then REQUIRE_REFERENCE ='X' ;
    INSERT INTO AR_LEDGER (
    DEBT_ACCT,DOC_NO, DOC_DATE,DEBTOR_ACCT,REF_NO,ref_date,FMONTH,DEBTOR_TYPE,TRX_TYPE,FYEAR,CURRENCY_CODE,CURRENCY_RATE ,MBASE_AMT,
    MTAX_AMT, MDOC_AMT,FBASE_AMT,FTAX_AMT, FDOC_AMT,MALLOC_AMT,FALLOC_AMT,MBAL_AMT, TAX_INV_NO ,CLASS,DR_CR_MODE,FBAL_AMT,
    BANK_CD, UPDATE_USER,UPDATE_DATE,DESCS)
    VALUES(
    :aDEBTOR,
    :aDOC_NO,
    :aDOC_DATE,
    :aDEBTOR,
    :delivery_no,
    :delivery_date,
    :FMONTH,
    :DEBTOR_TYPE,
    :TRX_TYPE,
    :FYEAR,
    :CURRENCY_CODE,
    0 ,
    :AMOUNT,
    :TAX,
    :GRAND_TOTAL,
    :AMOUNT,
    :TAX,
    :GRAND_TOTAL,
    0,
    0,
    :GRAND_TOTAL,
    :aDOC_NO,
    'I',
    'C',
    :GRAND_TOTAL,
    'NULL',
   :aupdate_user,
    CURRENT_TIMESTAMP,
    :descs
    );
     if (:REQUIRE_REFERENCE ='Y') then
     BEGIN
       update so_det_hd
       set invoice_matched ='Y'
       WHERE so_det_hd.delivery_no=:delivery_no;
     END ELSE           /*UPDATE SO ORDER FOR INDIRECT INVICE*/
     BEGIN
        UPDATE SO_ORDER_HD
        SET STATUS ='O'
        WHERE ORDER_NO =:ORDER_NO
        AND ORDER_DATE =:ORDER_DATE
        AND STATUS <>'C';
     END


    UPDATE AR_INVOICE_HD   SET STATUS = 'X'
    WHERE
    DEBTOR_ACCT = :aDEBTOR AND
    DOC_NO    = :aDOC_NO AND
    DOC_DATE  = :aDOC_DATE  ;

   END



END^


ALTER PROCEDURE X_AR_POST_RECEIPT (
    ADEBTOR VARCHAR(10),
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AUPDATE_USER VARCHAR(10))
AS
declare variable TRX_AMOUNT double precision;
declare variable AMOUNT double precision;
declare variable TAX_AMOUNT double precision;
declare variable BASE_AMOUNT double precision;
declare variable TRX_TYPE varchar(2);
declare variable INV_NO varchar(15);
declare variable INV_DATE timestamp;
declare variable FMONTH integer;
declare variable FYEAR integer;
declare variable FOUND_RECORD smallint;
declare variable DEBTOR_TYPE varchar(10);
declare variable CURRENCY_CODE varchar(10);
declare variable CURRENCY_RATE float;
declare variable DESCS varchar(60);
declare variable BANK_CODE varchar(4);
BEGIN
  /* AR INVOICE POST ACTION
     ACTION INSERT DATA INOT AL_LEDGER AND UPDATE STATUS IN AR_INVOICE_HEADER
   */
  FYEAR = extract(YEAR FROM :ADOC_DATE);
  FMONTH = EXTRACT(MONTH FROM :ADOC_DATE);


 
  FOR SELECT SUM(DT.base_amount),
  SUM(DT.tax_amount),
  SUM(DT.trx_amount),
  COUNT(hD.DEBTOR_ACCT) ,
  DT.inv_no,
  DT.inv_date,
 max(hD.descs) ,MAX(HD.trx_type),
  MAX(HD.currency_code),
  max(hd.currency_rate),
  max(hd.bank_code)
  from ar_receipt_dt dt , ar_receipt_hd hd
  where hd.doc_no = dt.doc_no
  and hd.doc_date = dt.doc_date
  and hd.debtor_acct = dt.debtor_acct
  and hd.doc_no  =:adoc_no
  and hd.doc_date = :adoc_date
  and hd.debtor_acct = :adebtor
  and hD.status <>'X'
  GROUP BY  HD.DOC_NO,HD.DOC_DATE,DT.inv_no,DT.inv_date
   INTO :BASE_AMOUNT,:TAX_AMOUNT,:TRX_AMOUNT,:FOUND_RECORD,:INV_NO,:INV_DATE, :descs  ,:TRX_TYPE   ,
  :CURRENCY_CODE,:currency_rate,:bank_code
  DO
  BEGIN


  IF(:FOUND_RECORD > 0) THEN
  BEGIN
    
  SELECT   max(DEBTOR_TYPE)
  FROM AR_DEBTOR
  WHERE DEBTOR_ACCT = :aDEBTOR
  INTO  :DEBTOR_TYPE;

   INSERT INTO AR_LEDGER (
    DEBT_ACCT,DOC_NO, DOC_DATE,DEBTOR_ACCT,REF_NO,ref_date,FMONTH,
    DEBTOR_TYPE,TRX_TYPE,FYEAR,CURRENCY_CODE,CURRENCY_RATE ,MBASE_AMT,
    MTAX_AMT, MDOC_AMT,FBASE_AMT,FTAX_AMT, FDOC_AMT,MALLOC_AMT,FALLOC_AMT,MBAL_AMT, TAX_INV_NO ,CLASS,DR_CR_MODE,FBAL_AMT,
    BANK_CD, UPDATE_USER,UPDATE_DATE,DESCS)
    VALUES(
    :aDEBTOR,
    :aDOC_NO,
    :aDOC_DATE,
    :aDEBTOR,
    :INV_NO,
    :INV_DATE,
    :FMONTH,
    :DEBTOR_TYPE,
    :TRX_TYPE,
    :FYEAR,
    :CURRENCY_CODE,
    :CURRENCY_RATE ,
    :BASE_AMOUNT,
    :TAX_AMOUNT,
    :TRX_AMOUNT,
    :TRX_AMOUNT,
    :TAX_AMOUNT,
    :TRX_AMOUNT,
    0,
    0,
    :TRX_AMOUNT,
    :aDOC_NO,
    'R',
    'D',
    :TRX_AMOUNT,
    'NULL',
   :aupdate_user,
    CURRENT_TIMESTAMP,
    :descs

    );

    UPDATE AR_LEDGER LG
    SET  LG.malloc_amt = malloc_amt + :TRX_AMOUNT,
         LG.falloc_amt = falloc_amt +:TRX_AMOUNT ,
         LG.fbal_amt = FBAL_AMT - :TRX_AMOUNT  ,
         LG.mbal_amt = mBAL_AMT - :TRX_AMOUNT
    WHERE DOC_NO  =:INV_NO
    AND DOC_DATE =:INV_DATE ;
    --UPDATE MATCH INVOICE STATUS

    --UPDATE CN,DN TRANSACTION  17 NOV,2010 to filter out from AR DEBTOR LEDGER
    
    UPDATE AR_LEDGER LG
    SET  LG.malloc_amt = malloc_amt + :TRX_AMOUNT,
         LG.falloc_amt = falloc_amt +:TRX_AMOUNT

    WHERE REF_NO  =:INV_NO
    AND REF_DATE =:INV_DATE ;

    update ar_invoice_hd
    set ar_invoice_hd.receipt_status ='Y'
    WHERE DOC_NO  =:INV_NO
    AND DOC_date = :INV_DATE
    AND ar_invoice_hd.receipt_status ='N';

    UPDATE AR_RECEIPT_HD  SET STATUS = 'X'
    WHERE
        DOC_NO  = :adoc_no
        and doc_date =:adoc_date
        and debtor_acct =:adebtor
    AND STATUS <>'X'     ;
  END
  end /*FOR*/
  suspend;

END^


ALTER PROCEDURE X_AUTO_RESET_STOCK_RESERVED (
    AYEAR SMALLINT,
    AMONTH SMALLINT)
AS
declare variable lot_cd varchar(15);
declare variable purchase_date timestamp;
declare variable ref_no varchar(15);
declare variable ref_date timestamp;

declare variable current_reserved_qty float;

begin


FOR SELECT
        LOT_CD,PURCHASE_DATE,REF_NO,REF_DATE
        from ic_mat_stk_dt_link
        where reserved_qty >0
        and extract(year from purchase_date) =:ayear
        and extract(month from purchase_date ) =:amonth
        
        into :lot_cd , :purchase_date , :ref_no ,:ref_date

DO
BEGIN

        select sum(dt.qty)
        from pl_req_dt dt , pl_Req_hd hd
        where hd.doc_no = dt.doc_no
        and hd.doc_date = dt.doc_date
        and hd.status ='N'
        and dt.lot_no =:lot_cd
        and dt.purchase_date =:purchase_date
        and dt.ref_no =:ref_no
        and dt.ref_date =:ref_date
        into :current_reserved_qty;

        if (:current_reserved_qty is null) then
        begin
          current_reserved_qty = 0;

          update  ic_mat_stk_dt_link
          set reserved_qty =0
          where ref_no = :ref_no
          and ref_date =:ref_date
          and lot_cd =:lot_cd
          and purchase_date =:purchase_date;

          delete from ic_stock_reserved
          where ref_no = :ref_no
          and ref_date =:ref_date
          and lot_cd =:lot_cd
          and purchase_date =:purchase_date;
        end

     suspend;

END






  suspend;
end^


ALTER PROCEDURE X_CHECK_UNKNOW_LOT
RETURNS (
    STOCK_CODE VARCHAR(15),
    LOT_CD VARCHAR(15),
    PURCHASE_DATE TIMESTAMP,
    UNKNOW VARCHAR(1))
AS
DECLARE ROWSNUM SMALLINT;
BEGIN
  ROWSNUM=0;
  FOR SELECT DISTINCT STOCK_CD , LOT_CD ,PURCHASE_DATE
  FROM ic_stockcard
  WHERE MODE ='I'
  AND PURCHASE_DATE >'01/01/1900'
  INTO :stock_code,:lot_cd,:purchase_date

  DO
  BEGIN
  UNKNOW ='N';
     SELECT COUNT(*)
     FROM ic_mat_stk_dt_link
     WHERE STOCK_CD =:STOCK_CODE
     AND LOT_CD =:lot_cd
     AND PURCHASE_DATE =:purchase_date
     INTO :ROWSNUM   ;
     IF (ROWSNUM =0)
     THEN
     BEGIN
        UNKNOW ='Y';
     END
     SUSPEND;
  END


END^


ALTER PROCEDURE X_CLEAN_ORDERREVISION (
    ADATE TIMESTAMP)
AS
                     BEGIN
                        DELETE FROM SO_ORDER_REVISION_HD
                        WHERE DOC_DATE < :ADATE - 30;
                        SUSPEND;
                     END^


ALTER PROCEDURE X_CLOSED_MELT (
    MELT_NO VARCHAR(10))
AS
declare variable FNG_UNIT_COST float;
declare variable CHARGED_QTY float;
declare variable CHARGED_TOTAL_COST float;
declare variable RECOVERY_QTY float;
declare variable ROW1 smallint;
declare variable ROW2 smallint;
declare variable CMONTH smallint;
declare variable CYEAR smallint;
begin
  fng_unit_cost =0;
  begin
      select count(*)
      from pl_req_hd h , pl_req_dt d
      where h.doc_no = d.doc_no
      and h.doc_date = d.doc_date
      and h.melt_no = :melt_no
      and h.status ='N'
      and h.IC_MODE ='O'
      into :row1;
      if (row1 > 0) then
      begin
          select  sum(qty),SUM(D.QTY*D.UNIT_COST),
                  max(extract(year from h.doc_date)),
                  max(extract(month from h.doc_date))
          from pl_req_hd h , pl_req_dt d
          where h.doc_no = d.doc_no
          and h.doc_date = d.doc_date
          and h.melt_no = :melt_no
          and h.status ='X'
          and h.IC_MODE ='O'
          into :charged_qty,:charged_total_cost,:cyear,:cmonth;
     end
     else
     begin
        charged_qty=0;
        charged_total_cost=0;
        cyear=extract(year from current_timestamp) ;
        cmonth=extract(month from current_timestamp) ;
     end
     end
     begin
     select count(*)
     from pl_fn_receive_hd h, pl_fn_receive_dt d
     where h.doc_no = d.doc_no
     and h.doc_date = d.doc_date
     and h.melt_no = d.melt_no
     and h.melt_no = :melt_no
     and h.status ='N'
     into :row2;
  if (row2 >0) then
  begin
         select sum(d.qty)
         from pl_fn_receive_hd h, pl_fn_receive_dt d
         where h.doc_no = d.doc_no
         and h.doc_date = d.doc_date
         and h.melt_no = d.melt_no
         and h.melt_no = :melt_no
         and h.status ='X'
         into :recovery_qty;
  END
  /**calculate new finished good cost*/
  if ((recovery_qty > 0) and (charged_total_cost > 0)) then
  begin
      fng_unit_cost = charged_total_cost /recovery_qty;
      /** update section **/
       begin
         update so_ledger
         set  unit_cost = :fng_unit_cost,
              total_amt = qty*:fng_unit_cost
         where melt_no = :melt_no;
       end
       begin
         update so_sales_item_stock
         set  unit_cost = :fng_unit_cost,
              total_cost = onhand_qty*:fng_unit_cost
         where melt_no = :melt_no;
       end
       /*update remelt item section*/
       begin
         update ic_mat_stk_dt
         set last_purchase_price = :fng_unit_cost,
             unit_cost = :fng_unit_cost,
             total_cost = :fng_unit_cost*onhand_qty
         where lot_cd = :melt_no;
       end
       begin
         update ic_stockcard
         set unit_cost = :fng_unit_cost,
             total_cost = :fng_unit_cost*qty
         where melt_no = :melt_no
               and lot_cd = :melt_no;
       end
       begin
         update po_order_dt
         set unit_cost = :fng_unit_cost,
             total_amt = :fng_unit_cost*qty
         where item_code = :melt_no;
       end
    END
      /**  insert into pl_closed_melt_log  **/
     begin
         insert into pl_closed_melt_log(melt_no,cmonth,cyear,update_user,update_date,unit_cost)
         values (:melt_no,:cmonth,:cyear,'BIT',current_timestamp,:fng_unit_cost);
     end

      /**  update pl_req_hd.status ='O' , update pl_fn_recieve_hd ='O' **/
       begin
         update pl_req_hd
         set status = 'O'
         where melt_no = :melt_no;
       end
       begin
         update pl_fn_receive_hd
         set status = 'O'
         where melt_no =:melt_no;
       end
       begin
         update pl_pro_plan_dt
         set status ='X'
         where melt_no =:melt_no;
       end
       begin
         update pl_rawmat_sheet_hd
         set status ='X'
         where melt_no =:melt_no;
       end

  end
  /*else
  begin
    /**could create exception to be proper message*/
      --exception e_amt_error;
  --end



  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_GET_DISPATCH (
    AREVISE_NO VARCHAR(15),
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AFROM_DATE TIMESTAMP,
    ATO_DATE TIMESTAMP)
AS
DECLARE VARIABLE DELIVERY_DATE TIMESTAMP;
DECLARE VARIABLE ORDER_NO VARCHAR(15);
DECLARE VARIABLE CUST_CODE VARCHAR(10);
DECLARE VARIABLE ORDER_DATE TIMESTAMP;
DECLARE VARIABLE ITEM_CODE VARCHAR(15);
DECLARE VARIABLE DELIVERY_QTY FLOAT;
DECLARE VARIABLE LINE_NO SMALLINT;
DECLARE VARIABLE UOM_CD VARCHAR(4);
DECLARE VARIABLE ITEM_DESCS VARCHAR(60);
DECLARE VARIABLE MELT_NO VARCHAR(10);
DECLARE VARIABLE REMARK VARCHAR(255);
DECLARE VARIABLE MELT_TEXT VARCHAR(150);
declare variable ORDER_QTY FLOAT;
DECLARE VARIABLE NEW_ORDER VARCHAR(1);
BEGIN

    for SELECT ordersch.CUST_CODE,
    ordersch.ORDER_NO,
    ordersch.ORDER_DATE,
    ordersch.ITEM_CODE,
    ordersch.LINE_NO,
    ordersch.SCHEDULE_DATE,
    ordersch.SCHEDULE_QTY,
    ordersch.REMARKS,
    ordersch.UOM ,
    orderdt.item_descs   ,
    orderdt.qty
    FROM SO_ORDER_SCH_DT  ordersch , so_order_dt orderdt
    where ordersch.cust_code = orderdt.cust_code
    and
      ordersch.order_no = orderdt.order_no
    and
     ordersch.order_date = orderdt.order_date
    and
     ordersch.item_code = orderdt.item_code
     and
     ordersch.uom = orderdt.uom
     and

     ordersch.schedule_date >=:afrom_date
          AND
     ordersch.schedule_date <=:ATO_DATE
     ORDER BY
     ordersch.schedule_date
     into :cust_code,:order_no,:order_date,:item_code,
     :line_no,:delivery_date,:delivery_qty,:remark,:uom_cd,:item_descs ,:order_qty
     do
     begin
           MELT_TEXT =''; /**RESET MELT TEXT FOR EACH ORDER*/
           melt_no ='';
          select max(so_order_revision_dt.new_order_flag  )
          from so_order_revision_dt
          where order_no =:order_no
          and order_date =:order_date
          and cust_code =:cust_code
          and item_code =:item_code
          and doc_no =:arevise_no
          into    :new_order  ;
          if (new_order='Y') then
          BEGIN
            REMARK =REMARK || 'NEW ORDER';
          END

             FOR SELECT MELT_NO
             FROM pl_pro_plan_dt
             where order_no =:order_no
             and order_date =:order_date
             and item_code =:item_code
             and cust_code =:cust_code
             ORDER BY ITEM_CODE , MELT_NO
             INTO :MELT_NO
             DO
             BEGIN
               if (MELT_TEXT='') then
               BEGIN
                   MELT_TEXT =:MELT_NO   ;
               END
               ELSE
               BEGIN
                  MELT_TEXT =MELT_TEXT || ',' || :MELT_NO ;
               END
             END
             INSERT INTO PL_DISPATCH_DT
             (DELIVERY_DATE,
             ORDER_NO,ORDER_DATE,ITEM_CODE,UOM_CD,MELT_NO,LINE_NO,CUST_CODE,REMARKS,ORDER_QTY,DET_QTY,doc_no,doc_date,MELT_TEXT)
             values(:delivery_date,:order_no,:order_date,:item_code,:uom_cd,:MELT_NO,:LINE_NO,:CUST_CODE,:remark,:order_qty,:delivery_qty,:ADOC_NO,:ADOC_DATE,:MELT_TEXT) ;

     end


  SUSPEND;
END^


ALTER PROCEDURE X_GET_LAST_PURCHASE_PRICE (
    ASTOCK_CD VARCHAR(25),
    ALOT_CD VARCHAR(15),
    APURCHASE_DATE TIMESTAMP,
    AREF_NO VARCHAR(15),
    AREF_DATE TIMESTAMP)
RETURNS (
    RET_PRICE FLOAT)
AS
begin

  SELECT MAX(LAST_PURCHASE_PRICE)
  FROM ic_mat_stk_dt_link
  WHERE STOCK_CD = :astock_cd
  AND LOT_CD = :alot_cd
  AND PURCHASE_DATE = :apurchase_date
  AND REF_NO = :aref_no
  AND REF_DATE = :aref_date
  INTO :RET_PRICE;
  if (RET_PRICE IS NULL) THEN    RET_PRICE = 0;
  suspend;
end^


ALTER PROCEDURE X_GET_MELT_SUMMARY (
    FROM_MELT VARCHAR(10),
    TO_MELT VARCHAR(10))
AS
declare variable DOC_NO varchar(15);
declare variable PLAN_DOC varchar(15);
declare variable ITEM_CODE varchar(15);
declare variable STOCK_CODE varchar(15);
declare variable STOCK_DESCS varchar(60);
declare variable UOM_CD varchar(4);
declare variable GROUP_ID varchar(10);
declare variable GROUP_DESCS varchar(60);
declare variable LOT_CD varchar(15);
declare variable PURCHASE_DATE timestamp;
declare variable UNIT_COST float;
declare variable CHARGED_WEIGHT float;
declare variable ACTUAL_WEIGHT float;
declare variable REMELT_WEIGHT float;
declare variable SUM_CHARGED_COST float;
declare variable SUM_CHARGED_WEIGHT float;
declare variable SCHARGED_WEIGHT float;
declare variable SRECOVERY_WEIGHT float;
declare variable AMELT_NO varchar(10);
declare variable TOTAL_COST float;
declare variable ACTUAL_CHARGED_WEIGHT float;
declare variable ACTUAL_RECOVERY_WEIGHT float;
declare variable ACTUAL_TOTAL_COST float;
declare variable ACTUAL_WEIGHT_OUT float;
declare variable ACTUAL_REMELT_WEIGHT float;
declare variable MELT_TEXT varchar(60);
declare variable DROSS_WEIGHT float;
declare variable ACTUAL_DROSS_WEIGHT float;
declare variable ADD_WEIGHT1 float;
declare variable ADD_WEIGHT2 float;
declare variable MIN_LINE smallint;
declare variable MAX_LINE smallint;
declare variable ADDITIONAL_WEIGHT_OUT1 float;
declare variable ADDITIONAL_WEIGHT_OUT2 float;
declare variable RECOVERY_PERC float;
declare variable RECOVERY_WEIGHT float;
declare variable CAL_YIELD float;
declare variable CAL_COST float;
declare variable ACTUAL_YIELD float;
declare variable ACTUAL_COST float;
declare variable ACTUAL_YIELD1 float;
declare variable ACTUAL_COST1 float;
declare variable ELE_PERC1 float;
declare variable ELE_PERC2 float;
declare variable ELE_PERC3 float;
declare variable ELE_PERC4 float;
declare variable ELE_PERC5 float;
declare variable ELE_PERC6 float;
declare variable ELE_PERC7 float;
declare variable ELE_PERC8 float;
declare variable ELE_PERC9 float;
declare variable ELE_PERC10 float;
declare variable ELE_PERC11 float;
declare variable ELE_PERC12 float;
declare variable ELE_PERC13 float;
declare variable ELE_PERC14 float;
declare variable ELE_PERC15 float;
declare variable ELE_PERC16 float;
declare variable ELE_PERC17 float;
declare variable ELE_PERC18 float;
declare variable ELE_PERC19 float;
declare variable ELE_PERC20 float;
declare variable ELE_PERC21 float;
declare variable ELE_PERC22 float;
declare variable ELE_PERC23 float;
declare variable ELE_PERC24 float;
declare variable ELE_PERC25 float;
declare variable RAWMAT_SHEET_DOC varchar(15);
declare variable SUPPLIER_NAME varchar(60);
declare variable SUPP_CODE varchar(10);
declare variable PL_SHEET_ROW smallint;
declare variable RECOVER_ADJUST_WEIGHT float;
declare variable FNG_ADJUST_QTY float;
declare variable REF_NO varchar(15);
declare variable REF_DATE timestamp;
begin
   doc_no= cast(current_date as varchar(15));
   melt_text ='';
   RECOVER_ADJUST_WEIGHT = 0;
   begin
       delete from melt_summary_meterial;
       delete from melt_summary_meterial_lot;
       delete from melt_summary_final_blend;
       delete from melt_summary_finished_goods  ;
       delete from brd_report_params;
       delete from melt_element_label;

   end
   /*GET MELT NO LIST*/
   select MAX(LINE_NO) from pl_pro_plan_dt
   where MELT_NO = UPPER(:FROM_MELT)
   INTO :MIN_LINE;

   select MAX(LINE_NO) from pl_pro_plan_dt
   where MELT_NO = UPPER(:TO_MELT)
   INTO :MAX_LINE;

   IF( (MAX_LINE >0) AND (MIN_LINE >0) AND (MAX_LINE >= MIN_LINE)) THEN
   BEGIN
      --SELECT PLAN DOCUMENT
       SELECT MAX(PLAN_DOC)
       FROM  pl_pro_plan_dt
       WHERE  pl_pro_plan_dt.melt_no = UPPER(:FROM_MELT)
       INTO :PLAN_DOC  ;

       begin
         --UPDATE LASTEST ELEMENT LABEL
       EXECUTE PROCEDURE  X_UPDATE_ELEMENT_LABEL '*','*','Y';
       INSERT INTO melt_element_label
       select :doc_no,
       ELABEL1,
             ELABEL2,
             ELABEL3,
             ELABEL4,
             ELABEL5,
             ELABEL6,
             ELABEL7,
             ELABEL8,
             ELABEL9,
             ELABEL10,
             ELABEL11,
             ELABEL12,
             ELABEL13,
             ELABEL14,
             ELABEL15,
             ELABEL16,
             ELABEL17,
             ELABEL18,
             ELABEL19,
             ELABEL20,
             ELABEL21,
             ELABEL22,
             ELABEL23,
             ELABEL24,
             ELABEL25 from ic_element_label;
       end

   for SELECT MELT_NO from pl_pro_plan_dt
   where LINE_NO >= :MIN_LINE
   AND LINE_NO <= :MAX_LINE
   AND pl_pro_plan_dt.PLAN_DOC = :PLAN_DOC
   order by pl_pro_plan_dt.LINE_NO
   into :amelt_no
   do
   begin

           select max(item_code)
           from pl_pro_plan_dt
           where melt_no=:amelt_no
           into :item_code  ;
           --DROSS TYPE 1
           SELECT SUM(pl_dross_dt.weight)
           from pl_dross_dt
           where pl_dross_dt.melt_no =:amelt_no
           AND pl_dross_dt.dross_type =1
           into :DROSS_WEIGHT;

            --OTHER TYPE 2 ** not use for

           SELECT SUM(pl_dross_dt.weight)
           from pl_dross_dt
           where pl_dross_dt.melt_no =:amelt_no
           AND pl_dross_dt.dross_type =2
           into :ADD_WEIGHT1;

           --ALUMINIUM TYPE 3 ** ADDED WEIGHT
           SELECT SUM(pl_dross_dt.weight)
           from pl_dross_dt
           where pl_dross_dt.melt_no =:amelt_no
           AND pl_dross_dt.dross_type =3
           into :ADD_WEIGHT2;
           if (DROSS_WEIGHT IS NULL) then  DROSS_WEIGHT =0;
           if (ADD_WEIGHT1 IS NULL) then  ADD_WEIGHT1 =0;
           if (ADD_WEIGHT2 IS NULL) then  ADD_WEIGHT2 =0;
           --note that additional weight 2 is aluminium

           begin
           /*get material information*/
               FOR
             SELECT
               DT.item_code,
               max(dt.item_descs),
               dt.group_id,
               dt.uom,
               dt.lot_no,
               dt.purchase_date ,
               DT.REF_NO,
               DT.REF_DATE,
               MAX(LN.unit_cost),
               sum(dt.qty) ,
               MAX(ST.recovery) ,
               SUM(ST.recovery*dt.qty)/100 AS RECOVERY_WEIGHT    ,
               MAX(DT.acct_cd)
               FROM PL_REQ_HD HD , PL_REQ_DT DT  , IC_MAT_STK_HD ST
               ,IC_MAT_STK_DT_LINK LN   /**20091014 add additional link to stock detail
               also gorup by unit cost since difference grn with same lotcd can be used
               note: make sure that melt_summary_meterial*/
                WHERE HD.DOC_NO = DT.DOC_NO
               AND HD.DOC_DATE = DT.DOC_DATE
               AND HD.TRX_TYPE = DT.TRX_TYPE
               AND HD.status ='X'/*Only posted status accept*/
               AND HD.melt_no =:amelt_no
               AND DT.item_code = ST.stock_cd
               AND DT.group_id = ST.group_id
               AND DT.uom = ST.uom_cd
               AND LN.stock_cd = DT.item_code
               AND LN.group_id = DT.GROUP_ID
               AND LN.uom_cd = DT.uom
               AND LN.stock_cd = ST.stock_cd
               AND LN.group_id = ST.GROUP_ID
               AND LN.uom_cd = ST.uom_CD
               AND LN.lot_cd = DT.lot_no
               AND LN.purchase_date = DT.purchase_date
               and ln.ref_no = dt.ref_no
               and ln.ref_date = dt.ref_date
               --only valued filter
               and dt.qty >0
               GROUP by
               DT.item_code,
               dt.group_id,
               dt.uom,
               dt.lot_no,
               dt.purchase_date   ,
               dt.ref_no,
               dt.ref_date

               --2007/08/18 eliminated null value insert
               HAVING  sum(dt.qty) > 0
               into :stock_code ,:stock_descs,:group_id,:uom_cd,:lot_cd,
               :purchase_date,:REF_NO,:REF_DATE,:unit_cost,:charged_weight,
               :RECOVERY_PERC ,:RECOVERY_WEIGHT  ,:SUPP_CODE

               do
               begin
                 RECOVER_ADJUST_WEIGHT=0;
                 fng_adjust_qty = 0;
                 BEGIN
                    SELECT MAX(DESCS)
                    FROM IC_GROUP WHERE GROUP_ID=:group_id INTO:group_descs;
                 END
                     BEGIN
                     --17 Aug,2009 get adjust directly from stockcard
                     --where source is MA
                         SELECT SUM(QTY) FROM  IC_STOCKCARD
                         WHERE  MELT_NO=:amelt_no
                         AND lot_CD =:lot_cd
                         AND purchase_date =:PURCHASE_DATE
                         AND REF_NO = :REF_NO
                         AND REF_DATE =:REF_DATE
                         AND TRX_TYPE ='MA'
                         INTO :RECOVER_ADJUST_WEIGHT;
                         --REVERSE MODE TO MELT SUMMARY
                     RECOVER_ADJUST_WEIGHT = :RECOVER_ADJUST_WEIGHT*(-1) ;
                     if (RECOVER_ADJUST_WEIGHT<>0) then
                     BEGIN
                        CHARGED_WEIGHT = :CHARGED_WEIGHT +:RECOVER_ADJUST_WEIGHT;
                        RECOVERY_WEIGHT = (:CHARGED_WEIGHT*:RECOVERY_PERC)/100;
                     END
                 END
                 BEGIN
                       --GET LAST PURCHASE PRICE
                       --20080820 Get from ic_mat_stk_dt_link instead
                       --20091014 removed this since unit cost has selected from main cursor
                      /* SELECT MAX(ic_mat_stk_dt_link.unit_cost),MAX(ic_mat_stk_dt_link.acct_code)
                       FROM ic_mat_stk_dt_link
                       WHERE stock_cd = :STOCK_CODE
                       AND GROUP_ID = :GROUP_ID
                       AND UOM_cd = :UOM_CD
                       AND lot_cd = :LOT_CD
                       AND purchase_date = :PURCHASE_DATE
                       INTO :UNIT_COST,:SUPP_CODE;
                       IF (UNIT_COST IS NULL) THEN UNIT_COST = 0;
                       */

                       --SET SUPPLIER NAME
                       SELECT MAX(NAME)
                       FROM po_supplier
                       WHERE SUPPLIER_CD = :SUPP_CODE
                       INTO :SUPPLIER_NAME;

                       select count(*)
                        FROM pl_rawmat_sheet_dt
                         WHERE MELT_NO =    :aMELT_no
                         AND STOCK_CODE = :STOCK_CODE
                         AND pl_rawmat_sheet_dt.group_id = :GROUP_ID
                         AND pl_rawmat_sheet_dt.uom = :UOM_CD
                         AND pl_rawmat_sheet_dt.lot_no = :LOT_CD
                         AND pl_rawmat_sheet_dt.purchase_date = :PURCHASE_DATE
                       into :PL_SHEET_ROW ;
                       if (PL_SHEET_ROW is null) then PL_SHEET_ROW = 0;
                       if (PL_SHEET_ROW >0) then
                       begin
                       /*SELECT ELEMENT COMPONENT FROM PL_RAWMAT_PLAN_DT*/
                        SELECT MAX(PLAN_DOC),
                         MAX(ELE_PERC1),
                         MAX(ELE_PERC2),
                         MAX(ELE_PERC3),
                         MAX(ELE_PERC4),
                         MAX(ELE_PERC5),
                         MAX(ELE_PERC6),
                         MAX(ELE_PERC7),
                         MAX(ELE_PERC8),
                         MAX(ELE_PERC9),
                         MAX(ELE_PERC10),
                         MAX(ELE_PERC11),
                         MAX(ELE_PERC12),
                         MAX(ELE_PERC13),
                         MAX(ELE_PERC14),
                         MAX(ELE_PERC15),
                         MAX(ELE_PERC16),
                         MAX(ELE_PERC17),
                         MAX(ELE_PERC18),
                         MAX(ELE_PERC19),
                         MAX(ELE_PERC20),
                         MAX(ELE_PERC21),
                         MAX(ELE_PERC22),
                         MAX(ELE_PERC23),
                         MAX(ELE_PERC24),
                         MAX(ELE_PERC25)
                         FROM pl_rawmat_sheet_dt
                         WHERE MELT_NO =    :aMELT_no
                         AND STOCK_CODE = :STOCK_CODE
                         AND pl_rawmat_sheet_dt.group_id = :GROUP_ID
                         AND pl_rawmat_sheet_dt.uom = :UOM_CD
                         AND pl_rawmat_sheet_dt.lot_no = :LOT_CD
                         AND pl_rawmat_sheet_dt.purchase_date = :PURCHASE_DATE
                         INTO :RAWMAT_SHEET_DOC, :ELE_PERC1,
                        :ELE_PERC2,    :ELE_PERC3,
                        :ELE_PERC4,    :ELE_PERC5,
                        :ELE_PERC6,    :ELE_PERC7,
                        :ELE_PERC8,    :ELE_PERC9,
                        :ELE_PERC10,   :ELE_PERC11,
                        :ELE_PERC12,   :ELE_PERC13,
                        :ELE_PERC14,   :ELE_PERC15,
                        :ELE_PERC16,   :ELE_PERC17,
                        :ELE_PERC18,   :ELE_PERC19,
                        :ELE_PERC20,   :ELE_PERC11,
                        :ELE_PERC22,   :ELE_PERC13,
                        :ELE_PERC24,   :ELE_PERC25;
                       end 
                       else
                       begin
                        select
                         MAX(ELE1_PERC),
                         MAX(ELE2_PERC),
                         MAX(ELE3_PERC),
                         MAX(ELE4_PERC),
                         MAX(ELE5_PERC),
                         MAX(ELE6_PERC),
                         MAX(ELE7_PERC),
                         MAX(ELE8_PERC),
                         MAX(ELE9_PERC),
                         MAX(ELE10_PERC),
                         MAX(ELE11_PERC),
                         MAX(ELE12_PERC),
                         MAX(ELE13_PERC),
                         MAX(ELE14_PERC),
                         MAX(ELE15_PERC),
                         MAX(ELE16_PERC),
                         MAX(ELE17_PERC),
                         MAX(ELE18_PERC),
                         MAX(ELE19_PERC),
                         MAX(ELE20_PERC),
                         MAX(ELE21_PERC),
                         MAX(ELE22_PERC),
                         MAX(ELE23_PERC),
                         MAX(ELE24_PERC),
                         MAX(ELE25_PERC)
                         from ic_mat_default_element
                         where stock_cd = :STOCK_CODE
                         into :ELE_PERC1,
                        :ELE_PERC2,    :ELE_PERC3,
                        :ELE_PERC4,    :ELE_PERC5,
                        :ELE_PERC6,    :ELE_PERC7,
                        :ELE_PERC8,    :ELE_PERC9,
                        :ELE_PERC10,   :ELE_PERC11,
                        :ELE_PERC12,   :ELE_PERC13,
                        :ELE_PERC14,   :ELE_PERC15,
                        :ELE_PERC16,   :ELE_PERC17,
                        :ELE_PERC18,   :ELE_PERC19,
                        :ELE_PERC20,   :ELE_PERC11,
                        :ELE_PERC22,   :ELE_PERC13,
                        :ELE_PERC24,   :ELE_PERC25;

                       end

                       INSERT INTO MELT_SUMMARY_METERIAL (
                        DOC_NO,
                        MELT_NO,
                        TO_MELT,
                        ITEM_CODE,
                        STOCK_CODE,
                        STOCK_DESCS,
                        UOM_CD,
                        GROUP_ID,
                        GROUP_DESCS,
                        LOT_CD,
                        PURCHASE_DATE,
                        REF_NO,
                        REF_DATE,
                        SUPP_NAME,
                        UNIT_COST,
                        CHARGED_WEIGHT,
                        RECOVERY_PERC,
                        RECOVERY_WEIGHT,
                        ELE_PERC1,
                        ELE_PERC2,
                        ELE_PERC3,
                        ELE_PERC4,
                        ELE_PERC5,
                        ELE_PERC6,
                        ELE_PERC7,
                        ELE_PERC8,
                        ELE_PERC9,
                        ELE_PERC10,
                        ELE_PERC11,
                        ELE_PERC12,
                        ELE_PERC13,
                        ELE_PERC14,
                        ELE_PERC15,
                        ELE_PERC16,
                        ELE_PERC17,
                        ELE_PERC18,
                        ELE_PERC19,
                        ELE_PERC20,
                        ELE_PERC21,
                        ELE_PERC22,
                        ELE_PERC23,
                        ELE_PERC24,
                        ELE_PERC25)
                      VALUES (
                        :DOC_NO,
                        :aMELT_no,
                        :TO_MELT,
                        :ITEM_CODE,
                        :STOCK_CODE,
                        :STOCK_DESCS,
                        :UOM_CD,
                        :GROUP_ID,
                        :GROUP_DESCS,
                        :LOT_CD,
                        :PURCHASE_DATE,
                        :REF_NO,
                        :REF_DATE, 
                        :SUPPLIER_NAME,
                        :UNIT_COST,
                        :CHARGED_WEIGHT,
                        :RECOVERY_PERC,
                        :RECOVERY_WEIGHT,:ELE_PERC1,
                        :ELE_PERC2,    :ELE_PERC3,
                        :ELE_PERC4,    :ELE_PERC5,
                        :ELE_PERC6,    :ELE_PERC7,
                        :ELE_PERC8,    :ELE_PERC9,
                        :ELE_PERC10,   :ELE_PERC11,
                        :ELE_PERC12,   :ELE_PERC13,
                        :ELE_PERC14,   :ELE_PERC15,
                        :ELE_PERC16,   :ELE_PERC17,
                        :ELE_PERC18,   :ELE_PERC19,
                        :ELE_PERC20,   :ELE_PERC21,
                        :ELE_PERC22,   :ELE_PERC23,
                        :ELE_PERC24,   :ELE_PERC25);
                 END/*INSERT BLOCK*/
               end /*for select*/
            end/*END MATERIAL INFORMATION INSERT*/
            BEGIN
            /*when remelt have never received */
                /*  SELECT
                  max(D.item_code),
                  sum(d.qty)
                  FROM  SO_LEDGER D
                  where  d.melt_no =:amelt_no
                  and d.tax_cd =''
                  INto :ITEM_CODE, :actual_weight;    */
                  /*instead of checking from so_ledger */
                   select max(d.item_code),sum(d.weight_qty)
                   from pl_fn_receive_dt  d , pl_fn_receive_hd h
                   where h.doc_no = d.doc_no
                   and h.doc_date = d.doc_date
                   and h.melt_no = d.melt_no
                   and h.status ='X'
                   and d.remelt_item_flag='N'
                   AND d.melt_no=:AMELT_NO
                   INTO :item_code,:ACTUAL_WEIGHT;
                   --20 Aug,2008 add check finishd good adjust qty
                   select sum(d.qty)
                   from pl_fng_adj_dt  d ,pl_fng_adj_hd  h
                   where h.doc_no = d.doc_no
                   and h.doc_date = d.doc_date
                   and h.status ='X'
                   and d.melt_no=  :AMELT_NO
                   into :fng_adjust_qty;
                   if (fng_adjust_qty <>0) then  actual_weight = :actual_weight +:fng_adjust_qty ;

                   if (actual_weight is null) then actual_weight =0;
                     /*get remelt infromation*/
                     if (item_code is null) then
                     begin
                       select MAX(pl_fn_receive_dt.item_code)
                       from pl_fn_receive_dt
                       where pl_fn_receive_dt.melt_no=:AMELT_NO
                       into :item_code;
                     end
                     begin
                       select sum(pl_fn_receive_dt.weight_qty)
                       from pl_fn_receive_dt
                       where pl_fn_receive_dt.melt_no=:AMELT_NO
                       and pl_fn_receive_dt.remelt_item_flag='Y'
                       into :remelt_weight;
                       if (REMELT_WEIGHT is null) then remelt_weight =0;
                       --actual_weight = actual_weight +
                     end
                     begin
                           INSERT INTO MELT_SUMMARY_FINISHED_GOODS (
                            DOC_NO,
                            MELT_NO ,
                            TO_MELT ,
                            ITEM_CODE,
                            ACTUAL_WEIGHT,
                            REMELT_WEIGHT,
                            CAL_COST,
                            CAL_YIELD,
                            ACTUAL_COST,
                            ACTUAL_YIELD,
                            scharged_weight,
                            srecovery_weight,
                            total_cost,
                            DROSS_WEIGHT,
                            ADDITIONAL_WEIGHT1,
                            ADDITIONAL_WEIGHT2)
                          VALUES (
                            :DOC_NO,
                            :AMELT_NO,
                            :TO_MELT,
                            :ITEM_CODE,
                            :ACTUAL_WEIGHT,
                            :REMELT_WEIGHT,
                           0 ,
                              0,
                          0,
                          0,
                          0,
                          0,
                             :total_cost,
                            :DROSS_WEIGHT,
                            :ADD_WEIGHT1,
                            :ADD_WEIGHT2 /*aluminium*/);
                     end

            END/*Finished good insert*/
    end

   /* MELT_SUMMARY_METERIAL_LOT LEVEL*/
        BEGIN
             INSERT INTO MELT_SUMMARY_METERIAL_LOT (
                DOC_NO, ITEM_CODE,
                STOCK_CODE,               STOCK_DESCS,
                UOM_CD,                    GROUP_ID,
                GROUP_DESCS,                LOT_CD,
                PURCHASE_DATE,REF_NO,REF_DATE, SUPP_NAME,       UNIT_COST,
                CHARGED_WEIGHT,RECOVERY_PERC,
                RECOVERY_WEIGHT,  ELE_PERC1,
                     ELE_PERC2,
                     ELE_PERC3,
                     ELE_PERC4,
                     ELE_PERC5,
                     ELE_PERC6,
                     ELE_PERC7,
                     ELE_PERC8,
                     ELE_PERC9,
                     ELE_PERC10,
                     ELE_PERC11,
                     ELE_PERC12,
                     ELE_PERC13,
                     ELE_PERC14,
                     ELE_PERC15,
                     ELE_PERC16,
                     ELE_PERC17,
                     ELE_PERC18,
                     ELE_PERC19,
                     ELE_PERC20,
                     ELE_PERC21,
                     ELE_PERC22,
                     ELE_PERC23,
                     ELE_PERC24,
                     ELE_PERC25)
                SELECT DOC_NO, MAX(ITEM_CODE),
                STOCK_CODE,               max(STOCK_DESCS),
                UOM_CD,                    GROUP_ID,
                GROUP_DESCS,                LOT_CD,
                PURCHASE_DATE, REF_NO,REF_DATE,MAX(SUPP_NAME),       MAX(UNIT_COST),
                SUM(CHARGED_WEIGHT) , MAX(RECOVERY_PERC),
                SUM(RECOVERY_WEIGHT),  MAX(ELE_PERC1),
             MAX(ELE_PERC2),
             MAX(ELE_PERC3),
             MAX(ELE_PERC4),
             MAX(ELE_PERC5),
             MAX(ELE_PERC6),
             MAX(ELE_PERC7),
             MAX(ELE_PERC8),
             MAX(ELE_PERC9),
             MAX(ELE_PERC10),
             MAX(ELE_PERC11),
             MAX(ELE_PERC12),
             MAX(ELE_PERC13),
             MAX(ELE_PERC14),
             MAX(ELE_PERC15),
             MAX(ELE_PERC16),
             MAX(ELE_PERC17),
             MAX(ELE_PERC18),
             MAX(ELE_PERC19),
             MAX(ELE_PERC20),
             MAX(ELE_PERC21),
             MAX(ELE_PERC22),
             MAX(ELE_PERC23),
             MAX(ELE_PERC24),
             MAX(ELE_PERC25)
                FROM MELT_SUMMARY_METERIAL
                GROUP BY  DOC_NO,       STOCK_CODE,
                UOM_CD,                    GROUP_ID,
                GROUP_DESCS,                LOT_CD,
                PURCHASE_DATE ,REF_NO,REF_DATE;


                /*INSERT FINAL BLEND*/
                insert into melt_summary_final_blend
                select :doc_no,
                     MAX(FLB1),
                     MAX(FLB2),
                     MAX(FLB3),
                     MAX(FLB4),
                     MAX(FLB5),
                     MAX(FLB6),
                     MAX(FLB7),
                     MAX(FLB8),
                     MAX(FLB9),
                     MAX(FLB10),
                     MAX(FLB11),
                     MAX(FLB12),
                     MAX(FLB13),
                     MAX(FLB14),
                     MAX(FLB15),
                     MAX(FLB16),
                     MAX(FLB17),
                     MAX(FLB18),
                     MAX(FLB19),
                     MAX(FLB20),
                     MAX(FLB21),
                     MAX(FLB22),
                     MAX(FLB23),
                     MAX(FLB24),
                     MAX(FLB25)
               from pl_rawmat_sheet_HD
               WHERE PLAN_DOC =  :RAWMAT_SHEET_DOC ;

                /*INSERT FINAL BLEND*/


        END
        /* MELT_SUMMARY_METERIAL_LOT LEVEL*/
 
    begin
        select sum(charged_weight), sum(recovery_weight) ,SUM(UNIT_COST*charged_weight)
        from  melt_summary_meterial
        into :ACTUAL_CHARGED_WEIGHT,:ACTUAL_RECOVERY_WEIGHT,:ACTUAL_TOTAL_COST  ;
        SELECT
        SUM(melt_summary_finished_goods.dross_weight),
        SUM(MELT_SUMMARY_FINISHED_GOODS.additional_weight1),
        SUM(MELT_SUMMARY_FINISHED_GOODS.additional_weight2)
        from  melt_summary_finished_goods
        into :ACTUAL_DROSS_WEIGHT,:ADDITIONAL_WEIGHT_OUT1 ,:ADDITIONAL_WEIGHT_OUT2 /*aluminium*/ ;


        SELECT SUM(ACTUAL_WEIGHT+REMELT_WEIGHT)
        FROM melt_summary_finished_goods
        into :actual_weight_out;


        CAL_YIELD = :ACTUAL_RECOVERY_WEIGHT/:ACTUAL_CHARGED_WEIGHT*100;
        CAL_COST  = :ACTUAL_TOTAL_COST/:ACTUAL_RECOVERY_WEIGHT;

        ACTUAL_YIELD = :actual_weight_ouT/:ACTUAL_CHARGED_WEIGHT*100;
        ACTUAL_COST = :ACTUAL_TOTAL_COST/ :actual_weight_out;
        /*Aluminu*/
        ACTUAL_YIELD1 =((:actual_weight_out - :ADDITIONAL_WEIGHT_OUT2)/ :ACTUAL_CHARGED_WEIGHT*100);
        ACTUAL_COST1 =:ACTUAL_TOTAL_COST/(:actual_weight_out - :ADDITIONAL_WEIGHT_OUT2);


        select min(melt_no)||' - '||max(melt_no)
        from  melt_summary_finished_goods
        into :melt_text  ;

        insert into brd_report_params(keyvar15,floatvalue1,floatvalue2,floatvalue3,
        floatvalue4,floatvalue5,floatvalue6,
        floatvalue7,FLOATVALUE8,floatvalue9,floatvalue10,floatvalue11,STRVALUE1)
        values(:doc_no,:CAL_YIELD,:CAL_COST,:ACTUAL_YIELD,
        :ACTUAL_COST ,:ACTUAL_YIELD1,:ACTUAL_COST1,
        :ACTUAL_RECOVERY_WEIGHT,:ACTUAL_CHARGED_WEIGHT,:ACTUAL_DROSS_WEIGHT,:ADDITIONAL_WEIGHT_OUT1,:actual_total_cost,:MELT_TEXT);
        --MAPPED VALUE
        -- cal section
        --1.Cal Yield
        --2.TOTAL RECOVER WEIGHT FROM  MELT_SHEET
        --3 total cost from melt_sheet
        -- actual section
        --4.actual charged weight    (material issue)
        --5 actual charged cost
        --6 finished good weight out + remelt
        --7 dross weight
        --8 additional weight out
    end


    -- Obsolete
   -- delete from pl_melt_no_addigned;
   end /*MIN AND MAX LINE IS VALID*/
   else
   begin
     exception E_PL_MELT_SUMMARY;
   end
  SUSPEND;

end^


ALTER PROCEDURE X_GET_MELT_SUMMARY_REV2012 (
    ADOC_NO VARCHAR(15),
    FROM_MELT VARCHAR(10),
    TO_MELT VARCHAR(10))
AS
declare variable DOC_NO varchar(15);
declare variable PLAN_DOC varchar(15);
declare variable ITEM_CODE varchar(15);
declare variable STOCK_CODE varchar(15);
declare variable STOCK_DESCS varchar(60);
declare variable UOM_CD varchar(4);
declare variable GROUP_ID varchar(10);
declare variable GROUP_DESCS varchar(60);
declare variable LOT_CD varchar(15);
declare variable PURCHASE_DATE timestamp;
declare variable UNIT_COST float;
declare variable CHARGED_WEIGHT float;
declare variable ACTUAL_WEIGHT float;
declare variable REMELT_WEIGHT float;
declare variable SUM_CHARGED_COST float;
declare variable SUM_CHARGED_WEIGHT float;
declare variable SCHARGED_WEIGHT float;
declare variable SRECOVERY_WEIGHT float;
declare variable AMELT_NO varchar(10);
declare variable TOTAL_COST float;
declare variable ACTUAL_CHARGED_WEIGHT float;
declare variable ACTUAL_RECOVERY_WEIGHT float;
declare variable ACTUAL_TOTAL_COST float;
declare variable ACTUAL_WEIGHT_OUT float;
declare variable ACTUAL_REMELT_WEIGHT float;
declare variable MELT_TEXT varchar(60);
declare variable DROSS_WEIGHT float;
declare variable ACTUAL_DROSS_WEIGHT float;
declare variable ADD_WEIGHT1 float;
declare variable ADD_WEIGHT2 float;
declare variable MIN_LINE smallint;
declare variable MAX_LINE smallint;
declare variable ADDITIONAL_WEIGHT_OUT1 float;
declare variable ADDITIONAL_WEIGHT_OUT2 float;
declare variable RECOVERY_PERC float;
declare variable RECOVERY_WEIGHT float;
declare variable CAL_YIELD float;
declare variable CAL_COST float;
declare variable ACTUAL_YIELD float;
declare variable ACTUAL_COST float;
declare variable ACTUAL_YIELD1 float;
declare variable ACTUAL_COST1 float;
declare variable ELE_PERC1 float;
declare variable ELE_PERC2 float;
declare variable ELE_PERC3 float;
declare variable ELE_PERC4 float;
declare variable ELE_PERC5 float;
declare variable ELE_PERC6 float;
declare variable ELE_PERC7 float;
declare variable ELE_PERC8 float;
declare variable ELE_PERC9 float;
declare variable ELE_PERC10 float;
declare variable ELE_PERC11 float;
declare variable ELE_PERC12 float;
declare variable ELE_PERC13 float;
declare variable ELE_PERC14 float;
declare variable ELE_PERC15 float;
declare variable ELE_PERC16 float;
declare variable ELE_PERC17 float;
declare variable ELE_PERC18 float;
declare variable ELE_PERC19 float;
declare variable ELE_PERC20 float;
declare variable ELE_PERC21 float;
declare variable ELE_PERC22 float;
declare variable ELE_PERC23 float;
declare variable ELE_PERC24 float;
declare variable ELE_PERC25 float;
declare variable RAWMAT_SHEET_DOC varchar(15);
declare variable SUPPLIER_NAME varchar(60);
declare variable SUPP_CODE varchar(10);
declare variable PL_SHEET_ROW smallint;
declare variable RECOVER_ADJUST_WEIGHT float;
declare variable FNG_ADJUST_QTY float;
declare variable REF_NO varchar(15);
declare variable REF_DATE timestamp;
begin
   doc_no= cast(current_date as varchar(15));
   melt_text ='';
   RECOVER_ADJUST_WEIGHT = 0;
   min_line =0;
   max_line =0;
   begin
       delete from melt_summary_meterial;
       delete from melt_summary_meterial_lot;
       delete from melt_summary_final_blend;
       delete from melt_summary_finished_goods  ;
       delete from brd_report_params;
       delete from melt_element_label;

   end
   --2 March,2012 forget about line number check we use document no as primary key just check if from_melt and to melt is really exist
    --check if from melt exist
   select count(*) from pl_pro_plan_dt
   where   plan_doc = :ADOC_NO
   and melt_no =:from_melt
   into :min_line;


    --check if to melt exist
   select count(*) from pl_pro_plan_dt
   where   plan_doc = :ADOC_NO
   and melt_no =:to_melt
   into :max_line;
   /*GET MELT NO LIST
   select MAX(LINE_NO) from pl_pro_plan_dt
   where MELT_NO = UPPER(:FROM_MELT)
   INTO :MIN_LINE;

   select MAX(LINE_NO) from pl_pro_plan_dt
   where MELT_NO = UPPER(:TO_MELT)
   INTO :MAX_LINE;
   */
   if ( (MAX_LINE >0) AND (MIN_LINE >0) )THEN
   BEGIN
       PLAN_DOC=:adoc_no;
       begin
         --UPDATE LASTEST ELEMENT LABEL
       EXECUTE PROCEDURE  X_UPDATE_ELEMENT_LABEL '*','*','Y';
       INSERT INTO melt_element_label
       select :doc_no,
       ELABEL1,
             ELABEL2,
             ELABEL3,
             ELABEL4,
             ELABEL5,
             ELABEL6,
             ELABEL7,
             ELABEL8,
             ELABEL9,
             ELABEL10,
             ELABEL11,
             ELABEL12,
             ELABEL13,
             ELABEL14,
             ELABEL15,
             ELABEL16,
             ELABEL17,
             ELABEL18,
             ELABEL19,
             ELABEL20,
             ELABEL21,
             ELABEL22,
             ELABEL23,
             ELABEL24,
             ELABEL25 from ic_element_label;
       end
    --SELECT UNIQUE MELT_NO FROM A PLAN
   for SELECT DISTINCT MELT_NO from pl_pro_plan_dt
   where MELT_NO >=:from_melt
   AND MELT_NO <= :TO_MELT
   AND pl_pro_plan_dt.PLAN_DOC = :PLAN_DOC
   order by melt_no
   into :amelt_no
   do
   begin

           select max(item_code)
           from pl_pro_plan_dt
           where melt_no=:amelt_no
           into :item_code  ;
           --DROSS TYPE 1
           SELECT SUM(pl_dross_dt.weight)
           from pl_dross_dt
           where pl_dross_dt.melt_no =:amelt_no
           AND pl_dross_dt.dross_type =1
           into :DROSS_WEIGHT;

            --OTHER TYPE 2 ** not use for

           SELECT SUM(pl_dross_dt.weight)
           from pl_dross_dt
           where pl_dross_dt.melt_no =:amelt_no
           AND pl_dross_dt.dross_type =2
           into :ADD_WEIGHT1;

           --ALUMINIUM TYPE 3 ** ADDED WEIGHT
           SELECT SUM(pl_dross_dt.weight)
           from pl_dross_dt
           where pl_dross_dt.melt_no =:amelt_no
           AND pl_dross_dt.dross_type =3
           into :ADD_WEIGHT2;
           if (DROSS_WEIGHT IS NULL) then  DROSS_WEIGHT =0;
           if (ADD_WEIGHT1 IS NULL) then  ADD_WEIGHT1 =0;
           if (ADD_WEIGHT2 IS NULL) then  ADD_WEIGHT2 =0;
           --note that additional weight 2 is aluminium

           begin
           /*get material information*/
               FOR
             SELECT
               DT.item_code,
               max(dt.item_descs),
               dt.group_id,
               dt.uom,
               dt.lot_no,
               dt.purchase_date ,
               DT.REF_NO,
               DT.REF_DATE,
               MAX(LN.unit_cost),
               sum(dt.qty) ,
               MAX(ST.recovery) ,
               SUM(ST.recovery*dt.qty)/100 AS RECOVERY_WEIGHT    ,
               MAX(DT.acct_cd)
               FROM PL_REQ_HD HD , PL_REQ_DT DT  , IC_MAT_STK_HD ST
               ,IC_MAT_STK_DT_LINK LN   /**20091014 add additional link to stock detail
               also gorup by unit cost since difference grn with same lotcd can be used
               note: make sure that melt_summary_meterial*/
                WHERE HD.DOC_NO = DT.DOC_NO
               AND HD.DOC_DATE = DT.DOC_DATE
               AND HD.TRX_TYPE = DT.TRX_TYPE
               AND HD.status ='X'/*Only posted status accept*/
               AND HD.melt_no =:amelt_no
               AND DT.item_code = ST.stock_cd
               AND DT.group_id = ST.group_id
               AND DT.uom = ST.uom_cd
               AND LN.stock_cd = DT.item_code
               AND LN.group_id = DT.GROUP_ID
               AND LN.uom_cd = DT.uom
               AND LN.stock_cd = ST.stock_cd
               AND LN.group_id = ST.GROUP_ID
               AND LN.uom_cd = ST.uom_CD
               AND LN.lot_cd = DT.lot_no
               AND LN.purchase_date = DT.purchase_date
               and ln.ref_no = dt.ref_no
               and ln.ref_date = dt.ref_date
               --only valued filter
               and dt.qty >0
               GROUP by
               DT.item_code,
               dt.group_id,
               dt.uom,
               dt.lot_no,
               dt.purchase_date   ,
               dt.ref_no,
               dt.ref_date

               --2007/08/18 eliminated null value insert
               HAVING  sum(dt.qty) > 0
               into :stock_code ,:stock_descs,:group_id,:uom_cd,:lot_cd,
               :purchase_date,:REF_NO,:REF_DATE,:unit_cost,:charged_weight,
               :RECOVERY_PERC ,:RECOVERY_WEIGHT  ,:SUPP_CODE

               do
               begin
                 RECOVER_ADJUST_WEIGHT=0;
                 fng_adjust_qty = 0;
                 BEGIN
                    SELECT MAX(DESCS)
                    FROM IC_GROUP WHERE GROUP_ID=:group_id INTO:group_descs;
                 END
                     BEGIN
                     --17 Aug,2009 get adjust directly from stockcard
                     --where source is MA
                         SELECT SUM(QTY) FROM  IC_STOCKCARD
                         WHERE  MELT_NO=:amelt_no
                         AND lot_CD =:lot_cd
                         AND purchase_date =:PURCHASE_DATE
                         AND REF_NO = :REF_NO
                         AND REF_DATE =:REF_DATE
                         AND TRX_TYPE ='MA'
                         INTO :RECOVER_ADJUST_WEIGHT;
                         --REVERSE MODE TO MELT SUMMARY
                     RECOVER_ADJUST_WEIGHT = :RECOVER_ADJUST_WEIGHT*(-1) ;
                     if (RECOVER_ADJUST_WEIGHT<>0) then
                     BEGIN
                        CHARGED_WEIGHT = :CHARGED_WEIGHT +:RECOVER_ADJUST_WEIGHT;
                        RECOVERY_WEIGHT = (:CHARGED_WEIGHT*:RECOVERY_PERC)/100;
                     END
                 END
                 BEGIN
                       --GET LAST PURCHASE PRICE
                       --20080820 Get from ic_mat_stk_dt_link instead
                       --20091014 removed this since unit cost has selected from main cursor
                      /* SELECT MAX(ic_mat_stk_dt_link.unit_cost),MAX(ic_mat_stk_dt_link.acct_code)
                       FROM ic_mat_stk_dt_link
                       WHERE stock_cd = :STOCK_CODE
                       AND GROUP_ID = :GROUP_ID
                       AND UOM_cd = :UOM_CD
                       AND lot_cd = :LOT_CD
                       AND purchase_date = :PURCHASE_DATE
                       INTO :UNIT_COST,:SUPP_CODE;
                       IF (UNIT_COST IS NULL) THEN UNIT_COST = 0;
                       */

                       --SET SUPPLIER NAME
                       SELECT MAX(NAME)
                       FROM po_supplier
                       WHERE SUPPLIER_CD = :SUPP_CODE
                       INTO :SUPPLIER_NAME;

                       select count(*)
                        FROM pl_rawmat_sheet_dt
                         WHERE MELT_NO =    :aMELT_no
                         AND STOCK_CODE = :STOCK_CODE
                         AND pl_rawmat_sheet_dt.group_id = :GROUP_ID
                         AND pl_rawmat_sheet_dt.uom = :UOM_CD
                         AND pl_rawmat_sheet_dt.lot_no = :LOT_CD
                         AND pl_rawmat_sheet_dt.purchase_date = :PURCHASE_DATE
                       into :PL_SHEET_ROW ;
                       if (PL_SHEET_ROW is null) then PL_SHEET_ROW = 0;
                       if (PL_SHEET_ROW >0) then
                       begin
                       /*SELECT ELEMENT COMPONENT FROM PL_RAWMAT_PLAN_DT*/
                        SELECT MAX(PLAN_DOC),
                         MAX(ELE_PERC1),
                         MAX(ELE_PERC2),
                         MAX(ELE_PERC3),
                         MAX(ELE_PERC4),
                         MAX(ELE_PERC5),
                         MAX(ELE_PERC6),
                         MAX(ELE_PERC7),
                         MAX(ELE_PERC8),
                         MAX(ELE_PERC9),
                         MAX(ELE_PERC10),
                         MAX(ELE_PERC11),
                         MAX(ELE_PERC12),
                         MAX(ELE_PERC13),
                         MAX(ELE_PERC14),
                         MAX(ELE_PERC15),
                         MAX(ELE_PERC16),
                         MAX(ELE_PERC17),
                         MAX(ELE_PERC18),
                         MAX(ELE_PERC19),
                         MAX(ELE_PERC20),
                         MAX(ELE_PERC21),
                         MAX(ELE_PERC22),
                         MAX(ELE_PERC23),
                         MAX(ELE_PERC24),
                         MAX(ELE_PERC25)
                         FROM pl_rawmat_sheet_dt
                         WHERE MELT_NO =    :aMELT_no
                         AND STOCK_CODE = :STOCK_CODE
                         AND pl_rawmat_sheet_dt.group_id = :GROUP_ID
                         AND pl_rawmat_sheet_dt.uom = :UOM_CD
                         AND pl_rawmat_sheet_dt.lot_no = :LOT_CD
                         AND pl_rawmat_sheet_dt.purchase_date = :PURCHASE_DATE
                         INTO :RAWMAT_SHEET_DOC, :ELE_PERC1,
                        :ELE_PERC2,    :ELE_PERC3,
                        :ELE_PERC4,    :ELE_PERC5,
                        :ELE_PERC6,    :ELE_PERC7,
                        :ELE_PERC8,    :ELE_PERC9,
                        :ELE_PERC10,   :ELE_PERC11,
                        :ELE_PERC12,   :ELE_PERC13,
                        :ELE_PERC14,   :ELE_PERC15,
                        :ELE_PERC16,   :ELE_PERC17,
                        :ELE_PERC18,   :ELE_PERC19,
                        :ELE_PERC20,   :ELE_PERC11,
                        :ELE_PERC22,   :ELE_PERC13,
                        :ELE_PERC24,   :ELE_PERC25;
                       end 
                       else
                       begin
                        select
                         MAX(ELE1_PERC),
                         MAX(ELE2_PERC),
                         MAX(ELE3_PERC),
                         MAX(ELE4_PERC),
                         MAX(ELE5_PERC),
                         MAX(ELE6_PERC),
                         MAX(ELE7_PERC),
                         MAX(ELE8_PERC),
                         MAX(ELE9_PERC),
                         MAX(ELE10_PERC),
                         MAX(ELE11_PERC),
                         MAX(ELE12_PERC),
                         MAX(ELE13_PERC),
                         MAX(ELE14_PERC),
                         MAX(ELE15_PERC),
                         MAX(ELE16_PERC),
                         MAX(ELE17_PERC),
                         MAX(ELE18_PERC),
                         MAX(ELE19_PERC),
                         MAX(ELE20_PERC),
                         MAX(ELE21_PERC),
                         MAX(ELE22_PERC),
                         MAX(ELE23_PERC),
                         MAX(ELE24_PERC),
                         MAX(ELE25_PERC)
                         from ic_mat_default_element
                         where stock_cd = :STOCK_CODE
                         into :ELE_PERC1,
                        :ELE_PERC2,    :ELE_PERC3,
                        :ELE_PERC4,    :ELE_PERC5,
                        :ELE_PERC6,    :ELE_PERC7,
                        :ELE_PERC8,    :ELE_PERC9,
                        :ELE_PERC10,   :ELE_PERC11,
                        :ELE_PERC12,   :ELE_PERC13,
                        :ELE_PERC14,   :ELE_PERC15,
                        :ELE_PERC16,   :ELE_PERC17,
                        :ELE_PERC18,   :ELE_PERC19,
                        :ELE_PERC20,   :ELE_PERC11,
                        :ELE_PERC22,   :ELE_PERC13,
                        :ELE_PERC24,   :ELE_PERC25;

                       end

                       INSERT INTO MELT_SUMMARY_METERIAL (
                        DOC_NO,
                        MELT_NO,
                        TO_MELT,
                        ITEM_CODE,
                        STOCK_CODE,
                        STOCK_DESCS,
                        UOM_CD,
                        GROUP_ID,
                        GROUP_DESCS,
                        LOT_CD,
                        PURCHASE_DATE,
                        REF_NO,
                        REF_DATE,
                        SUPP_NAME,
                        UNIT_COST,
                        CHARGED_WEIGHT,
                        RECOVERY_PERC,
                        RECOVERY_WEIGHT,
                        ELE_PERC1,
                        ELE_PERC2,
                        ELE_PERC3,
                        ELE_PERC4,
                        ELE_PERC5,
                        ELE_PERC6,
                        ELE_PERC7,
                        ELE_PERC8,
                        ELE_PERC9,
                        ELE_PERC10,
                        ELE_PERC11,
                        ELE_PERC12,
                        ELE_PERC13,
                        ELE_PERC14,
                        ELE_PERC15,
                        ELE_PERC16,
                        ELE_PERC17,
                        ELE_PERC18,
                        ELE_PERC19,
                        ELE_PERC20,
                        ELE_PERC21,
                        ELE_PERC22,
                        ELE_PERC23,
                        ELE_PERC24,
                        ELE_PERC25)
                      VALUES (
                        :DOC_NO,
                        :aMELT_no,
                        :TO_MELT,
                        :ITEM_CODE,
                        :STOCK_CODE,
                        :STOCK_DESCS,
                        :UOM_CD,
                        :GROUP_ID,
                        :GROUP_DESCS,
                        :LOT_CD,
                        :PURCHASE_DATE,
                        :REF_NO,
                        :REF_DATE, 
                        :SUPPLIER_NAME,
                        :UNIT_COST,
                        :CHARGED_WEIGHT,
                        :RECOVERY_PERC,
                        :RECOVERY_WEIGHT,:ELE_PERC1,
                        :ELE_PERC2,    :ELE_PERC3,
                        :ELE_PERC4,    :ELE_PERC5,
                        :ELE_PERC6,    :ELE_PERC7,
                        :ELE_PERC8,    :ELE_PERC9,
                        :ELE_PERC10,   :ELE_PERC11,
                        :ELE_PERC12,   :ELE_PERC13,
                        :ELE_PERC14,   :ELE_PERC15,
                        :ELE_PERC16,   :ELE_PERC17,
                        :ELE_PERC18,   :ELE_PERC19,
                        :ELE_PERC20,   :ELE_PERC21,
                        :ELE_PERC22,   :ELE_PERC23,
                        :ELE_PERC24,   :ELE_PERC25);
                 END/*INSERT BLOCK*/
               end /*for select*/
            end/*END MATERIAL INFORMATION INSERT*/
            BEGIN
            /*when remelt have never received */
                /*  SELECT
                  max(D.item_code),
                  sum(d.qty)
                  FROM  SO_LEDGER D
                  where  d.melt_no =:amelt_no
                  and d.tax_cd =''
                  INto :ITEM_CODE, :actual_weight;    */
                  /*instead of checking from so_ledger */
                   select max(d.item_code),sum(d.weight_qty)
                   from pl_fn_receive_dt  d , pl_fn_receive_hd h
                   where h.doc_no = d.doc_no
                   and h.doc_date = d.doc_date
                   and h.melt_no = d.melt_no
                   and h.status ='X'
                   and d.remelt_item_flag='N'
                   AND d.melt_no=:AMELT_NO
                   INTO :item_code,:ACTUAL_WEIGHT;
                   --20 Aug,2008 add check finishd good adjust qty
                   select sum(d.qty)
                   from pl_fng_adj_dt  d ,pl_fng_adj_hd  h
                   where h.doc_no = d.doc_no
                   and h.doc_date = d.doc_date
                   and h.status ='X'
                   and d.melt_no=  :AMELT_NO
                   into :fng_adjust_qty;
                   if (fng_adjust_qty <>0) then  actual_weight = :actual_weight +:fng_adjust_qty ;

                   if (actual_weight is null) then actual_weight =0;
                     /*get remelt infromation*/
                     if (item_code is null) then
                     begin
                       select MAX(pl_fn_receive_dt.item_code)
                       from pl_fn_receive_dt
                       where pl_fn_receive_dt.melt_no=:AMELT_NO
                       into :item_code;
                     end
                     begin
                       select sum(pl_fn_receive_dt.weight_qty)
                       from pl_fn_receive_dt
                       where pl_fn_receive_dt.melt_no=:AMELT_NO
                       and pl_fn_receive_dt.remelt_item_flag='Y'
                       into :remelt_weight;
                       if (REMELT_WEIGHT is null) then remelt_weight =0;
                       --actual_weight = actual_weight +
                     end
                     begin
                           INSERT INTO MELT_SUMMARY_FINISHED_GOODS (
                            DOC_NO,
                            MELT_NO ,
                            TO_MELT ,
                            ITEM_CODE,
                            ACTUAL_WEIGHT,
                            REMELT_WEIGHT,
                            CAL_COST,
                            CAL_YIELD,
                            ACTUAL_COST,
                            ACTUAL_YIELD,
                            scharged_weight,
                            srecovery_weight,
                            total_cost,
                            DROSS_WEIGHT,
                            ADDITIONAL_WEIGHT1,
                            ADDITIONAL_WEIGHT2)
                          VALUES (
                            :DOC_NO,
                            :AMELT_NO,
                            :TO_MELT,
                            :ITEM_CODE,
                            :ACTUAL_WEIGHT,
                            :REMELT_WEIGHT,
                           0 ,
                              0,
                          0,
                          0,
                          0,
                          0,
                             :total_cost,
                            :DROSS_WEIGHT,
                            :ADD_WEIGHT1,
                            :ADD_WEIGHT2 /*aluminium*/);
                     end

            END/*Finished good insert*/
    end

   /* MELT_SUMMARY_METERIAL_LOT LEVEL*/
        BEGIN
             INSERT INTO MELT_SUMMARY_METERIAL_LOT (
                DOC_NO, ITEM_CODE,
                STOCK_CODE,               STOCK_DESCS,
                UOM_CD,                    GROUP_ID,
                GROUP_DESCS,                LOT_CD,
                PURCHASE_DATE,REF_NO,REF_DATE, SUPP_NAME,       UNIT_COST,
                CHARGED_WEIGHT,RECOVERY_PERC,
                RECOVERY_WEIGHT,  ELE_PERC1,
                     ELE_PERC2,
                     ELE_PERC3,
                     ELE_PERC4,
                     ELE_PERC5,
                     ELE_PERC6,
                     ELE_PERC7,
                     ELE_PERC8,
                     ELE_PERC9,
                     ELE_PERC10,
                     ELE_PERC11,
                     ELE_PERC12,
                     ELE_PERC13,
                     ELE_PERC14,
                     ELE_PERC15,
                     ELE_PERC16,
                     ELE_PERC17,
                     ELE_PERC18,
                     ELE_PERC19,
                     ELE_PERC20,
                     ELE_PERC21,
                     ELE_PERC22,
                     ELE_PERC23,
                     ELE_PERC24,
                     ELE_PERC25)
                SELECT DOC_NO, MAX(ITEM_CODE),
                STOCK_CODE,               max(STOCK_DESCS),
                UOM_CD,                    GROUP_ID,
                GROUP_DESCS,                LOT_CD,
                PURCHASE_DATE, REF_NO,REF_DATE,MAX(SUPP_NAME),       MAX(UNIT_COST),
                SUM(CHARGED_WEIGHT) , MAX(RECOVERY_PERC),
                SUM(RECOVERY_WEIGHT),  MAX(ELE_PERC1),
             MAX(ELE_PERC2),
             MAX(ELE_PERC3),
             MAX(ELE_PERC4),
             MAX(ELE_PERC5),
             MAX(ELE_PERC6),
             MAX(ELE_PERC7),
             MAX(ELE_PERC8),
             MAX(ELE_PERC9),
             MAX(ELE_PERC10),
             MAX(ELE_PERC11),
             MAX(ELE_PERC12),
             MAX(ELE_PERC13),
             MAX(ELE_PERC14),
             MAX(ELE_PERC15),
             MAX(ELE_PERC16),
             MAX(ELE_PERC17),
             MAX(ELE_PERC18),
             MAX(ELE_PERC19),
             MAX(ELE_PERC20),
             MAX(ELE_PERC21),
             MAX(ELE_PERC22),
             MAX(ELE_PERC23),
             MAX(ELE_PERC24),
             MAX(ELE_PERC25)
                FROM MELT_SUMMARY_METERIAL
                GROUP BY  DOC_NO,       STOCK_CODE,
                UOM_CD,                    GROUP_ID,
                GROUP_DESCS,                LOT_CD,
                PURCHASE_DATE ,REF_NO,REF_DATE;


                /*INSERT FINAL BLEND*/
                insert into melt_summary_final_blend
                select :doc_no,
                     MAX(FLB1),
                     MAX(FLB2),
                     MAX(FLB3),
                     MAX(FLB4),
                     MAX(FLB5),
                     MAX(FLB6),
                     MAX(FLB7),
                     MAX(FLB8),
                     MAX(FLB9),
                     MAX(FLB10),
                     MAX(FLB11),
                     MAX(FLB12),
                     MAX(FLB13),
                     MAX(FLB14),
                     MAX(FLB15),
                     MAX(FLB16),
                     MAX(FLB17),
                     MAX(FLB18),
                     MAX(FLB19),
                     MAX(FLB20),
                     MAX(FLB21),
                     MAX(FLB22),
                     MAX(FLB23),
                     MAX(FLB24),
                     MAX(FLB25)
               from pl_rawmat_sheet_HD
               WHERE PLAN_DOC =  :RAWMAT_SHEET_DOC ;

                /*INSERT FINAL BLEND*/


        END
        /* MELT_SUMMARY_METERIAL_LOT LEVEL*/
 
    begin
        select sum(charged_weight), sum(recovery_weight) ,SUM(UNIT_COST*charged_weight)
        from  melt_summary_meterial
        into :ACTUAL_CHARGED_WEIGHT,:ACTUAL_RECOVERY_WEIGHT,:ACTUAL_TOTAL_COST  ;
        SELECT
        SUM(melt_summary_finished_goods.dross_weight),
        SUM(MELT_SUMMARY_FINISHED_GOODS.additional_weight1),
        SUM(MELT_SUMMARY_FINISHED_GOODS.additional_weight2)
        from  melt_summary_finished_goods
        into :ACTUAL_DROSS_WEIGHT,:ADDITIONAL_WEIGHT_OUT1 ,:ADDITIONAL_WEIGHT_OUT2 /*aluminium*/ ;


        SELECT SUM(ACTUAL_WEIGHT+REMELT_WEIGHT)
        FROM melt_summary_finished_goods
        into :actual_weight_out;


        CAL_YIELD = :ACTUAL_RECOVERY_WEIGHT/:ACTUAL_CHARGED_WEIGHT*100;
        CAL_COST  = :ACTUAL_TOTAL_COST/:ACTUAL_RECOVERY_WEIGHT;

        ACTUAL_YIELD = :actual_weight_ouT/:ACTUAL_CHARGED_WEIGHT*100;
        ACTUAL_COST = :ACTUAL_TOTAL_COST/ :actual_weight_out;
        /*Aluminu*/
        ACTUAL_YIELD1 =((:actual_weight_out - :ADDITIONAL_WEIGHT_OUT2)/ :ACTUAL_CHARGED_WEIGHT*100);
        ACTUAL_COST1 =:ACTUAL_TOTAL_COST/(:actual_weight_out - :ADDITIONAL_WEIGHT_OUT2);


        select min(melt_no)||' - '||max(melt_no)
        from  melt_summary_finished_goods
        into :melt_text  ;

        insert into brd_report_params(keyvar15,floatvalue1,floatvalue2,floatvalue3,
        floatvalue4,floatvalue5,floatvalue6,
        floatvalue7,FLOATVALUE8,floatvalue9,floatvalue10,floatvalue11,STRVALUE1)
        values(:doc_no,:CAL_YIELD,:CAL_COST,:ACTUAL_YIELD,
        :ACTUAL_COST ,:ACTUAL_YIELD1,:ACTUAL_COST1,
        :ACTUAL_RECOVERY_WEIGHT,:ACTUAL_CHARGED_WEIGHT,:ACTUAL_DROSS_WEIGHT,:ADDITIONAL_WEIGHT_OUT1,:actual_total_cost,:MELT_TEXT);
        --MAPPED VALUE
        -- cal section
        --1.Cal Yield
        --2.TOTAL RECOVER WEIGHT FROM  MELT_SHEET
        --3 total cost from melt_sheet
        -- actual section
        --4.actual charged weight    (material issue)
        --5 actual charged cost
        --6 finished good weight out + remelt
        --7 dross weight
        --8 additional weight out
    end


    -- Obsolete
   -- delete from pl_melt_no_addigned;
   end /*MIN AND MAX LINE IS VALID*/
   else
   begin
     exception E_PL_MELT_SUMMARY;
   end
  SUSPEND;

end^


ALTER PROCEDURE X_GET_RESULT_CHECK_PLATE (
    FROM_MELT_NO VARCHAR(10),
    TO_MELT_NO VARCHAR(10))
AS
declare variable FROM_LINE smallint;
declare variable TO_LINE smallint;
declare variable ICHECK_PLATE_GROUP smallint;
declare variable EXPECT_LINE smallint;
begin
    from_line =1;
    expect_line =0;
    begin
      delete from result_check_plate;
    end
    for select distinct pl_rawmat_sheet_dt.check_plate_group_id
    from pl_rawmat_sheet_dt
    where pl_rawmat_sheet_dt.melt_no between :from_melt_no and :to_melt_no
    order by check_plate_group_id
    INTO :ICHECK_PLATE_GROUP
    do
    BEGIN
        expect_line =expect_line + 1;
        INSERT INTO RESULT_CHECK_PLATE (
        MELT_NO,
        CUST_CODE,
        ITEM_CODE,
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12,
        F13,
        F14,
        F15,
        F16,
        F17,
        F18,
        F19,
        F20,
        F21,
        F22,
        F23,
        F24,
        F25,
        EXPECT_LINE)
         select
         max(pl_rawmat_sheet_hd.melt_no) as melt_no ,
         max(pl_rawmat_sheet_hd.cust_code),
         max(pl_rawmat_sheet_hd.item_code),
         cast(sum(ele_perc1* recovery_weight) / sum(recovery_weight) as float) as F1 ,
         cast(sum(ele_perc2* recovery_weight) / sum(recovery_weight) as float) as F2,
         cast(sum(ele_perc3* recovery_weight) / sum(recovery_weight) as float) as F3,
         cast(sum(ele_perc4* recovery_weight) / sum(recovery_weight) as float) as F4,
         cast(sum(ele_perc5* recovery_weight) / sum(recovery_weight) as float) as F5,
         cast(sum(ele_perc6* recovery_weight) / sum(recovery_weight) as float) as F6,
         cast(sum(ele_perc7* recovery_weight) / sum(recovery_weight) as float) as F7,
         cast(sum(ele_perc8* recovery_weight) / sum(recovery_weight) as float) as F8,
         cast(sum(ele_perc9* recovery_weight) / sum(recovery_weight) as float) as F9,
         cast(sum(ele_perc10* recovery_weight) / sum(recovery_weight) as float) as F10,
         cast(sum(ele_perc11* recovery_weight) / sum(recovery_weight) as float) as F11,
         cast(sum(ele_perc12* recovery_weight) / sum(recovery_weight) as float) as F12,
         cast(sum(ele_perc13* recovery_weight) / sum(recovery_weight) as float) as F13,
         cast(sum(ele_perc14* recovery_weight) / sum(recovery_weight) as float) as F14,
         cast(sum(ele_perc15* recovery_weight) / sum(recovery_weight) as float) as F15,
         cast(sum(ele_perc16* recovery_weight) / sum(recovery_weight) as float) as F16,
         cast(sum(ele_perc17* recovery_weight) / sum(recovery_weight) as float) as F17,
         cast(sum(ele_perc18* recovery_weight) / sum(recovery_weight) as float) as F18,
         cast(sum(ele_perc19* recovery_weight) / sum(recovery_weight) as float) as F19,
         cast(sum(ele_perc20* recovery_weight) / sum(recovery_weight) as float) as F20,
         cast(sum(ele_perc21* recovery_weight) / sum(recovery_weight) as float) as F21,
         cast(sum(ele_perc22* recovery_weight) / sum(recovery_weight) as float) as F22,
         cast(sum(ele_perc23* recovery_weight) / sum(recovery_weight) as float) as F23,
         cast(sum(ele_perc24* recovery_weight) / sum(recovery_weight) as float) as F24,
         cast(sum(ele_perc25* recovery_weight) / sum(recovery_weight) as float) as F25,
         cast(:expect_line as smallint)
         from pl_rawmat_sheet_dt , pl_rawmat_sheet_hd
         where pl_rawmat_sheet_dt.plan_doc = pl_rawmat_sheet_hd.plan_doc
         and pl_rawmat_sheet_dt.plan_date = pl_rawmat_sheet_hd.plan_date
         and pl_rawmat_sheet_dt.melt_no = pl_rawmat_sheet_hd.melt_no
         and pl_rawmat_sheet_dt.melt_no between :from_melt_no and :to_melt_no
         and pl_rawmat_sheet_dt.check_plate_group_id<= :ICHECK_PLATE_GROUP;
    end

  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_GET_REVENUE (
    AYEAR INTEGER,
    AMONTH INTEGER,
    AFLAG SMALLINT)
RETURNS (
    PURCHASETAX_AMOUNT INTEGER,
    PURCHASEBASE_AMOUNT FLOAT,
    SALETAX_AMOUNT FLOAT,
    SALEBASE_AMOUNT FLOAT,
    REVENUE_AMOUNT FLOAT,
    TAXDIFF_AMOUNT FLOAT)
AS
begin
taxdiff_amount =0;
purchasetax_amount =0;
 if (:aflag = 0) then
 BEGIN
     SELECT SUM(MBASE_AMT),SUM(MTAX_AMT) FROM ar_ledger
    WHERE CLASS ='I'
    AND FMONTH =:AMONTH
    AND FYEAR =:AYEAR
    AND MTAX_AMT >0
    INTO :salebase_amount ,:saletax_amount;
    
    
    SELECT SUM(MBASE_AMT),SUM(MTAX_AMT) FROM AP_LEDGER
    WHERE CLASS ='P'
    AND FMONTH =:AMONTH
    AND FYEAR =:AYEAR
  --  AND MTAX_AMT >0
    INTO :purchasebase_amount,:purchasetax_amount;
END
ELSE
BEGIN
   SELECT SUM(MBASE_AMT),SUM(MTAX_AMT) FROM ar_ledger
    WHERE CLASS ='I'
    AND FMONTH =:AMONTH
    AND FYEAR =:AYEAR
    AND MTAX_AMT >0
    INTO :salebase_amount ,:saletax_amount;
    
    
    SELECT SUM(MBASE_AMT),SUM(MTAX_AMT) FROM AP_LEDGER
    WHERE CLASS ='P'
    AND FMONTH =:AMONTH
    AND FYEAR =:AYEAR
   -- AND MTAX_AMT >0
    INTO :purchasebase_amount,:purchasetax_amount;
END

 revenue_amount =   :salebase_amount -:purchasebase_amount;
 taxdiff_amount = :saletax_amount - :purchasetax_amount;


  suspend;
end^


ALTER PROCEDURE X_GET_SALEITEM_COMPONENTS (
    ACUST_CODE VARCHAR(10),
    AITEM_CODE VARCHAR(25))
AS
declare variable CLINE1 varchar(150);
declare variable CLINE2 varchar(150);
declare variable CLINE3 varchar(150);
declare variable CLINE4 varchar(150);
declare variable CLINE5 varchar(150);
declare variable CLINE6 varchar(150);
declare variable MAX_D1 smallint;
declare variable MIN_D1 smallint;
declare variable MAX_D2 smallint;
declare variable MIN_D2 smallint;
declare variable MAX_D3 smallint;
declare variable MIN_D3 smallint;
declare variable MAX_D4 smallint;
declare variable MIN_D4 smallint;
declare variable MAX_D5 smallint;
declare variable MIN_D5 smallint;
declare variable MAX_D6 smallint;
declare variable MIN_D6 smallint;
declare variable MAX_D7 smallint;
declare variable MIN_D7 smallint;
declare variable MAX_D8 smallint;
declare variable MIN_D8 smallint;
declare variable MAX_D9 smallint;
declare variable MIN_D9 smallint;
declare variable MAX_D10 smallint;
declare variable MIN_D10 smallint;
declare variable MAX_D11 smallint;
declare variable MIN_D11 smallint;
declare variable MAX_D12 smallint;
declare variable MIN_D12 smallint;
declare variable MAX_D13 smallint;
declare variable MIN_D13 smallint;
declare variable MAX_D14 smallint;
declare variable MIN_D14 smallint;
declare variable MAX_D15 smallint;
declare variable MIN_D15 smallint;
declare variable MAX_D16 smallint;
declare variable MIN_D16 smallint;
declare variable MAX_D17 smallint;
declare variable MIN_D17 smallint;
declare variable MAX_D18 smallint;
declare variable MIN_D18 smallint;
declare variable MAX_D19 smallint;
declare variable MIN_D19 smallint;
declare variable MAX_D20 smallint;
declare variable MIN_D20 smallint;
declare variable MAX_D21 smallint;
declare variable MIN_D21 smallint;
declare variable MAX_D22 smallint;
declare variable MIN_D22 smallint;
declare variable MAX_D23 smallint;
declare variable MIN_D23 smallint;
declare variable MAX_D24 smallint;
declare variable MIN_D24 smallint;
declare variable MAX_V1 float;
declare variable MIN_V1 float;
declare variable MAX_V2 float;
declare variable MIN_V2 float;
declare variable MAX_V3 float;
declare variable MIN_V3 float;
declare variable MAX_V4 float;
declare variable MIN_V4 float;
declare variable MAX_V5 float;
declare variable MIN_V5 float;
declare variable MAX_V6 float;
declare variable MIN_V6 float;
declare variable MAX_V7 float;
declare variable MIN_V7 float;
declare variable MAX_V8 float;
declare variable MIN_V8 float;
declare variable MAX_V9 float;
declare variable MIN_V9 float;
declare variable MAX_V10 float;
declare variable MIN_V10 float;
declare variable MAX_V11 float;
declare variable MIN_V11 float;
declare variable MAX_V12 float;
declare variable MIN_V12 float;
declare variable MAX_V13 float;
declare variable MIN_V13 float;
declare variable MAX_V14 float;
declare variable MIN_V14 float;
declare variable MAX_V15 float;
declare variable MIN_V15 float;
declare variable MAX_V16 float;
declare variable MIN_V16 float;
declare variable MAX_V17 float;
declare variable MIN_V17 float;
declare variable MAX_V18 float;
declare variable MIN_V18 float;
declare variable MAX_V19 float;
declare variable MIN_V19 float;
declare variable MAX_V20 float;
declare variable MIN_V20 float;
declare variable MAX_V21 float;
declare variable MIN_V21 float;
declare variable MAX_V22 float;
declare variable MIN_V22 float;
declare variable MAX_V23 float;
declare variable MIN_V23 float;
declare variable MAX_V24 float;
declare variable MIN_V24 float;
declare variable MAX_F1 varchar(10);
declare variable MIN_F1 varchar(10);
declare variable MAX_F2 varchar(10);
declare variable MIN_F2 varchar(10);
declare variable MAX_F3 varchar(10);
declare variable MIN_F3 varchar(10);
declare variable MAX_F4 varchar(10);
declare variable MIN_F4 varchar(10);
declare variable MAX_F5 varchar(10);
declare variable MIN_F5 varchar(10);
declare variable MAX_F6 varchar(10);
declare variable MIN_F6 varchar(10);
declare variable MAX_F7 varchar(10);
declare variable MIN_F7 varchar(10);
declare variable MAX_F8 varchar(10);
declare variable MIN_F8 varchar(10);
declare variable MAX_F9 varchar(10);
declare variable MIN_F9 varchar(10);
declare variable MAX_F10 varchar(10);
declare variable MIN_F10 varchar(10);
declare variable MAX_F11 varchar(10);
declare variable MIN_F11 varchar(10);
declare variable MAX_F12 varchar(10);
declare variable MIN_F12 varchar(10);
declare variable MAX_F13 varchar(10);
declare variable MIN_F13 varchar(10);
declare variable MAX_F14 varchar(10);
declare variable MIN_F14 varchar(10);
declare variable MAX_F15 varchar(10);
declare variable MIN_F15 varchar(10);
declare variable MAX_F16 varchar(10);
declare variable MIN_F16 varchar(10);
declare variable MAX_F17 varchar(10);
declare variable MIN_F17 varchar(10);
declare variable MAX_F18 varchar(10);
declare variable MIN_F18 varchar(10);
declare variable MAX_F19 varchar(10);
declare variable MIN_F19 varchar(10);
declare variable MAX_F20 varchar(10);
declare variable MIN_F20 varchar(10);
declare variable MAX_F21 varchar(10);
declare variable MIN_F21 varchar(10);
declare variable MAX_F22 varchar(10);
declare variable MIN_F22 varchar(10);
declare variable MAX_F23 varchar(10);
declare variable MIN_F23 varchar(10);
declare variable MAX_F24 varchar(10);
declare variable MIN_F24 varchar(10);
declare variable E1 varchar(4);
declare variable E2 varchar(4);
declare variable E3 varchar(4);
declare variable E4 varchar(4);
declare variable E5 varchar(4);
declare variable E6 varchar(4);
declare variable E7 varchar(4);
declare variable E8 varchar(4);
declare variable E9 varchar(4);
declare variable E10 varchar(4);
declare variable E11 varchar(4);
declare variable E12 varchar(4);
declare variable E13 varchar(4);
declare variable E14 varchar(4);
declare variable E15 varchar(4);
declare variable E16 varchar(4);
declare variable E17 varchar(4);
declare variable E18 varchar(4);
declare variable E19 varchar(4);
declare variable E20 varchar(4);
declare variable E21 varchar(4);
declare variable E22 varchar(4);
declare variable E23 varchar(4);
declare variable E24 varchar(4);
declare variable EI1 varchar(25);
declare variable EI2 varchar(25);
declare variable EI3 varchar(25);
declare variable EI4 varchar(25);
declare variable EI5 varchar(25);
declare variable EI6 varchar(25);
declare variable EI7 varchar(25);
declare variable EI8 varchar(25);
declare variable EI9 varchar(25);
declare variable EI10 varchar(25);
declare variable EI11 varchar(25);
declare variable EI12 varchar(25);
declare variable EI13 varchar(25);
declare variable EI14 varchar(25);
declare variable EI15 varchar(25);
declare variable EI16 varchar(25);
declare variable EI17 varchar(25);
declare variable EI18 varchar(25);
declare variable EI19 varchar(25);
declare variable EI20 varchar(25);
declare variable EI21 varchar(25);
declare variable EI22 varchar(25);
declare variable EI23 varchar(25);
declare variable EI24 varchar(25);
declare variable ACTIVE1 varchar(1);
declare variable ACTIVE2 varchar(1);
declare variable ACTIVE3 varchar(1);
declare variable ACTIVE4 varchar(1);
declare variable ACTIVE5 varchar(1);
declare variable ACTIVE6 varchar(1);
declare variable ACTIVE7 varchar(1);
declare variable ACTIVE8 varchar(1);
declare variable ACTIVE9 varchar(1);
declare variable ACTIVE10 varchar(1);
declare variable ACTIVE11 varchar(1);
declare variable ACTIVE12 varchar(1);
declare variable ACTIVE13 varchar(1);
declare variable ACTIVE14 varchar(1);
declare variable ACTIVE15 varchar(1);
declare variable ACTIVE16 varchar(1);
declare variable ACTIVE17 varchar(1);
declare variable ACTIVE18 varchar(1);
declare variable ACTIVE19 varchar(1);
declare variable ACTIVE20 varchar(1);
declare variable ACTIVE21 varchar(1);
declare variable ACTIVE22 varchar(1);
declare variable ACTIVE23 varchar(1);
declare variable ACTIVE24 varchar(1);
begin
  /*DELETE FROM TEMP TEABLE*/
    delete from so_components_detail where CUST_CODE =:acust_code and ITEM_CODE =:aitem_code;
  /*init paras*/
   EI1 ='';  EI2 =''; EI3 =''; EI4 ='';
   EI5 ='';  EI6 =''; EI7 =''; EI8 ='';
   EI9 =''; EI10 ='';EI11 ='';EI12 ='';
   EI13 =''; EI14 ='';EI15 ='';EI16 ='';
   EI17 =''; EI18 ='';EI19 ='';EI20 ='';
   EI21 =''; EI22 ='';EI23 ='';EI24 ='';
  select
  /**1*/
  max(so_sales_item_req_sheet.elabel1),
  max(so_sales_item_req_sheet.max_float_point1) ,
  max(so_sales_item_req_sheet.min_float_point1)  ,
  max(so_sales_item_req_sheet.max_ele1),
  max(so_sales_item_req_sheet.min_ele1) ,
  max(so_sales_item_req_sheet.ele1_active) ,
  /*2*/
  max(so_sales_item_req_sheet.elabel2),
  max(so_sales_item_req_sheet.max_float_point2) ,
  max(so_sales_item_req_sheet.min_float_point2)  ,
  max(so_sales_item_req_sheet.max_ele2),
  max(so_sales_item_req_sheet.min_ele2),
  max(so_sales_item_req_sheet.ele2_active) ,
  /*3*/
   max(so_sales_item_req_sheet.elabel3),
  max(so_sales_item_req_sheet.max_float_point3) ,
  max(so_sales_item_req_sheet.min_float_point3)  ,
  max(so_sales_item_req_sheet.max_ele3),
  max(so_sales_item_req_sheet.min_ele3),
  max(so_sales_item_req_sheet.ele3_active) ,
  /*4*/
   max(so_sales_item_req_sheet.elabeL4),
  max(so_sales_item_req_sheet.max_float_point4) ,
  max(so_sales_item_req_sheet.min_float_point4)  ,
  max(so_sales_item_req_sheet.max_ele4),
  max(so_sales_item_req_sheet.min_ele4),
  max(so_sales_item_req_sheet.ele4_active) ,
  /*5*/
  max(so_sales_item_req_sheet.elabel5),
  max(so_sales_item_req_sheet.max_float_point5) ,
  max(so_sales_item_req_sheet.min_float_point5)  ,
  max(so_sales_item_req_sheet.max_ele5),
  max(so_sales_item_req_sheet.min_ele5),
  max(so_sales_item_req_sheet.ele5_active) ,
  /*6*/
   max(so_sales_item_req_sheet.elabel6),
  max(so_sales_item_req_sheet.max_float_point6) ,
  max(so_sales_item_req_sheet.min_float_point6)  ,
  max(so_sales_item_req_sheet.max_ele6),
  max(so_sales_item_req_sheet.min_ele6),
  max(so_sales_item_req_sheet.ele6_active) ,
  /*7*/
  max(so_sales_item_req_sheet.elabel7),
  max(so_sales_item_req_sheet.max_float_point7) ,
  max(so_sales_item_req_sheet.min_float_point7)  ,
  max(so_sales_item_req_sheet.max_ele7),
  max(so_sales_item_req_sheet.min_ele7),
  max(so_sales_item_req_sheet.ele7_active) ,
  /*8*/
   max(so_sales_item_req_sheet.elabel8),
  max(so_sales_item_req_sheet.max_float_point8) ,
  max(so_sales_item_req_sheet.min_float_point8)  ,
  max(so_sales_item_req_sheet.max_ele8),
  max(so_sales_item_req_sheet.min_ele8),
  max(so_sales_item_req_sheet.ele8_active) ,
  /*9*/
   max(so_sales_item_req_sheet.elabel9),
  max(so_sales_item_req_sheet.max_float_point9) ,
  max(so_sales_item_req_sheet.min_float_point9)  ,
  max(so_sales_item_req_sheet.max_ele9),
  max(so_sales_item_req_sheet.min_ele9),
  max(so_sales_item_req_sheet.ele9_active) ,
    /**10*/
   max(so_sales_item_req_sheet.elabel10),
  max(so_sales_item_req_sheet.max_float_point10) ,
  max(so_sales_item_req_sheet.min_float_point10)  ,
  max(so_sales_item_req_sheet.max_ele10),
  max(so_sales_item_req_sheet.min_ele10),
  max(so_sales_item_req_sheet.ele10_active) ,
    /**11*/
   max(so_sales_item_req_sheet.elabel11),
  max(so_sales_item_req_sheet.max_float_point11) ,
  max(so_sales_item_req_sheet.min_float_point11)  ,
  max(so_sales_item_req_sheet.max_ele11),
  max(so_sales_item_req_sheet.min_ele11),
  max(so_sales_item_req_sheet.ele11_active) ,
    /**12*/
  max(so_sales_item_req_sheet.elabel12),
  max(so_sales_item_req_sheet.max_float_point12) ,
  max(so_sales_item_req_sheet.min_float_point12)  ,
  max(so_sales_item_req_sheet.max_ele12),
  max(so_sales_item_req_sheet.min_ele12),
  max(so_sales_item_req_sheet.ele12_active) ,
      /**13*/
  max(so_sales_item_req_sheet.elabel13),
  max(so_sales_item_req_sheet.max_float_point13),
  max(so_sales_item_req_sheet.min_float_point13),
  max(so_sales_item_req_sheet.max_ele13),
  max(so_sales_item_req_sheet.min_ele13),
  max(so_sales_item_req_sheet.ele13_active) ,
      /**14*/
  max(so_sales_item_req_sheet.elabel14),
  max(so_sales_item_req_sheet.max_float_point14),
  max(so_sales_item_req_sheet.min_float_point14),
  max(so_sales_item_req_sheet.max_ele14),
  max(so_sales_item_req_sheet.min_ele14),
  max(so_sales_item_req_sheet.ele14_active) ,
    /**15*/
  max(so_sales_item_req_sheet.elabel15),
  max(so_sales_item_req_sheet.max_float_point15),
  max(so_sales_item_req_sheet.min_float_point15),
  max(so_sales_item_req_sheet.max_ele15),
  max(so_sales_item_req_sheet.min_ele15),
  max(so_sales_item_req_sheet.ele15_active) ,
    /**16*/
  max(so_sales_item_req_sheet.elabel16),
  max(so_sales_item_req_sheet.max_float_point16),
  max(so_sales_item_req_sheet.min_float_point16),
  max(so_sales_item_req_sheet.max_ele16),
  max(so_sales_item_req_sheet.min_ele16),
  max(so_sales_item_req_sheet.ele16_active) ,
    /**17*/
  max(so_sales_item_req_sheet.elabel17),
  max(so_sales_item_req_sheet.max_float_point17),
  max(so_sales_item_req_sheet.min_float_point17),
  max(so_sales_item_req_sheet.max_ele17),
  max(so_sales_item_req_sheet.min_ele17),
  max(so_sales_item_req_sheet.ele17_active) ,
    /**18*/
  max(so_sales_item_req_sheet.elabel18),
  max(so_sales_item_req_sheet.max_float_point18),
  max(so_sales_item_req_sheet.min_float_point18),
  max(so_sales_item_req_sheet.max_ele18),
  max(so_sales_item_req_sheet.min_ele18),
  max(so_sales_item_req_sheet.ele18_active) ,
    /**19*/
  max(so_sales_item_req_sheet.elabel19),
  max(so_sales_item_req_sheet.max_float_point19),
  max(so_sales_item_req_sheet.min_float_point19),
  max(so_sales_item_req_sheet.max_ele19),
  max(so_sales_item_req_sheet.min_ele19),
  max(so_sales_item_req_sheet.ele19_active) ,
    /**20*/
  max(so_sales_item_req_sheet.elabel20),
  max(so_sales_item_req_sheet.max_float_point20),
  max(so_sales_item_req_sheet.min_float_point20),
  max(so_sales_item_req_sheet.max_ele20),
  max(so_sales_item_req_sheet.min_ele20),
  max(so_sales_item_req_sheet.ele20_active) ,
    /**21*/
  max(so_sales_item_req_sheet.elabel21),
  max(so_sales_item_req_sheet.max_float_point21),
  max(so_sales_item_req_sheet.min_float_point21),
  max(so_sales_item_req_sheet.max_ele21),
  max(so_sales_item_req_sheet.min_ele21),
  max(so_sales_item_req_sheet.ele21_active) ,
    /**22*/
  max(so_sales_item_req_sheet.elabel22),
  max(so_sales_item_req_sheet.max_float_point22),
  max(so_sales_item_req_sheet.min_float_point22),
  max(so_sales_item_req_sheet.max_ele22),
  max(so_sales_item_req_sheet.min_ele22),
  max(so_sales_item_req_sheet.ele22_active) ,
    /**23*/
  max(so_sales_item_req_sheet.elabel23),
  max(so_sales_item_req_sheet.max_float_point23),
  max(so_sales_item_req_sheet.min_float_point23),
  max(so_sales_item_req_sheet.max_ele23),
  max(so_sales_item_req_sheet.min_ele23),
  max(so_sales_item_req_sheet.ele23_active) ,
    /**24*/
  max(so_sales_item_req_sheet.elabel24),
  max(so_sales_item_req_sheet.max_float_point24),
  max(so_sales_item_req_sheet.min_float_point24),
  max(so_sales_item_req_sheet.max_ele24),
  max(so_sales_item_req_sheet.min_ele24),
  max(so_sales_item_req_sheet.ele24_active)
  from so_sales_item_req_sheet
  where so_sales_item_req_sheet.cust_code =:ACUST_CODE
  and so_sales_item_req_sheet.item_code =:aitem_code
  into
  :E1, :MAX_D1 , :MIN_D1 ,:max_v1,:min_v1,active1,
  :E2, :MAX_D2 , :MIN_D2 ,:max_v2,:min_v2,active2,
  :E3, :MAX_D3 , :MIN_D3 ,:max_v3,:min_v3,active3,
  :E4, :MAX_D4 , :MIN_D4 ,:max_v4,:min_v4,active4,
  :E5, :MAX_D5 , :MIN_D5 ,:max_v5,:min_v5,active5,
  :E6, :MAX_D6 , :MIN_D6 ,:max_v6,:min_v6,active6,
  :E7, :MAX_D7 , :MIN_D7 ,:max_v7,:min_v7,active7,
  :E8, :MAX_D8 , :MIN_D8 ,:max_v8,:min_v8,active8,
  :E9, :MAX_D9 , :MIN_D9 ,:max_v9,:min_v9,active9,
  :E10, :MAX_D10 , :MIN_D10 ,:max_v10,:min_v10,active10,
  :E11, :MAX_D11 , :MIN_D11 ,:max_v11,:min_v11,active11,
  :E12, :MAX_D12 , :MIN_D12 ,:max_v12,:min_v12,active12,
  :E13, :MAX_D13 , :MIN_D13 ,:max_v13,:min_v13,active13,
  :E14, :MAX_D14 , :MIN_D14 ,:max_v14,:min_v14,active14,
  :E15, :MAX_D15 , :MIN_D15 ,:max_v15,:min_v15,active15,
  :E16, :MAX_D16 , :MIN_D16 ,:max_v16,:min_v16,active16,
  :E17, :MAX_D17 , :MIN_D17 ,:max_v17,:min_v17,active17,
  :E18, :MAX_D18 , :MIN_D18 ,:max_v18,:min_v18,active18,
  :E19, :MAX_D19 , :MIN_D19 ,:max_v19,:min_v19,active19,
  :E20, :MAX_D20 , :MIN_D20 ,:max_v20,:min_v20,active20,
  :E21, :MAX_D21 , :MIN_D21 ,:max_v21,:min_v21,active21,
  :E22, :MAX_D22 , :MIN_D22 ,:max_v22,:min_v22,active22,
  :E23, :MAX_D23 , :MIN_D23 ,:max_v23,:min_v23,active23,
  :E24, :MAX_D24 , :MIN_D24 ,:max_v24,:min_v24,active24;
   /*CHECK1*/


   /**initizlize null**/

   begin
      if (max_d1 is null) then      max_d1 =0;
      if (max_d2 is null) then      max_d2 =0;
      if (max_d3 is null) then      max_d3 =0;
      if (max_d4 is null) then      max_d4 =0;
      if (max_d5 is null) then      max_d5 =0;
      if (max_d6 is null) then      max_d6 =0;
      if (max_d7 is null) then      max_d7 =0;
      if (max_d8 is null) then      max_d8 =0;
      if (max_d9 is null) then      max_d9 =0;
      if (max_d10 is null) then      max_d10 =0;
      if (max_d11 is null) then      max_d11 =0;
      if (max_d12 is null) then      max_d12 =0;
      if (max_d13 is null) then      max_d13 =0;
      if (max_d14 is null) then      max_d14 =0;
      if (max_d15 is null) then      max_d15 =0;
      if (max_d16 is null) then      max_d16 =0;
      if (max_d17 is null) then      max_d17 =0;
      if (max_d18 is null) then      max_d18 =0;
      if (max_d19 is null) then      max_d19 =0;
      if (max_d20 is null) then      max_d20 =0;
      if (max_d21 is null) then      max_d21 =0;
      if (max_d22 is null) then      max_d22 =0;
      if (max_d23 is null) then      max_d23 =0;
      if (max_d24 is null) then      max_d24 =0;


       if (max_v1 is null) then      max_v1 =0;
      if (max_v2 is null) then      max_v2 =0;
      if (max_v3 is null) then      max_v3 =0;
      if (max_v4 is null) then      max_v4 =0;
      if (max_v5 is null) then      max_v5 =0;
      if (max_v6 is null) then      max_v6 =0;
      if (max_v7 is null) then      max_v7 =0;
      if (max_v8 is null) then      max_v8 =0;
      if (max_v9 is null) then      max_v9 =0;
      if (max_v10 is null) then      max_v10 =0;
      if (max_v11 is null) then      max_v11 =0;
      if (max_v12 is null) then      max_v12 =0;
      if (max_v13 is null) then      max_v13 =0;
      if (max_v14 is null) then      max_v14 =0;
      if (max_v15 is null) then      max_v15 =0;
      if (max_v16 is null) then      max_v16 =0;
      if (max_v17 is null) then      max_v17 =0;
      if (max_v18 is null) then      max_v18 =0;
      if (max_v19 is null) then      max_v19 =0;
      if (max_v20 is null) then      max_v20 =0;
      if (max_v21 is null) then      max_v21 =0;
      if (max_v22 is null) then      max_v22 =0;
      if (max_v23 is null) then      max_v23 =0;
      if (max_v24 is null) then      max_v24 =0;



         if (min_d1 is null) then      min_d1 =0;
      if (min_d2 is null) then      min_d2 =0;
      if (min_d3 is null) then      min_d3 =0;
      if (min_d4 is null) then      min_d4 =0;
      if (min_d5 is null) then      min_d5 =0;
      if (min_d6 is null) then      min_d6 =0;
      if (min_d7 is null) then      min_d7 =0;
      if (min_d8 is null) then      min_d8 =0;
      if (min_d9 is null) then      min_d9 =0;
      if (min_d10 is null) then      min_d10 =0;
      if (min_d11 is null) then      min_d11 =0;
      if (min_d12 is null) then      min_d12 =0;
      if (min_d13 is null) then      min_d13 =0;
      if (min_d14 is null) then      min_d14 =0;
      if (min_d15 is null) then      min_d15 =0;
      if (min_d16 is null) then      min_d16 =0;
      if (min_d17 is null) then      min_d17 =0;
      if (min_d18 is null) then      min_d18 =0;
      if (min_d19 is null) then      min_d19 =0;
      if (min_d20 is null) then      min_d20 =0;
      if (min_d21 is null) then      min_d21 =0;
      if (min_d22 is null) then      min_d22 =0;
      if (min_d23 is null) then      min_d23 =0;
      if (min_d24 is null) then      min_d24 =0;



       if (min_v1 is null) then      min_v1 =0;
      if (min_v2 is null) then      min_v2 =0;
      if (min_v3 is null) then      min_v3 =0;
      if (min_v4 is null) then      min_v4 =0;
      if (min_v5 is null) then      min_v5 =0;
      if (min_v6 is null) then      min_v6 =0;
      if (min_v7 is null) then      min_v7 =0;
      if (min_v8 is null) then      min_v8 =0;
      if (min_v9 is null) then      min_v9 =0;
      if (min_v10 is null) then      min_v10 =0;
      if (min_v11 is null) then      min_v11 =0;
      if (min_v12 is null) then      min_v12 =0;
      if (min_v13 is null) then      min_v13 =0;
      if (min_v14 is null) then      min_v14 =0;
      if (min_v15 is null) then      min_v15 =0;
      if (min_v16 is null) then      min_v16 =0;
      if (min_v17 is null) then      min_v17 =0;
      if (min_v18 is null) then      min_v18 =0;
      if (min_v19 is null) then      min_v19 =0;
      if (min_v20 is null) then      min_v20 =0;
      if (min_v21 is null) then      min_v21 =0;
      if (min_v22 is null) then      min_v22 =0;
      if (min_v23 is null) then      min_v23 =0;
      if (min_v24 is null) then      min_v24 =0;
   end
    if (active1 ='Y') then
    begin
        if (max_d1 =0) then max_f1 =0;
        if (min_d1 =0) then min_f1 =0;
        if (max_d1 = 1) then
        begin
          max_f1 = floattostr(max_v1,'%.1f')  ;
        end
        else if (max_d1 = 2) then
        begin
                max_f1 = floattostr(max_v1,'%.2f')  ;
        end
         else if (max_d1 = 3) then
        begin
              max_f1 = floattostr(max_v1,'%.3f')  ;
        end
         if (min_d1 = 1) then
        begin
             min_f1 = floattostr(min_v1,'%.1f')  ;
        end
        else if (min_d1 = 2) then
        begin
           min_f1 = floattostr(min_v1,'%.2f')  ;
        end
         else if (min_d1 = 3) then
        begin
           min_f1 = floattostr(min_v1,'%.3f')  ;
        end
        
        
           /*element 1*/
        if ((max_v1 >0) and (min_v1 > 0)) then
        begin
           EI1 =trim(:E1 ||':'||:MIN_F1||'-'||:MAX_F1) ;
        end else if((max_v1 >0) and (min_v1 = 0))  then
        begin
          EI1= trim(:E1 ||':'||:MAX_F1||'(Max)') ;
        end else if((max_v1 =0) and (min_v1 > 0))  then
        begin
          EI1= trim(:E1 ||':'||:MIN_F1||'(Min)') ;
        end
    end   /****End Element 1 check**/
    /*START CHECK2*/
    if (active2 ='Y') then
            if (max_d2 =0) then max_f2 =0;
            if (min_d2 =0) then min_f2 =0;
            begin
            if (max_d2 = 1) then
            begin
              max_f2 = floattostr(max_v2,'%.1f')  ;
            end
            else if (max_d2 = 2) then
            begin
                    max_f2 = floattostr(max_v2,'%.2f')  ;
            end
             else if (max_d2 = 3) then
            begin
                  max_f2 = floattostr(max_v2,'%.3f')  ;
            end
             if (min_d2 = 1) then
            begin
                 min_f2 = floattostr(min_v2,'%.1f')  ;
            end
            else if (min_d2 = 2) then
            begin
               min_f2 = floattostr(min_v2,'%.2f')  ;
            end
             else if (min_d2 = 3) then
            begin
               min_f2 = floattostr(min_v2,'%.3f')  ;
            end
        
                  /*element 2*/
             if ((max_v2 >0) and (min_v2 > 0)) then
            begin
               EI2 =trim(:E2 ||':'||:MIN_F2||'-'||:MAX_F2) ;
            end else if((max_v2 >0) and (min_v2 = 0))  then
            begin
              EI2= trim(:E2 ||':'||:MAX_F2||'(Max)') ;
            end else if((max_v2 =0) and (min_v2 > 0))  then
            begin
              EI2= trim(:E2 ||':'||:MIN_F2||'(Min)') ;
            end

    end     /****END CHECK 2***/
    /*SCHECK3*/
    if (ACTIVE3 ='Y') then
    begin
            if (max_d3 =0) then max_f3=0;
            if (min_d3 =0) then min_f3 =0;
            if (max_d3 = 1) then
            begin
              max_f3 = floattostr(max_v3,'%.1f')  ;
            end
            else if (max_d3 = 2) then
            begin
                    max_f3 = floattostr(max_v3,'%.2f')  ;
            end
             else if (max_D3 = 3) then
            begin
                  max_f3 = floattostr(max_v3,'%.3f')  ;
            end
             if (min_d3 = 1) then
            begin
                 min_f3 = floattostr(min_v3,'%.1f')  ;
            end
            else if (min_d3 = 2) then
            begin
               min_f3 = floattostr(min_v3,'%.2f')  ;
            end
             else if (min_d3 = 3) then
            begin
               min_f3 = floattostr(min_v3,'%.3f')  ;
            end
        
                /*element 3*/
             if ((max_v3 >0) and (min_v3 > 0)) then
            begin
               EI3 =trim(:E3 ||':'||:MIN_F3||'-'||:MAX_F3) ;
            end else if((max_v3 >0) and (min_v3 = 0))  then
            begin
              EI3= trim(:E3 ||':'||:MAX_F3||'(Max)') ;
            end else if((max_v3 =0) and (min_v3 > 0))  then
            begin
              EI3= trim(:E3 ||':'||:MIN_F3||'(Min)') ;
            end


    end /***END CHECK 3*/
    /*check4*/
    if (active4 ='Y') then
    begin
        if (max_d4 =0) then max_f4=0;
        if (min_d4 =0) then min_f4 =0;
        if (max_d4 = 1) then
        begin
          max_f4 = floattostr(max_v4,'%.1f')  ;
        end
        else if (max_d4 = 2) then
        begin
                max_f4 = floattostr(max_v4,'%.2f')  ;
        end
         else if (max_D4 = 3) then
        begin
              max_f4 = floattostr(max_v4,'%.3f')  ;
        end
         if (min_d4 = 1) then
        begin
             min_f4 = floattostr(min_v4,'%.1f')  ;
        end
        else if (min_d4 = 2) then
        begin
           min_f4 = floattostr(min_v4,'%.2f')  ;
        end
         else if (min_d4 = 3) then
        begin
           min_f4 = floattostr(min_v4,'%.3f')  ;
        end
           
    
          /*element 4*/
         if ((max_v4 >0) and (min_v4 > 0)) then
        begin
           EI4 =trim(:E4 ||':'||:MIN_F4||'-'||:MAX_F4) ;
        end else if((max_v4 >0) and (min_v4 = 0))  then
        begin
          EI4= trim(:E4 ||':'||:MAX_F4||'(Max)') ;
        end else if((max_v4 =0) and (min_v4 > 0))  then
        begin
          EI4= trim(:E4 ||':'||:MIN_F4||'(Min)') ;
        end

    end /***END ELEMENT 4*/
    /*check 5*/

    if (active5 ='Y') then
    begin
             if (max_d5 =0) then max_f5=0;
            if (min_d5 =0) then min_f5 =0;

             if (max_d5 = 1) then
            begin
              max_f5 = floattostr(max_v5,'%.1f')  ;
            end
            else if (max_d5 = 2) then
            begin
                    max_f5 = floattostr(max_v5,'%.2f')  ;
            end
             else if (max_D5 = 3) then
            begin
                  max_f5 = floattostr(max_v5,'%.3f')  ;
            end
             if (min_d5 = 1) then
            begin
                 min_f5 = floattostr(min_v5,'%.1f')  ;
            end
            else if (min_d5 = 2) then
            begin
               min_f5 = floattostr(min_v5,'%.2f')  ;
            end
             else if (min_d5 = 3) then
            begin
               min_f5 = floattostr(min_v5,'%.3f')  ;
            end
                 /*element 5*/
             if ((max_v5 >0) and (min_v5 > 0)) then
            begin
               EI5 =trim(:E5 ||':'||:MIN_F5||'-'||:MAX_F5) ;
            end else if((max_v5 >0) and (min_v5 = 0))  then
            begin
              EI5= trim(:E5 ||':'||:MAX_F5||'(Max)') ;
            end else if((max_v5 =0) and (min_v5 > 0))  then
            begin
              EI5= trim(:E5 ||':'||:MIN_F5||'(Min)') ;
            end

    end    /**END CHECK 5***/
     /*check 6*/
     if (active6 ='Y') then
     begin
                 if (max_d6 =0) then max_f6=0;
        if (min_d6 =0) then min_f6 =0;

             if (max_d6 = 1) then
            begin
              max_f6 = floattostr(max_v6,'%.1f')  ;
            end
            else if (max_d6 = 2) then
            begin
                    max_f6 = floattostr(max_v6,'%.2f')  ;
            end
             else if (max_D6 = 3) then
            begin
                  max_f6 = floattostr(max_v6,'%.3f')  ;
            end
             if (min_d6 = 1) then
            begin
                 min_f6 = floattostr(min_v6,'%.1f')  ;
            end
            else if (min_d6 = 2) then
            begin
               min_f6 = floattostr(min_v6,'%.2f')  ;
            end
             else if (min_d6 = 3) then
            begin
               min_f6 = floattostr(min_v6,'%.3f')  ;
            end
            
                /*element 6*/
             if ((max_v6 >0) and (min_v6 > 0)) then
            begin
               EI6 =trim(:E6 ||':'||:MIN_F6||'-'||:MAX_F6) ;
            end else if((max_v6 >0) and (min_v6 = 0))  then
            begin
              EI6= trim(:E6 ||':'||:MAX_F6||'(Max)') ;
            end else if((max_v6 =0) and (min_v6 > 0))  then
            begin
              EI6= trim(:E6 ||':'||:MIN_F6||'(Min)') ;
            end

    end /**END CHECK 6***/
    /*START check 7*/
    if (active7 ='Y') then
    begin
                  if (max_d7 =0) then max_f7=0;
        if (min_d7 =0) then min_f7 =0;
             if (max_d7 = 1) then
            begin
              max_f7 = floattostr(max_v7,'%.1f')  ;
            end
            else if (max_d7 = 2) then
            begin
                    max_f7 = floattostr(max_v7,'%.2f')  ;
            end
             else if (max_D7 = 3) then
            begin
                  max_f7 = floattostr(max_v7,'%.3f')  ;
            end
             if (min_d7 = 1) then
            begin
                 min_f7 = floattostr(min_v7,'%.1f')  ;
            end
            else if (min_d7 = 2) then
            begin
               min_f7 = floattostr(min_v7,'%.2f')  ;
            end
             else if (min_d7 = 3) then
            begin
               min_f7 = floattostr(min_v7,'%.3f')  ;
            end
                        /*element 7*/
             if ((max_v7 >0) and (min_v7 > 0)) then
            begin
               EI7 =trim(:E7 ||':'||:MIN_F7||'-'||:MAX_F7) ;
            end else if((max_v7 >0) and (min_v7 = 0))  then
            begin
              EI7= trim(:E7 ||':'||:MAX_F7||'(Max)') ;
            end else if((max_v7 =0) and (min_v7 > 0))  then
            begin
              EI7= trim(:E7 ||':'||:MIN_F7||'(Min)') ;
            end

    end /***END CHECK 7***/
    /*START check 8*/
    if (active8 ='Y') then
    begin
            if (max_d8 =0) then max_f8=0;
            if (min_d8 =0) then min_f8 =0;

             if (max_d8 = 1) then
            begin
              max_f8 = floattostr(max_v8,'%.1f')  ;
            end
            else if (max_d8 = 2) then
            begin
                    max_f8 = floattostr(max_v8,'%.2f')  ;
            end
             else if (max_D8 = 3) then
            begin
                  max_f8 = floattostr(max_v8,'%.3f')  ;
            end
             if (min_d8 = 1) then
            begin
                 min_f8 = floattostr(min_v8,'%.1f')  ;
            end
            else if (min_d8 = 2) then
            begin
               min_f8 = floattostr(min_v8,'%.2f')  ;
            end
             else if (min_d8 = 3) then
            begin
               min_f8 = floattostr(min_v8,'%.3f')  ;
            end
            
        
                /*element 8*/
             if ((max_v8 >0) and (min_v8 > 0)) then
            begin
               EI8 =trim(:E8 ||':'||:MIN_F8||'-'||:MAX_F8) ;
            end else if((max_v8 >0) and (min_v8 = 0))  then
            begin
              EI8= trim(:E8 ||':'||:MAX_F8||'(Max)') ;
            end else if((max_v8 =0) and (min_v8 > 0))  then
            begin
              EI8= trim(:E8 ||':'||:MIN_F8||'(Min)') ;
            end
    end /**END CHECK 8***/
    /*START check 9*/
    if (active9 = 'Y') then
    begin

                 if (max_d9 =0) then max_f9=0;
              if (min_d9 =0) then min_f9 =0;
            if (max_d9 = 1) then
            begin
              max_f9 = floattostr(max_v9,'%.1f')  ;
            end
            else if (max_d9 = 2) then
            begin
                    max_f9 = floattostr(max_v9,'%.2f')  ;
            end
             else if (max_D9 = 3) then
            begin
                  max_f9 = floattostr(max_v9,'%.3f')  ;
            end
             if (min_d9 = 1) then
            begin
                 min_f9 = floattostr(min_v9,'%.1f')  ;
            end
            else if (min_d9 = 2) then
            begin
               min_f9 = floattostr(min_v9,'%.2f')  ;
            end
             else if (min_d9 = 3) then
            begin
               min_f9 = floattostr(min_v9,'%.3f')  ;
            end
                            /*element 9*/
             if ((max_v9 >0) and (min_v9 > 0)) then
            begin
               EI9 =trim(:E9 ||':'||:MIN_F9||'-'||:MAX_F9) ;
            end else if((max_v9 >0) and (min_v9 = 0))  then
            begin
              EI9= trim(:E9 ||':'||:MAX_F9||'(Max)') ;
            end else if((max_v9 =0) and (min_v9 > 0))  then
            begin
              EI9= trim(:E9 ||':'||:MIN_F9||'(Min)') ;
            end
     end /****END CHECK 9**/
    /*check 10*/
    if (active10 ='Y') then
    begin
              if (max_d10 =0) then max_f10=0;
             if (min_d10 =0) then min_f10 =0;
            if (max_d10 = 1) then
            begin
              max_f10 = floattostr(max_v10,'%.1f')  ;
            end
            else if (max_d10 = 2) then
            begin
                    max_f10 = floattostr(max_v10,'%.2f')  ;
            end
             else if (max_D10 = 3) then
            begin
                  max_f10 = floattostr(max_v10,'%.3f')  ;
            end
             if (min_d10 = 1) then
            begin
                 min_f10 = floattostr(min_v10,'%.1f')  ;
            end
            else if (min_d10 = 2) then
            begin
               min_f10 = floattostr(min_v10,'%.2f')  ;
            end
             else if (min_d10 = 3) then
            begin
               min_f10 = floattostr(min_v10,'%.3f')  ;
            end

                /*element 10*/
             if ((max_v10 >0) and (min_v10 > 0)) then
            begin
               EI10 =trim(:E10 ||':'||:MIN_F10||'-'||:MAX_F10) ;
            end else if((max_v10 >0) and (min_v10 = 0))  then
            begin
              EI10= trim(:E10 ||':'||:MAX_F10||'(Max)') ;
            end else if((max_v10 =0) and (min_v10 > 0))  then
            begin
              EI10= trim(:E10 ||':'||:MIN_F10||'(Min)') ;
            end
    end /**END CHECK 10*/
   /*STARTcheck 11*/
   if (ACTIVE11 ='Y') then
   begin

                 if (max_d11 =0) then max_f11=0;
        if (min_d11 =0) then min_f11 =0;
            if (max_d11 = 1) then
            begin
              max_f11 = floattostr(max_v11,'%.1f')  ;
            end
            else if (max_d11 = 2) then
            begin
                    max_f11 = floattostr(max_v11,'%.2f')  ;
            end
             else if (max_d11 = 3) then
            begin
                  max_f11 = floattostr(max_v11,'%.3f')  ;
            end
             if (min_d11 = 1) then
            begin
                 min_f11 = floattostr(min_v11,'%.1f')  ;
            end
            else if (min_d11 = 2) then
            begin
               min_f11 = floattostr(min_v11,'%.2f')  ;
            end
             else if (min_d11 = 3) then
            begin
               min_f11 = floattostr(min_v11,'%.3f')  ;
            end
            
                /*element 11*/
             if ((max_v11 >0) and (min_v11 > 0)) then
            begin
               EI11 =trim(:E11 ||':'||:MIN_F11||'-'||:MAX_F11) ;
            end else if((max_v11 >0) and (min_v11 = 0))  then
            begin
              EI11= trim(:E11 ||':'||:MAX_F11||'(Max)') ;
            end else if((max_v11 =0) and (min_v11 > 0))  then
            begin
              EI11= trim(:E11 ||':'||:MIN_F11||'(Min)') ;
            end
    end /**END CEHCK 11**/


    /*check 12*/
    if (ACTIVE12 ='Y') then
    begin

          if (max_d12 =0) then max_f12=0;
        if (min_d12 =0) then min_f12 =0;
                if (max_d12 = 1) then
            begin
              max_f12 = floattostr(max_v12,'%.1f')  ;
            end
            else if (max_d12 = 2) then
            begin
                    max_f12 = floattostr(max_v12,'%.2f')  ;
            end
             else if (max_d12 = 3) then
            begin
                  max_f12 = floattostr(max_v12,'%.3f')  ;
            end
             if (min_d12 = 1) then
            begin
                 min_f12 = floattostr(min_v12,'%.1f')  ;
            end
            else if (min_d12 = 2) then
            begin
               min_f12 = floattostr(min_v12,'%.2f')  ;
            end
             else if (min_d12 = 3) then
            begin
               min_f12 = floattostr(min_v12,'%.3f')  ;
            end

            
        
                /*element 12*/
             if ((max_v12 >0) and (min_v12 > 0)) then
            begin
               EI12 =trim(:E12 ||':'||:MIN_F12||'-'||:MAX_F12) ;
            end else if((max_v12 >0) and (min_v12 = 0))  then
            begin
              EI12= trim(:E12 ||':'||:MAX_F12||'(Max)') ;
            end else if((max_v12 =0) and (min_v12 > 0))  then
            begin
              EI12= trim(:E12 ||':'||:MIN_F12||'(Min)') ;
            end
    end /**END CHECK 12*/
   /*check 13*/
   if (ACTIVE13 ='Y') then
   begin
          if (max_d13 =0) then max_f13=0;
          if (min_d13 =0) then min_f13 =0;
           if (max_d13 = 1) then
            begin
              max_f13 = floattostr(max_v13,'%.1f')  ;
            end
            else if (max_d13 = 2) then
            begin
                    max_f13 = floattostr(max_v13,'%.2f')  ;
            end
             else if (max_d13 = 3) then
            begin
                  max_f13 = floattostr(max_v13,'%.3f')  ;
            end
             if (min_d13 = 1) then
            begin
                 min_f13 = floattostr(min_v13,'%.1f')  ;
            end
            else if (min_d13 = 2) then
            begin
               min_f13 = floattostr(min_v13,'%.2f')  ;
            end
             else if (min_d13 = 3) then
            begin
               min_f13 = floattostr(min_v13,'%.3f')  ;
            end
        
                    
             /*element 13*/
             if ((max_v13 >0) and (min_v13 > 0)) then
            begin
               EI13 =trim(:E13 ||':'||:MIN_F13||'-'||:MAX_F13) ;
            end else if((max_v13 >0) and (min_v13 = 0))  then
            begin
              EI13= trim(:E13 ||':'||:MAX_F13||'(Max)') ;
            end else if((max_v13 =0) and (min_v13 > 0))  then
            begin
              EI13= trim(:E13 ||':'||:MIN_F13||'(Min)') ;
            end

   end /***END CHECK 13*/
 /*check 14*/
   if (ACTIVE14 ='Y') then
   begin
           if (max_d14 =0) then max_f14=0;
          if (min_d14 =0) then min_f14 =0;
               if (max_d14 = 1) then
                begin
                  max_f14 = floattostr(max_v14,'%.1f')  ;
                end
                else if (max_d14 = 2) then
                begin
                        max_f14 = floattostr(max_v14,'%.2f')  ;
                end
                 else if (max_d14 = 3) then
                begin
                      max_f14 = floattostr(max_v14,'%.3f')  ;
                end


                 if (min_d14 = 1) then
                begin
                     min_f14 = floattostr(min_v14,'%.1f')  ;
                end
                else if (min_d14 = 2) then
                begin
                   min_f14 = floattostr(min_v14,'%.2f')  ;
                end
                 else if (min_d14 = 3) then
                begin
                   min_f14 = floattostr(min_v14,'%.3f')  ;
                end

                    
             /*element 14*/
             if ((max_v14 >0) and (min_v14 > 0)) then
            begin
               EI14 =trim(:E14 ||':'||:MIN_F14||'-'||:MAX_F14) ;
            end else if((max_v14 >0) and (min_v14 = 0))  then
            begin
              EI14= trim(:E14 ||':'||:MAX_F14||'(Max)') ;
            end else if((max_v14 =0) and (min_v14 > 0))  then
            begin
              EI14= trim(:E14 ||':'||:MIN_F14||'(Min)') ;
            end
    end /**END ACTIVE14*/
 /*check 15*/
   if (ACTIVE15 ='Y') then
   begin
                     if (max_d15 =0) then max_f15=0;
          if (min_d15 =0) then min_f15 =0;
           if (max_d15 = 1) then
            begin
              max_f15 = floattostr(max_v15,'%.1f')  ;
            end
            else if (max_d15 = 2) then
            begin
                    max_f15 = floattostr(max_v15,'%.2f')  ;
            end
             else if (max_d15 = 3) then
            begin
                  max_f15 = floattostr(max_v15,'%.3f')  ;
            end
             if (min_d15 = 1) then
            begin
                 min_f15 = floattostr(min_v15,'%.1f')  ;
            end
            else if (min_d15 = 2) then
            begin
               min_f15 = floattostr(min_v15,'%.2f')  ;
            end
             else if (min_d15 = 3) then
            begin
               min_f15 = floattostr(min_v15,'%.3f')  ;
            end

              /*element 15*/
             if ((max_v15 >0) and (min_v15 > 0)) then
            begin
               EI15 =trim(:E15 ||':'||:MIN_F15||'-'||:MAX_F15) ;
            end else if((max_v15 >0) and (min_v15 = 0))  then
            begin
              EI15= trim(:E15 ||':'||:MAX_F15||'(Max)') ;
            end else if((max_v15 =0) and (min_v15 > 0))  then
            begin
              EI15= trim(:E15 ||':'||:MIN_F15||'(Min)') ;
            end
    end /**END ACTIVE 15*/
 /*check 16*/
   if (ACTIVE16 ='Y') then
   begin
                    if (max_d16 =0) then max_f16=0;
          if (min_d16 =0) then min_f16 =0;
          if (max_d16 = 1) then
            begin
              max_f16 = floattostr(max_v16,'%.1f')  ;
            end
            else if (max_d16 = 2) then
            begin
                    max_f16 = floattostr(max_v16,'%.2f')  ;
            end
             else if (max_d16 = 3) then
            begin
                  max_f16 = floattostr(max_v16,'%.3f')  ;
            end
             if (min_d16 = 1) then
            begin
                 min_f16 = floattostr(min_v16,'%.1f')  ;
            end
            else if (min_d16 = 2) then
            begin
               min_f16 = floattostr(min_v16,'%.2f')  ;
            end
             else if (min_d16 = 3) then
            begin
               min_f16 = floattostr(min_v16,'%.3f')  ;
            end

        
                      /*element 16*/
             if ((max_v16 >0) and (min_v16 > 0)) then
            begin
               EI16 =trim(:E16 ||':'||:MIN_F16||'-'||:MAX_F16) ;
            end else if((max_v16 >0) and (min_v16 = 0))  then
            begin
              EI16= trim(:E16 ||':'||:MAX_F16||'(Max)') ;
            end else if((max_v16 =0) and (min_v16 > 0))  then
            begin
              EI16= trim(:E16 ||':'||:MIN_F16||'(Min)') ;
            end

    end /**END CEHCK 16*/
 /*check 17*/
   if (ACTIVE17 ='Y') then
   begin
          if (max_d17 =0) then max_f17=0;
          if (min_d17 =0) then min_f17 =0;
           if (max_d17 = 1) then
            begin
              max_f17 = floattostr(max_v17,'%.1f')  ;
            end
            else if (max_d17 = 2) then
            begin
                    max_f17 = floattostr(max_v17,'%.2f')  ;
            end
             else if (max_d17 = 3) then
            begin
                  max_f17 = floattostr(max_v17,'%.3f')  ;
            end
             if (min_d17 = 1) then
            begin
                 min_f17 = floattostr(min_v17,'%.1f')  ;
            end
            else if (min_d17 = 2) then
            begin
               min_f17 = floattostr(min_v17,'%.2f')  ;
            end
             else if (min_d17 = 3) then
            begin
               min_f17 = floattostr(min_v17,'%.3f')  ;
            end
              /*element 17*/
             if ((max_v17 >0) and (min_v17 > 0)) then
            begin
               EI17 =trim(:E17 ||':'||:MIN_F17||'-'||:MAX_F17) ;
            end else if((max_v17 >0) and (min_v17 = 0))  then
            begin
              EI17= trim(:E17 ||':'||:MAX_F17||'(Max)') ;
            end else if((max_v17 =0) and (min_v17 > 0))  then
            begin
              EI17= trim(:E17 ||':'||:MIN_F17||'(Min)') ;
            end

    end /**END CHECK 17***/
 /*check 18*/
   if (active18 ='Y') then
   BEGIN
                    if (max_d18 =0) then max_f8=0;
          if (min_d18 =0) then min_f18 =0;
           if (max_d18 = 1) then
            begin
              max_f18 = floattostr(max_v18,'%.1f')  ;
            end
            else if (max_d18 = 2) then
            begin
                    max_f18 = floattostr(max_v18,'%.2f')  ;
            end
             else if (max_d18 = 3) then
            begin
                  max_f18 = floattostr(max_v18,'%.3f')  ;
            end
             if (min_d18 = 1) then
            begin
                 min_f18 = floattostr(min_v18,'%.1f')  ;
            end
            else if (min_d18 = 2) then
            begin
               min_f18 = floattostr(min_v18,'%.2f')  ;
            end
             else if (min_d18 = 3) then
            begin
               min_f18 = floattostr(min_v18,'%.3f')  ;
            end
     /*element 18*/
             if ((max_v18 >0) and (min_v18 > 0)) then
            begin
               EI18 =trim(:E18 ||':'||:MIN_F18||'-'||:MAX_F18) ;
            end else if((max_v18 >0) and (min_v18 = 0))  then
            begin
              EI18= trim(:E18 ||':'||:MAX_F18||'(Max)') ;
            end else if((max_v18 =0) and (min_v18 > 0))  then
            begin
              EI18= trim(:E18 ||':'||:MIN_F18||'(Min)') ;
            end
    END
 /*check 19*/
 if (active19 ='Y') then
 BEGIN
                        if (max_d19 =0) then max_f19=0;
          if (min_d19 =0) then min_f19 =0;

               if (max_d19 = 1) then
                begin
                  max_f19 = floattostr(max_v19,'%.1f')  ;
                end
                else if (max_d19 = 2) then
                begin
                        max_f19 = floattostr(max_v19,'%.2f')  ;
                end
                 else if (max_d19 = 3) then
                begin
                      max_f19 = floattostr(max_v19,'%.3f')  ;
                end
                 if (min_d19 = 1) then
                begin
                     min_f19 = floattostr(min_v19,'%.1f')  ;
                end
                else if (min_d19 = 2) then
                begin
                   min_f19 = floattostr(min_v19,'%.2f')  ;
                end
                 else if (min_d19 = 3) then
                begin
                   min_f19 = floattostr(min_v19,'%.3f')  ;
                end

                        
        
             /*element 19*/
             if ((max_v19 >0) and (min_v19 > 0)) then
            begin
               EI19 =trim(:E19 ||':'||:MIN_F19||'-'||:MAX_F19) ;
            end else if((max_v19 >0) and (min_v19 = 0))  then
            begin
              EI19= trim(:E19 ||':'||:MAX_F19||'(Max)') ;
            end else if((max_v19 =0) and (min_v19 > 0))  then
            begin
              EI19= trim(:E19 ||':'||:MIN_F19||'(Min)') ;
            end


    END /**END CHECK 19**/
    
     /*check 20*/
     if (active20 ='Y') then
     BEGIN

                        if (max_d20 =0) then max_f20=0;
          if (min_d20 =0) then min_f20 =0;
               if (max_d20 = 1) then
                begin
                  max_f20 = floattostr(max_v20,'%.1f')  ;
                end
                else if (max_d20 = 2) then
                begin
                        max_f20 = floattostr(max_v20,'%.2f')  ;
                end
                 else if (max_d20 = 3) then
                begin
                      max_f20 = floattostr(max_v20,'%.3f')  ;
                end
                 if (min_d20 = 1) then
                begin
                     min_f20 = floattostr(min_v20,'%.1f')  ;
                end
                else if (min_d20 = 2) then
                begin
                   min_f20 = floattostr(min_v20,'%.2f')  ;
                end
                 else if (min_d20 = 3) then
                begin
                   min_f20 = floattostr(min_v20,'%.3f')  ;
                end
                  /*element 20*/
             if ((max_v20 >0) and (min_v20 > 0)) then
            begin
               EI20 =trim(:E20 ||':'||:MIN_F20||'-'||:MAX_F20) ;
            end else if((max_v20 >0) and (min_v20 = 0))  then
            begin
              EI20= trim(:E20 ||':'||:MAX_F20||'(Max)') ;
            end else if((max_v20 =0) and (min_v20 > 0))  then
            begin
              EI20= trim(:E20 ||':'||:MIN_F20||'(Min)') ;
            end

     END/***END CHECK 20**/
 /*check 21*/
   if (active21 ='Y') then
   BEGIN
                    if (max_d21 =0) then max_f21=0;
          if (min_d21 =0) then min_f21 =0;

           if (max_d21 = 1) then
            begin
              max_f21 = floattostr(max_v21,'%.1f')  ;
            end
            else if (max_d21 = 2) then
            begin
                    max_f21 = floattostr(max_v21,'%.2f')  ;
            end
             else if (max_d21 = 3) then
            begin
                  max_f21 = floattostr(max_v21,'%.3f')  ;
            end
             if (min_d21 = 1) then
            begin
                 min_f21 = floattostr(min_v21,'%.1f')  ;
            end
            else if (min_d21 = 2) then
            begin
               min_f21 = floattostr(min_v21,'%.2f')  ;
            end
             else if (min_d21 = 3) then
            begin
               min_f21 = floattostr(min_v21,'%.3f')  ;
            end
             /*element 21*/
             if ((max_v21 >0) and (min_v21 > 0)) then
            begin
               EI21 =trim(:E21 ||':'||:MIN_F21||'-'||:MAX_F21) ;
            end else if((max_v21 >0) and (min_v21 = 0))  then
            begin
              EI21= trim(:E21 ||':'||:MAX_F21||'(Max)') ;
            end else if((max_v21 =0) and (min_v21 > 0))  then
            begin
              EI21= trim(:E21 ||':'||:MIN_F21||'(Min)') ;
            end
    END /**END CHECK 20**/
 /*check 22*/
 if (active22 = 'Y') then
 BEGIN

              if (max_d22 =0) then max_f22=0;
            if (min_d22 =0) then min_f22 =0;
           if (max_d22 = 1) then
            begin
              max_f22 = floattostr(max_v22,'%.1f')  ;
            end
            else if (max_d22 = 2) then
            begin
                    max_f22 = floattostr(max_v22,'%.2f')  ;
            end
             else if (max_d22 = 3) then
            begin
                  max_f22 = floattostr(max_v22,'%.3f')  ;
            end
             if (min_d22 = 1) then
            begin
                 min_f22 = floattostr(min_v22,'%.1f')  ;
            end
            else if (min_d22 = 2) then
            begin
               min_f22 = floattostr(min_v22,'%.2f')  ;
            end
             else if (min_d22 = 3) then
            begin
               min_f22 = floattostr(min_v22,'%.3f')  ;
            end


         /*   element 22*/
     if ((max_v22 >0) and (min_v22 > 0)) then
    begin
       EI22 =trim(:E22 ||':'||:MIN_F22||'-'||:MAX_F22) ;
    end else if((max_v22 >0) and (min_v22 = 0))  then
    begin
      EI22= trim(:E22 ||':'||:MAX_F22||'(Max)') ;
    end else if((max_v22 =0) and (min_v22 > 0))  then
    begin
      EI22= trim(:E22 ||':'||:MIN_F22||'(Min)') ;
    end
    END /***END CHECK 22**/
 /*check 23*/
 if (ACTIVE23 ='Y') then
 BEGIN
           if (max_d23 =0) then max_f23=0;
          if (min_d23 =0) then min_f23 =0;
           if (max_d23 = 1) then
            begin
              max_f23 = floattostr(max_v23,'%.1f')  ;
            end
            else if (max_d23 = 2) then
            begin
                    max_f23 = floattostr(max_v23,'%.2f')  ;
            end
             else if (max_d23 = 3) then
            begin
                  max_f23 = floattostr(max_v23,'%.3f')  ;
            end
             if (min_d23 = 1) then
            begin
                 min_f23 = floattostr(min_v23,'%.1f')  ;
            end
            else if (min_d23 = 2) then
            begin
               min_f23 = floattostr(min_v23,'%.2f')  ;
            end
             else if (min_d23 = 3) then
            begin
               min_f23 = floattostr(min_v23,'%.3f')  ;
            end

            

     /*element 23*/
     if ((max_v23 >0) and (min_v23 > 0)) then
    begin
       EI23 =trim(:E23 ||':'||:MIN_F23||'-'||:MAX_F23) ;
    end else if((max_v23 >0) and (min_v23 = 0))  then
    begin
      EI23= trim(:E23 ||':'||:MAX_F23||'(Max)') ;
    end else if((max_v23 =0) and (min_v23 > 0))  then
    begin
      EI23= trim(:E23 ||':'||:MIN_F23||'(Min)') ;
    end

    END /**END CHECK 23*/
 /*check 24*/
 if (active24 ='Y') then
 BEGIN

           if (max_d24 =0) then max_f24=0;
          if (min_d24 =0) then min_f24 =0;
   if (max_d24 = 1) then
    begin
      max_f24 = floattostr(max_v24,'%.1f')  ;
    end
    else if (max_d24 = 2) then
    begin
            max_f24 = floattostr(max_v24,'%.2f')  ;
    end
     else if (max_d24 = 3) then
    begin
          max_f24 = floattostr(max_v24,'%.3f')  ;
    end
     if (min_d24 = 1) then
    begin
         min_f24 = floattostr(min_v24,'%.1f')  ;
    end
    else if (min_d24 = 2) then
    begin
       min_f24 = floattostr(min_v24,'%.2f')  ;
    end
     else if (min_d24 = 3) then
    begin
       min_f24 = floattostr(min_v24,'%.3f')  ;
    end


     /*element 24*/
     if ((max_v24 >0) and (min_v24 > 0)) then
    begin
       EI24 =trim(:E24 ||':'||:MIN_F24||'-'||:MAX_F24) ;
    end else if((max_v24 >0) and (min_v24 = 0))  then
    begin
      EI24= trim(:E24 ||':'||:MAX_F24||'(Max)') ;
    end else if((max_v24 =0) and (min_v24 > 0))  then
    begin
      EI24= trim(:E24 ||':'||:MIN_F24||'(Min)') ;
    end

  END /***END CHECK 24**/


     CLINE1 =  EI1  ||','|| EI2  ||','|| ei3  ||','||ei4 ||',';
     CLINE2 =  EI5  ||','|| EI6  ||','|| ei7  ||','||ei8 ||',';
     CLINE3 =  EI9  ||','|| ei10 ||','|| ei11 ||','||ei12||',';
     CLINE4 =  EI13 ||','|| ei14 ||','|| ei15 ||','||ei16||',';
     CLINE5 =  EI17 ||','|| ei18 ||','|| ei19 ||','||ei20||',';
     CLINE6 =  EI21 ||','|| ei22 ||','|| ei23 ||','||ei24 ;

     --eliminated double comma
     CLINE1 = strReplace(CLINE1,',,,,',',');
     CLINE2 = strReplace(CLINE2,',,,,',',');
     CLINE3 = strReplace(CLINE3,',,,,',',');
     CLINE4 = strReplace(CLINE4,',,,,',',');
     CLINE5 = strReplace(CLINE5,',,,,',',');
     CLINE6 = strReplace(CLINE6,',,,,',',');


     CLINE1 = strReplace(CLINE1,',,,',',');
     CLINE2 = strReplace(CLINE2,',,,',',');
     CLINE3 = strReplace(CLINE3,',,,',',');
     CLINE4 = strReplace(CLINE4,',,,',',');
     CLINE5 = strReplace(CLINE5,',,,',',');
     CLINE6 = strReplace(CLINE6,',,,',',');


     CLINE1 = strReplace(CLINE1,',,',',');
     CLINE2 = strReplace(CLINE2,',,',',');
     CLINE3 = strReplace(CLINE3,',,',',');
     CLINE4 = strReplace(CLINE4,',,',',');
     CLINE5 = strReplace(CLINE5,',,',',');
     CLINE6 = strReplace(CLINE6,',,',',');
--cut last comma
     if (CLINE6=',') then
     begin
       CLINE6 = '';
     end
     if (CLINE5=',') then
     begin
       CLINE5 = '';
     end
     if (CLINE4=',') then
     begin
       CLINE4 = '';
     end
     if (CLINE3=',') then
     begin
       CLINE3 = '';
     end
     if (CLINE2=',') then
     begin
       CLINE2 = '';
     end
     if (CLINE1=',') then
     begin
       CLINE1 = '';
     end

     if (subStr( CLINE2,strLen(CLINE2),strlen(CLINE2)-1 ) ='' )then
     begin
       CLINE1 = subStr(CLINE1,1,strlen(CLINE1) -1) ;
     end else if (subStr( CLINE3,strLen(CLINE3),strlen(CLINE3)-1 ) ='' )then
     begin
       CLINE2 = subStr(CLINE2,1,strlen(CLINE2) -1) ;
     end else if (subStr( CLINE4,strLen(CLINE4),strlen(CLINE4)-1 ) ='' )then
     begin
       CLINE3 = subStr(CLINE3,1,strlen(CLINE3) -1) ;
     end else if (subStr( CLINE5,strLen(CLINE5),strlen(CLINE5)-1 ) ='' )then
     begin
       CLINE4 = subStr(CLINE4,1,strlen(CLINE4) -1) ;
     end else if (subStr( CLINE6,strLen(CLINE6),strlen(CLINE6)-1 ) ='' )then
     begin
       CLINE5 = subStr(CLINE5,1,strlen(CLINE5) -1) ;
     end
      if (subStr( CLINE6,strLen(CLINE6),strlen(CLINE6)-1 ) =',' ) then
     begin
       CLINE6 = subStr(CLINE6,1,strlen(CLINE6) -1) ;
     end
     insert into   so_components_detail values(:ACUST_CODE,:AITEM_CODE,:CLINE1,:cline2, :CLINE3,:CLINE4,:cline5, :CLINE6);
  /*$$IBE$$ SELECT  TRIM( case  when SO_SALES_ITEM_REQ_SHEET.max_ELE1 > 0 and SO_SALES_ITEM_REQ_SHEET.min_ELE1 >0 then
   SO_SALES_ITEM_REQ_SHEET.ELABEL1 ||':' ||
   cast(CAST(SO_SALES_ITEM_REQ_SHEET.Min_ELE1 AS NUMERIC(6,3)) as varchar(6))||'-'||
   cast(CAST(SO_SALES_ITEM_REQ_SHEET.max_ELE1 AS NUMERIC(6,3)) as varchar(6))
   when SO_SALES_ITEM_REQ_SHEET.max_ELE1 > 0 and SO_SALES_ITEM_REQ_SHEET.min_ELE1 =0 then
     SO_SALES_ITEM_REQ_SHEET.ELABEL1 ||':' || cast(CAST(SO_SALES_ITEM_REQ_SHEET.Max_ELE1 AS NUMERIC(6,3)) as varchar(6))||'(Max)'
    END  )
    FROM SO_SALES_ITEM_REQ_SHEET
      WHERE so_sales_item_req_sheet.cust_code =:ACUST_CODE
  AND so_sales_item_req_sheet.item_code =:aitem_code
  INTO : CLINE1; $$IBE$$*/
   --round
 -- suspend;
/*Sep 2011 modified by kung
-- cut last comma
-- show Min only
-- check active_flag
*/
end^


ALTER PROCEDURE X_GET_STOCK
RETURNS (
    STOCK_CD VARCHAR(15),
    GROUP_ID VARCHAR(10),
    UOM_CD VARCHAR(4),
    LOT_CD VARCHAR(15),
    PURCHASE_DATE TIMESTAMP,
    REF_NO VARCHAR(15),
    REF_DATE TIMESTAMP,
    ADJ_QTY NUMERIC(12,2),
    ONHAND_QTY NUMERIC(12,2),
    ACCT_CD VARCHAR(10),
    UNIT_COST FLOAT,
    ADJUST_FLAG VARCHAR(1))
AS
DECLARE VARIABLE STOCKCARD_QTY NUMERIC(12,2);
begin

FOR SELECT STOCK_CD,
GROUP_ID,
UOM_CD,
LOT_CD,
PURCHASE_DATE,
MAX(REF_NO),
MAX(REF_DATE),
MAX(ACCT_CODE),
MAX(UNIT_COST),
SUM(ONHAND_QTY)
FROM ic_mat_stk_dt_link
WHERE GROUP_ID NOT IN ('SG008','SG009')
GROUP BY STOCK_CD,GROUP_ID,UOM_CD,LOT_CD,PURCHASE_DATE
into :stock_cd,:GROUP_ID,:UOM_CD,:lot_cd,:purchase_date,:REF_NO,:REF_DATE,:ACCT_CD,:UNIT_COST,:ONHAND_QTY
DO
BEGIN
 ADJUST_FLAG='N';
   SELECT SUM(QTY)
  from IC_STOCKCARD
  WHERE LOT_CD =:LOT_CD
  AND STOCK_CD=:STOCK_CD
 -- AND PURCHASE_DATE=:PURCHASE_DATE
  INTO : ADJ_QTY;
  IF (ROUND(ADJ_QTY,0) <> ROUND(ONHAND_QTY,0) )  THEN
  BEGIN

 
    ADJUST_FLAG='Y';
  END


  suspend;
END
end^


ALTER PROCEDURE X_GET_UNDUE_ONHAND_LOT (
    ADATE DATE)
RETURNS (
    PURCHASEYEAR SMALLINT,
    STOCK_CD VARCHAR(15),
    LOT_NO VARCHAR(15),
    PURCHASE_DATE DATE,
    REF_NO VARCHAR(15),
    REF_DATE DATE,
    ONHAND_QTY FLOAT,
    CARDQTY FLOAT,
    UPDATEQTY FLOAT,
    UNDUE VARCHAR(1))
AS
DECLARE VARIABLE STOCKCARDONHANDQTY FLOAT;
begin
 for select  lot_cd , purchase_date,min(ref_no),min(ref_date),
 stock_cd,sum(onhand_qty) ,max(extract(year from purchase_date))
 from ic_mat_stk_dt_link
 WHERE GROUP_ID NOT IN('SG008','SG009')
 AND PURCHASE_DATE >=:adate
 group by purchase_date, stock_cd,lot_cd
 order by purchase_date, stock_cd,lot_cd

 into :lot_no,:purchase_date,:ref_no,:ref_date,:stock_cd  ,:onhand_qty   ,:purchaseyear
 do
 begin
  undue = 'N' ;
  cardQty = 0;
  select sum(qty)
  from ic_stockcard
  where stock_cd  = :stock_cd
  and
  lot_cd = :lot_no
  and
  purchase_date = :purchase_date


  into :StockCardOnhandQty;
  cardQty =   StockCardOnhandQty;
  if (StockCardOnhandQty <> onhand_qty) then
  begin

    undue ='Y' ;
    updateQty =   StockCardOnhandQty - onhand_qty ;
  end

  suspend;
 end

  --suspend;
end^


ALTER PROCEDURE X_INS_AP_CREDITOR
AS
declare variable  SUPPLIER_CD VARCHAR(10);
declare variable  CREDITOR_ACCT VARCHAR(10);
declare variable  NAME VARCHAR(60);
declare variable  ADDRESS1 VARCHAR(60);
declare variable  ADDRESS2 VARCHAR(60);
declare variable  ADDRESS3 VARCHAR(60);
declare variable  TELEPHONE VARCHAR(30);
declare variable  FAX_NO VARCHAR(30);
declare variable  CONTRACT_PERSON VARCHAR(60);
declare variable  UPDATE_USER VARCHAR(10);
declare variable  UPDATE_DATE TIMESTAMP;
declare variable  TAX_CD VARCHAR(2);
declare variable  POSTCODE VARCHAR(10);
declare variable  PROVINCE VARCHAR(30);
BEGIN

  FOR SELECT SUPPLIER_CD,CREDITOR_ACCT,NAME,ADDRESS1,ADDRESS2,ADDRESS3,TELEPHONE,FAX_NO,CONTRACT_PERSON,UPDATE_USER,UPDATE_DATE,TAX_CD,POSTCODE,PROVINCE
      FROM PO_SUPPLIER
      WHERE PO_SUPPLIER.CREDITOR_ACCT NOT IN  (SELECT  AP_CREDITOR.creditor_acct FROM AP_CREDITOR)
      INTO :SUPPLIER_CD,:CREDITOR_ACCT,:NAME,:ADDRESS1,:ADDRESS2,:ADDRESS3,:TELEPHONE,:FAX_NO,:CONTRACT_PERSON,:UPDATE_USER,:UPDATE_DATE,:TAX_CD,:POSTCODE,:PROVINCE
  DO
  BEGIN
        INSERT INTO  AP_CREDITOR
        (CREDITOR_ACCT,NAME,CREDITOR_TYPE,ADDRESS1,ADDRESS2,ADDRESS3,
        TELPHONE,FAX_NO,SHORT_NAME,CREDIT_TERM,
        TAX_REGISTED_NO,BALANCE_AMT,CREDIT_LIMIT,CURRENCY_CODE,
        MAILADDR1,MAILADDR2,MAILADDR3,
       UPDATE_USER,UPDATE_DATE,
       TAX_CD,
       PROVINCE,
       POSTCODE  )
       VALUES(  :CREDITOR_ACCT,:NAME,'LT',
       :ADDRESS1,:ADDRESS2,:ADDRESS3,
       :TELEPHONE, :FAX_NO, :NAME, 0, '', 0, 0,'THB',
       :ADDRESS1, :ADDRESS2 , :ADDRESS3,
       :UPDATE_USER, :UPDATE_DATE , '7%',
       :PROVINCE,:POSTCODE  ) ;
  END
  SUSPEND;
END^


ALTER PROCEDURE X_INS_DISPATCH_DT (
    ADOC_NO VARCHAR(15),
    ADOC_DATE DATE,
    ADELIVERY_DATE DATE)
AS
declare variable delivery_date timestamp;
declare variable order_no varchar(15);
declare variable cust_code varchar(10);
declare variable order_date timestamp;
declare variable item_code varchar(15);
declare variable delivery_qty float;
declare variable line_no smallint;
declare variable uom_cd varchar(4);
declare variable item_descs varchar(60);
declare variable remark varchar(255);

BEGIN

    for SELECT ordersch.CUST_CODE,
    ordersch.ORDER_NO,
    ordersch.ORDER_DATE,
    ordersch.ITEM_CODE,
    ordersch.LINE_NO,
    ordersch.SCHEDULE_DATE,
    ordersch.SCHEDULE_QTY,
    ordersch.REMARKS,
    ordersch.UOM ,
    orderdt.item_descs
    FROM SO_ORDER_SCH_DT  ordersch , so_order_dt orderdt
    where ordersch.cust_code = orderdt.cust_code
    and
      ordersch.order_no = orderdt.order_no
    and
     ordersch.order_date = orderdt.order_date
    and
     ordersch.item_code = orderdt.item_code
     and
     ordersch.uom = orderdt.uom
     and
     ordersch.schedule_date <=:ADELIVERY_DATE
     into :cust_code,:order_no,:order_date,:item_code,
     :line_no,:delivery_date,:delivery_qty,:remark,:uom_cd,:item_descs
     do
     begin
             INSERT INTO PL_DISPATCH_DT
             (DELIVERY_DATE,ORDER_NO,ORDER_DATE,ITEM_CODE,UOM_CD,MELT_NO,LINE_NO,CUST_CODE,REMARKS,ORDER_QTY,DET_QTY,doc_no,doc_date)
             valueS (:delivery_date,:order_no,:order_date,:item_code,:uom_cd,'MELT_NO',:LINE_NO,:CUST_CODE,:remark,0,:delivery_qty,:ADOC_NO,:ADOC_DATE) ;

     end






  SUSPEND;
END^


ALTER PROCEDURE X_INS_PL_REQ_DT (
    ADOC_NO VARCHAR(15),
    ADOC_DATE DATE,
    APLAN_DOC VARCHAR(15),
    AMELT_NO VARCHAR(10))
AS
begin

 INSERT INTO PL_REQ_DT (
    DOC_NO,     DOC_DATE,
    TRX_TYPE,    ITEM_CODE,
    ITEM_DESCS,    LOT_NO,
    PURCHASE_DATE,    QTY,
    UNIT_COST,       UOM,
    TOTAL_COST,      GROUP_ID,
    USAGED_QTY,      ITEM_TYPE,
    ONHAND_QTY,      REF_NO,
    REF_DATE,
    ACCT_CD)
    select   :ADOC_NO, :ADOC_DATE,
    'RT',PL.stock_code,
    ST.EN_descs,PL.lot_no,
    PL.purchase_date,0,
    PL.unit_cost,PL.uom,
    0,PL.group_id,
    0,'N',
    PL.onhand_qty,'GRNNO',
    current_date,
    PL.supplier_cd
    from  pl_rawmat_sheet_dt pl,ic_mat_stk_hd ST
    where PL.stock_code = ST.stock_cd
    and pl.plan_doc =:aplan_doc
    AND PL.MELT_NO=:AMELT_NO;

  suspend;
end^


ALTER PROCEDURE X_INS_SALES_LEDGER (
    DOC_NO VARCHAR(15),
    DOC_DATE TIMESTAMP,
    MODULE VARCHAR(2),
    MODE VARCHAR(1))
AS
declare variable QTY FLOAT ;
begin
  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_INS_SO_ORDER (
    CUST_CODE VARCHAR(10),
    ORDER_NO VARCHAR(15),
    ORDER_DATE TIMESTAMP,
    DOC_NO VARCHAR(15),
    DOC_DATE TIMESTAMP)
AS
/**Variable For SO_ORDER_HD*/
declare variable REF_NO VARCHAR(15);
declare variable REF_DATE timestamp;
declare variable delivery_date timestamp;
declare variable descs varchar(60);
declare variable doc_amt float;
declare variable update_user varchar(10);
/*Declare Variable for SO_ORDER_DT*/

declare variable ITEM_CODE VARCHAR(15);
declare variable LINE_NO INTEGER;
declare variable UOM Varchar(2);
declare variable item_descs varchar(60);
declare variable unit_cost float;
declare variable total_amt float;
/*declare variable remarks varchar(60);*/
declare variable tax_amt float ;
declare variable base_amt float;
declare variable qty float;
declare variable TAX_CD VARCHAR(2);
declare variable tax_rate float;
declare variable remarks varchar(255);
declare variable fax_to varchar(60);
declare variable cc_to varchar(60);
declare variable hremarks varchar(255) ;
declare variable currency_cd varchar(4);
declare variable mark_up smallint;
declare variable  term_of_payment smallint;
BEGIN
  BEGIN
     SELECT REF_NO, REF_DATE, DELIVERY_DATE, DESCS, DOC_AMT, UPDATE_USER,fax_to,cc_to,remarks,currency_cd,term_of_payment
     FROM so_quotation_hd
     WHERE CUST_CODE =:CUST_CODE
     AND DOC_DATE =:DOC_DATE
     AND DOC_NO =:DOC_NO
     INTO :REF_NO, :REF_DATE, :delivery_date, :descs, :doc_amt, :update_user,:fax_to,:cc_to,:hremarks,:currency_cd,:term_of_payment;

     INSERT INTO SO_ORDER_HD (CUST_CODE,ORDER_NO,ORDER_DATE,REF_NO,REF_DATE,UPDATE_USER,UPDATE_DATE,STATUS,ORDER_AMT,DESCS,SCHEDULE_DATE,fax_to,cc_to,remarks,currency_cd,term_of_payment)
     VALUES (:CUST_CODE,:ORDER_NO,:ORDER_DATE,:REF_NO,:REF_DATE,:UPDATE_USER,current_timestamp,'N',:DOC_AMT,:DESCS,:DELIVERY_DATE,:fax_to,:cc_to,:hremarks,:currency_cd,:term_of_payment);
     WHEN SQLCODE -530  DO
        EXCEPTION EX_SO_ORDER_HD;

   END

    FOR
    SELECT ITEM_CODE,LINE_NO,UOM,ITEM_DESCS,UNIT_COST,TOTAL_AMT,TAX_AMT,BASE_AMT,TAX_CD,QTY,TAX_RATE,remarks ,mark_up
    FROM so_QUOTATION_DT
    WHERE CUST_CODE =:CUST_CODE
    AND DOC_DATE =:DOC_DATE
    AND DOC_NO =:DOC_NO
    INTO :ITEM_CODE,:LINE_NO,:UOM,:ITEM_DESCS,:UNIT_COST,:TOTAL_AMT,:TAX_AMT,:BASE_AMT,:TAX_CD,:QTY,:TAX_RATE,:remarks,:mark_up
    DO
    BEGIN
       INSERT INTO SO_ORDER_DT (ORDER_NO,ORDER_DATE,ITEM_CODE,CUST_CODE,LINE_NO,UOM,ITEM_DESCS,UNIT_COST,TOTAL_AMT,REMARKS,DISCS_AMT,TAX_AMT,BASE_AMT,TAX_CD,DISCS_CD,QTY,TAX_RATE,STATUS,DET_QTY,mark_up) /**ADD DET_QTY AON 20030211*/
       VALUES (:ORDER_NO,:ORDER_DATE,:ITEM_CODE,:CUST_CODE,:LINE_NO,:UOM,:ITEM_DESCS,:UNIT_COST,:TOTAL_AMT,:remarks,0.00,:TAX_AMT,:BASE_AMT,:TAX_CD,'',:QTY,:TAX_RATE,'N',0.0,:mark_up);

       WHEN SQLCODE - 530 DO
       BEGIN
         EXCEPTION EX_SO_ORDER_DT;
       END

    END
    /**UPDATE STATUS TO 'X' MEAN GENERATED*/
    BEGIN
      UPDATE so_quotation_hd
      SET STATUS ='X'
      WHERE CUST_CODE =:CUST_CODE
      AND DOC_DATE =:DOC_DATE
      AND DOC_NO =:DOC_NO;

      UPDATE so_quotation_DT
      SET STATUS ='X'
      WHERE CUST_CODE =:CUST_CODE
      AND DOC_DATE =:DOC_DATE
      AND DOC_NO =:DOC_NO;
      UPDATE SO_ORDER_HD
      SET ORDER_AMT =:DOC_AMT
      WHERE ORDER_NO =:ORDER_NO
      AND ORDER_DATE =:ORDER_DATE
      AND CUST_CODE =:CUST_CODE;

    END
    suspend;
END^


ALTER PROCEDURE X_INS_STOCKCARD (
    ACCT_CD VARCHAR(10),
    DOC_NO VARCHAR(15),
    DOC_DATE TIMESTAMP,
    UPDATE_USER VARCHAR(10),
    MODULE VARCHAR(2),
    MODE VARCHAR(1))
AS
declare variable  REF_NO VARCHAR(15);
  declare variable  REF_DATE TIMESTAMP;
  declare variable  QTY FLOAT;
  declare variable  UNIT_COST FLOAT;
  declare variable  TOTAL_COST FLOAT;
  declare variable  LOT_CD VARCHAR(15);
  declare variable  GROUP_ID VARCHAR(10);
  declare variable  UOM_CD VARCHAR(4);
  declare variable  STOCK_VALUE FLOAT;
  declare variable  FMONTH SMALLINT;
  declare variable  FYEAR SMALLINT;
  declare variable  STOCK_CD VARCHAR(15);
  declare variable  UPDATE_DATE TIMESTAMP ;
  declare variable row_num smallint;
  declare variable order_line smallint;
  declare variable usage_qty float;
  declare variable order_qty float;
  declare variable descs varchar(60);
  declare variable trx_type varchar(2);
BEGIN

  BEGIN
     UPDATE_DATE = CURRENT_DATE;
     row_num =0;
     FYEAR = extract(YEAR FROM DOC_DATE);
     FMONTH = EXTRACT(MONTH FROM DOC_DATE);
     IF (MODULE ='PO') then     /**GRN TRANSACTION*/
     BEGIN

       SELECT COUNT(*)
       FROM PO_GRN_DT B, PO_GRN_HD A
       WHERE A.supp_code =b.supp_code
       and a.grn_no = b.grn_no
       and b.grn_date =b.grn_date
        AND A.SUPP_CODE =:ACCT_CD
        AND A.GRN_DATE =:DOC_DATE
        AND A.GRN_NO =:DOC_NO
        INTO :row_num;
       if (row_num <= 0 ) then
       begin
         exception E_NO_ROW;
       end
       FOR
        SELECT
        A.DESCS ,
        B.SUPP_CODE,
        B.GRN_NO,
        B.GRN_DATE,
        B.ORDER_NO,
        B.ORDER_DATE,
        B.GRN_QTY,
        B.ORDER_QTY,
        B.UNIT_COST,
        B.TOTAL_AMT,
        B.LOT_NO,B.GROUP_ID,B.UOM,
        B.GRN_QTY*B.UNIT_COST,
        B.ITEM_CODE,
        b.order_line
       FROM PO_GRN_DT B , PO_GRN_HD A
       WHERE A.supp_code =b.supp_code
       AND a.grn_no = b.grn_no
       AND b.grn_date =b.grn_date
       AND A.SUPP_CODE =:ACCT_CD
       AND A.GRN_DATE =:DOC_DATE
       AND A.GRN_NO =:DOC_NO
       INTO :DESCS, :ACCT_CD,:DOC_NO,:DOC_DATE,
             :REF_NO,:REF_DATE,:QTY,:ORDER_QTY,
             :UNIT_COST,:TOTAL_COST,
             :LOT_CD,:GROUP_ID,:UOM_CD,
             :STOCK_VALUE,:STOCK_CD,:ORDER_LINE
        DO
        BEGIN
            UPDATE PO_GRN_HD
             SET STATUS ='X'
             WHERE SUPP_CODE =:ACCT_CD
             AND GRN_DATE =:DOC_DATE
             AND GRN_NO =:DOC_NO;
             /***Update GRN_QTY TO PO_ORDER_DT**/

             UPDATE PO_ORDER_DT
             SET GRN_QTY = GRN_QTY + :QTY
             WHERE ORDER_NO =:REF_NO
             AND ORDER_DATE = :REF_DATE
             AND ITEM_CODE =:STOCK_CD
             AND GROUP_ID =:GROUP_ID
             AND UOM =:UOM_CD;
             if (QTY >= ORDER_QTY) then
             BEGIN
             /**Update Status of Purcahse order  ot Close "O"if (recive qty cater with order qty) then**/
                UPDATE PO_ORDER_DT
                SET STATUS ='O'
                 WHERE ORDER_NO =:REF_NO
                 AND ORDER_DATE = :REF_DATE
                 AND ITEM_CODE =:STOCK_CD
                 AND GROUP_ID =:GROUP_ID
                 AND UOM =:UOM_CD;

             END
         BEGIN /**Insert into STOCK DETAIL*/
          INSERT INTO IC_MAT_STK_DT (
               STOCK_CD             ,
               GROUP_ID             ,
               UOM_CD               ,
               LOT_CD               ,
               UNIT_COST            ,
               LAST_PURCHASE_PRICE  ,
               PURCHASE_DATE        ,
               ONHAND_QTY           ,
               RESERVED_QTY         ,
               STOCK_VALUE          ,
               TOTAL_COST           ,
               ACCT_CODE            ,
               ORDER_LINE    )
               values(:STOCK_CD,
               :GROUP_ID,
               :UOM_CD,
               :REF_NO,
               :UNIT_COST,
               :UNIT_COST,
               :REF_DATE,
               :QTY,
               0,
               :STOCK_VALUE,
               :TOTAL_COST,
               :ACCT_CD,
               :ORDER_LINE);
                WHEN SQLCODE - 530 DO
                BEGIN
                    EXCEPTION EX_INS_STK_DT;
                END
           END

           INSERT INTO IC_STOCKCARD (ACCT_CD,DOC_NO,DOC_DATE,REF_NO,REF_DATE,QTY,UNIT_COST,TOTAL_COST,LOT_CD,GROUP_ID,UOM_CD,STOCK_VALUE,FMONTH,FYEAR,MODE,STOCK_CD,UPDATE_USER,UPDATE_DATE,MODULE,ORDER_LINE,DESCS,TRX_TYPE,ONHAND_QTY,RESERVED_QTY)
           VALUES (:ACCT_CD,:DOC_NO,:DOC_DATE,:REF_NO,:REF_DATE,:QTY,:UNIT_COST,:TOTAL_COST,:LOT_CD,:GROUP_ID,:UOM_CD,:STOCK_VALUE,:FMONTH,:FYEAR,:MODE,:STOCK_CD,:UPDATE_USER,:UPDATE_DATE,:MODULE,:ORDER_LINE,:DESCS,'GR',:QTY,0.00);
           WHEN SQLCODE - 530 DO
           BEGIN
             EXCEPTION EX_INS_STOCKCARD;
           END



        END /*End for*/
     END /*End if (MODULE = PO) then*/
     IF (MODULE ='PL') then
     BEGIN
         order_line =0;
         FOR
         SELECT A.DOC_NO,A.DOC_DATE,
                A.req_by,A.req_date,QTY,usaged_qty ,
                UNIT_COST,TOTAL_COST,
                LOT_NO,GROUP_ID ,UOM,
                QTY*UNIT_COST,ITEM_CODE,a.descs ,a.trx_type
         FROM  pl_req_dt  , PL_REQ_HD A
         WHERE A.DOC_NO =:DOC_NO
         AND A.DOC_DATE =:DOC_DATE
         AND IC_MODE =:MODE
         AND A.STATUS <> 'X'
         INTO :DOC_NO,:DOC_DATE,
             :REF_NO,:REF_DATE,:QTY,:usage_qty ,
             :UNIT_COST,:TOTAL_COST,
             :LOT_CD,:GROUP_ID,:UOM_CD,
             :STOCK_VALUE,:STOCK_CD,:descs,:trx_type
         DO
         BEGIN
           ACCT_CD ='PLMODULE';
           order_line = order_line +1 ;
          /*Update Posted Status*/
           UPDATE PL_REQ_HD
           SET STATUS ='X'
           WHERE DOC_NO =:DOC_NO
           AND DOC_DATE =:DOC_DATE;
           /*Update IC -ONHAND DETAIL QUANTITY*/
           if (MODE ='R') then
           BEGIN
              UPDATE IC_MAT_STK_DT
              SET ONHAND_QTY = ONHAND_QTY - :QTY /**Material Actual Stock Usage QUANTITY**/
              WHERE STOCK_CD = :STOCK_CD
              AND GROUP_ID =:GROUP_ID
              AND LOT_CD =:LOT_CD
              AND UOM_CD =:UOM_CD;
             /* QTY = USAGE_QTY;   */   /**Only Actual Qty will post to Stock card**/
           END
           if (MODE ='I') then
           BEGIN
              UPDATE IC_MAT_STK_DT
              SET ONHAND_QTY = ONHAND_QTY + :QTY /**Material Return Value**/
              WHERE STOCK_CD = :STOCK_CD
              AND GROUP_ID =:GROUP_ID
              AND LOT_CD =:LOT_CD
              AND UOM_CD =:UOM_CD;

           END
           /*******Only Good Receive Note will insert into IC MAT STK DT*****/
           BEGIN
              INSERT INTO IC_MAT_STK_DT (
               STOCK_CD  ,    GROUP_ID  ,
               UOM_CD    ,     LOT_CD    ,
               UNIT_COST ,   LAST_PURCHASE_PRICE  ,
               PURCHASE_DATE        ,   ONHAND_QTY           ,
               RESERVED_QTY         ,    STOCK_VALUE          ,
               TOTAL_COST           ,    ACCT_CODE)
               values(:STOCK_CD,
               :GROUP_ID,      :UOM_CD,
               :REF_NO,     :UNIT_COST,
               :UNIT_COST,    :REF_DATE,
               :QTY,     0, :STOCK_VALUE,
               :TOTAL_COST, :ACCT_CD);
                WHEN SQLCODE - 530 DO
                BEGIN
                    EXCEPTION EX_INS_STK_DT;
                END
           END
           if ((MODE ='I') or (MODE ='O') or (MODE ='R')) then
           BEGIN
               INSERT INTO IC_STOCKCARD (ACCT_CD,DOC_NO,DOC_DATE,REF_NO,REF_DATE,QTY,UNIT_COST,TOTAL_COST,LOT_CD,GROUP_ID,UOM_CD,STOCK_VALUE,FMONTH,FYEAR,MODE,STOCK_CD,UPDATE_USER,UPDATE_DATE,MODULE,ORDER_LINE,descs,TRX_TYPE)
               VALUES (:ACCT_CD,:DOC_NO,:DOC_DATE,:REF_NO,:REF_DATE,:QTY,:UNIT_COST,:TOTAL_COST,:LOT_CD,:GROUP_ID,:UOM_CD,:STOCK_VALUE,:FMONTH,:FYEAR,:MODE,:STOCK_CD,:UPDATE_USER,:UPDATE_DATE,:MODULE,:ORDER_LINE,:descs,:TRX_TYPE);
               WHEN SQLCODE - 530 DO
               BEGIN
                 EXCEPTION EX_INS_STOCKCARD;
               END
           END
           
           WHEN SQLCODE 0 do /*No Error Then update status to X**/
           BEGIN
              /* BEGIN UPDATE STOCK WHEN QTY IN */
              if (MODE = 'I') then
              BEGIN
                UPDATE IC_MAT_STK_DT
                SET ONHAND_QTY = ONHAND_QTY+:QTY
                WHERE STOCK_CD = :STOCK_CD
                AND   GROUP_ID = :GROUP_ID
                AND   LOT_CD   = :LOT_CD
                AND   UOM_CD   = :UOM_CD;
              END
            /* END UPDATE STOCK WHEN QTY IN */

              /* BEGIN UPDATE STOCK WHEN QTY OUT */
              if (MODE = 'O') then
              BEGIN

                UPDATE IC_MAT_STK_DT
                SET ONHAND_QTY = ONHAND_QTY - :QTY
                WHERE STOCK_CD = :STOCK_CD
                AND   GROUP_ID = :GROUP_ID
                AND   LOT_CD   = :LOT_CD
                AND   UOM_CD   = :UOM_CD;

                UPDATE IC_MAT_STK_DT
                SET RESERVED_QTY = RESERVED_QTY - :QTY
                WHERE STOCK_CD = :STOCK_CD
                AND   GROUP_ID = :GROUP_ID
                AND   LOT_CD   = :LOT_CD
                AND   UOM_CD   = :UOM_CD;

              END
            /* END UPDATE STOCK WHEN QTY OUT */

              UPDATE PL_REQ_HD
              SET STATUS ='X'
              WHERE DOC_NO =:DOC_NO
              AND DOC_DATE =:DOC_DATE;

           END /* END WHEN INSERT STOCK CARD NO ERROR */

       
         END
     END /**MODULE PL*/

  END

  SUSPEND;
END^


ALTER PROCEDURE X_IS_PREV_MELT_POSTED (
    APLAN_DOC VARCHAR(15),
    APLAN_DATE TIMESTAMP,
    AMELT_NO VARCHAR(10))
RETURNS (
    RESULT VARCHAR(3))
AS
DECLARE VARIABLE CURRENT_MELT_LINE SMALLINT;
DECLARE VARIABLE PREV_MELT_NO VARCHAR(10);
DECLARE VARIABLE ROWSNUM SMALLINT;
declare variable MIN_LINE SMALLINT;
begin
  /* Procedure Text */
    RESULT ='NO';
    prev_melt_no ='';
    ROWSNUM = 0;
    SELECT MIN(LINE_NO)
    FROM PL_PRO_PLAN_DT
    WHERE PLAN_DOC =:APLAN_DOC
    AND PLAN_DATE =:APLAN_DATE
    INTO :MIN_LINE;

   SELECT MAX(LINE_NO)
   FROM PL_PRO_PLAN_DT
   WHERE PLAN_DOC =:APLAN_DOC
   AND PLAN_DATE =:APLAN_DATE
   AND MELT_NO = :AMELT_NO
   INTO :current_melt_line ;
   /**Check if is the fist line of the plan*/
   if (MIN_LINE =current_melt_line ) then
   BEGIN
    RESULT = 'YES';

   END
   if (current_melt_line <=0) then
   BEGIN
     result = 'NO'  ;
   END
   if (current_melt_line =1) then
   BEGIN
      result = 'YES'  ;

   END
   if (current_melt_line >1) then
   BEGIN
         select max(melt_no)
         FROM PL_PRO_PLAN_DT
         WHERE PLAN_DOC =:APLAN_DOC
         AND PLAN_DATE =:APLAN_DATE
         and line_no < :current_melt_line
         into :prev_melt_no;
         if (prev_melt_no IS NOT NULL) then
         begin
           select count(*) from
           ic_stockcard where melt_no = :prev_melt_no
           into :ROWSNUM;
          if ( ROWSNUM > 0) then
            begin
                result = 'YES';
            end
         end

   END

   suspend;

end^


ALTER PROCEDURE X_MONTHLY_CLOSE (
    AYEAR SMALLINT,
    AMONTH SMALLINT,
    AUSERID VARCHAR(15))
AS
DECLARE VARIABLE PIOR_YEAR SMALLINT; /* PRIOR YEAR PERIOD */
DECLARE VARIABLE PIOR_MONTH SMALLINT; /* PRIOR MONTH PERIOD */
DECLARE VARIABLE STOCK_CD VARCHAR(15);
DECLARE VARIABLE GROUP_ID VARCHAR(10);
DECLARE VARIABLE UOM_CD VARCHAR(2);
DECLARE VARIABLE LOT_CD VARCHAR(15);
DECLARE VARIABLE PURCHASE_DATE TIMESTAMP;
DECLARE VARIABLE UNIT_COST FLOAT;
DECLARE VARIABLE ONHAND_QTY FLOAT;
DECLARE VARIABLE STOCK_VALUE FLOAT;
DECLARE VARIABLE ACCT_CODE VARCHAR(10);
DECLARE VARIABLE ORDER_LINE SMALLINT;
DECLARE VARIABLE REF_NO VARCHAR(15);
DECLARE VARIABLE REF_DATE TIMESTAMP;
DECLARE VARIABLE DOC_DATE TIMESTAMP;
DECLARE VARIABLE SUCCESS SMALLINT;
DECLARE VARIABLE ROWSNUM SMALLINT;
declare variable upd_cost float;
begin
    /*1.select balance forward from previouse month
    amonth = amonth -1 from ic_stockbalance_forward*/
  /* Procedure Text */
  /*set success to false*/
  success = 0;
  ROWSNUM = 0;
  SELECT COUNT(*) FROM ic_monthly_closed
  WHERE BF_YEAR = :AYEAR AND BF_MONTH = :AMONTH
  INTO :ROWSNUM ;
  if (ROWSNUM > 0 ) then
  BEGIN
    exception e_monthly_close;
    exit;
  END
  else if (ROWSNUM = 0) then
  begin
      /*delete exist temp data*/
      delete from temp_balance_forward
      where bf_year     = :ayear
      and bf_month      = :amonth;
      /*delete exist temp data*/
      /*GET LAST DATE OF MONTH*/
          select  LASTDAYMONTH(CAST( CAST( :AMONTH AS VARCHAR(2)) ||'/' || CAST('2' AS VARCHAR(2))
         ||'/'||CAST(:AYEAR AS VARCHAR(4)) AS TIMESTAMP))
          from rdb$database INTO :DOC_DATE ;
       /*GET LAST DATE OF MONTH*/
     --  select  DOC_DATE  from rdb$database   ;
      if (amonth = 1) then
      begin
        pior_year   =  :AYEAR -1 ;
        pior_month  =  12  ;
      end
      else if (amonth > 1) then
      begin
        pior_year  = :ayear ;
        pior_month = :amonth - 1 ;
      end

      /*select previous month stock*/
        /*############################################################*/
        /*select current month stock */
        begin
            INSERT INTO TEMP_BALANCE_FORWARD (
            STOCK_CD,    GROUP_ID,
            UOM_CD,      LOT_CD,
            UNIT_COST,    LAST_PURCHASE_PRICE,
            PURCHASE_DATE,    ONHAND_QTY,
            STOCK_VALUE,      TOTAL_COST,
            ACCT_CODE,        ORDER_LINE,
            REF_NO,           REF_DATE,
            BF_YEAR,          BF_MONTH,
            DOC_DATE)
               
          SELECT st.STOCK_CD,st.GROUP_ID,st.UOM_CD,
          st.LOT_CD AS PCNO, MAX(st.UNIT_COST) AS UNIT_COST,MAX(st.UNIT_COST) AS purchase_price,
                    st.PURCHASE_DATE,SUM(st.QTY) AS ONHANDQTY ,0,0,max(st.acct_cd),max(st.ORDER_LINE)  ,
            st.REF_NO AS GRNNO,st.REF_DATE AS GRN_DATE,  :AYEAR,  :AMONTH,:DOC_DATE
            FROM   ic_stockcard st , ic_mat_stk_hd hd
          where (ST.doc_date <= :DOC_DATE )
          and st.stock_cd = hd.stock_cd
          and st.group_id = hd.group_id
          and st.uom_cd = hd.uom_cd
          and hd.consumeable_item = 'N'
           AND ST.GROUP_ID NOT IN ('SG009','SG008')
            AND ST.PURCHASE_DATE >= '01/01/2006'
             GROUP BY ST.STOCK_CD,ST.GROUP_ID,ST.UOM_CD,ST.LOT_CD,ST.PURCHASE_DATE,ST.ACCT_CD,
            ST.REF_NO,ST.REF_DATE     HAVING SUM(QTY) > 0 ;
        end
        /*select current month stock */
        /*process balance forward of spacific month*/
       for select STOCK_CD,    GROUP_ID,
            UOM_CD,      LOT_CD,    PURCHASE_DATE,
            REF_NO,           REF_DATE,acct_code,order_line,unit_cost,
            ONHAND_QTY
            from TEMP_BALANCE_FORWARD
            where bf_year = :ayear
            and bf_month = :amonth
            into :stock_cd , :group_id ,
            :uom_cd,    :lot_cd, :purchase_date,
            :ref_no , :ref_date,  :ACCT_CODE ,:ORDER_LINE,:UNIT_COST ,
            :onhand_qty
        do
        begin

           select max(unit_cost)
           from ic_mat_stk_dt_link
           where stock_cd =:stock_cd
           and group_id = :group_id
           and lot_cd = :lot_cd
           and purchase_date = :purchase_date
           and ref_no = :ref_no
           and ref_date = :ref_date
           into :upd_cost;
           if (:upd_cost > 0) then
           begin
           unit_cost = :upd_cost ;
           end
           stock_value = :onhand_qty * :unit_cost ;
             /*recal stock value*/
          /*finally insert current balance forward stock*/
           INSERT INTO ic_BALANCE_FORWARD (
            STOCK_CD,    GROUP_ID,
            UOM_CD,      LOT_CD,
            UNIT_COST,    LAST_PURCHASE_PRICE,
            PURCHASE_DATE,    ONHAND_QTY,reserved_qty,
            STOCK_VALUE,      TOTAL_COST,
            ACCT_CODE,        ORDER_LINE,
            REF_NO,           REF_DATE,
            BF_YEAR,          BF_MONTH,
            DOC_DATE)
            values (:stock_cd ,:group_id,
            :uom_cd , :lot_cd,
            :unit_cost , :unit_cost,
            :purchase_date , :onhand_qty,0,
            :stock_value ,:stock_value,
            :acct_code ,:order_line,
            :ref_no , :ref_date,
            :ayear , :amonth,
            :doc_date) ;

            success = 1;

        end  /*do*/
        /*finally insert current balance forward stock*/
        /*process balance forward of spacific month*/
    
        /*if every thing is success*/
        if (success = 1) then
        begin
          insert into ic_monthly_closed
          values(:ayear,:amonth,current_timestamp,:auserid)  ;
        end
  end /*if row =0*/
  suspend;
end^


ALTER PROCEDURE X_PATCH_QA_INSPECT_DATA
AS
 DECLARE VARIABLE LOT_CD VARCHAR(15);
 DECLARE VARIABLE PURCHASE_DATE TIMESTAMP;
 DECLARE VARIABLE REF_NO VARCHAR(15);
 DECLARE VARIABLE REF_DATE TIMESTAMP;
 DECLARE VARIABLE STOCK_CD VARCHAR(25);

 DECLARE VARIABLE ROWSNUM SMALLINT;
begin
 FOR SELECT  lot_cd ,purchase_date,ref_no,ref_date,stock_cd from ic_mat_stk_dt_link
where onhand_qty >0
AND group_id not in ('SG008','SG009')
group by lot_cd ,purchase_date,ref_no,ref_date,stock_cd,group_id   ,acct_code
INTO    :LOT_CD,:PURCHASE_DATE ,:REF_NO,:REF_DATE,:STOCK_CD
  DO
  BEGIN
    SELECT COUNT(*) FROM ic_mat_element
    WHERE LOT_CD = :LOT_CD
    AND PURCHASE_DATE =:PURCHASE_DATE INTO :ROWSNUM;
    IF (ROWSNUM >0) THEN
    BEGIN
      UPDATE ic_mat_element
      SET REF_NO =:rEF_NO,
      REF_DATE =:REF_DATE
      WHERE LOT_CD = :LOT_CD
    AND PURCHASE_DATE =:PURCHASE_DATE  ;
    END else
    BEGIN
      INSERT INTO IC_MAT_ELEMENT (
    STOCK_CD,
    GROUP_ID,
    UOM_CD,
    LOT_CD,
    PURCHASE_DATE,
    ELE1_PERC,
    ELE2_PERC,
    ELE3_PERC,
    ELE4_PERC,
    ELE5_PERC,
    ELE6_PERC,
    ELE7_PERC,
    ELE8_PERC,
    ELE9_PERC,
    ELE10_PERC,
    ELE11_PERC,
    ELE12_PERC,
    ELE13_PERC,
    ACCT_CD,
    REF_NO,
    REF_DATE,
    LINE_NO)
     SELECT STOCK_CD,GROUP_ID,UOM_CD,LOT_CD,PURCHASE_DATE,
     0,0,0,0,0,0,0,0,0,0,0,0,0,ACCT_CODE,REF_NO,REF_DATE ,

     (SELECT GEN_ID(mygenerator,1) FROM RDB$DATABASE)
     FROM   ic_mat_stk_dt_link
     WHERE LOT_CD = :LOT_CD
    AND PURCHASE_DATE =:PURCHASE_DATE 
    AND REF_NO =:REF_NO
    AND REF_DATE =:REF_DATE ;

    END

  END


  suspend;
end^


ALTER PROCEDURE "x_patch_zero_unitcost_card"
AS
DECLARE VARIABLE DOCNO VARCHAR(15);
DECLARE VARIABLE LOTNO VARCHAR(15);
DECLARE VARIABLE REFNO VARCHAR(15);
DECLARE VARIABLE UNITCOST FLOAT;
begin
for select doc_no,lot_cd,ref_no from ic_stockcard
where  DESCS LIKE '%Stock Adjustment%'
and mode ='O'
AND UNIT_COST =0
AND PURCHASE_DATE >'1/1/2006'

into :docNo, :lotNo,:refNo
do
begin
   select max(unit_cost)
   from ic_mat_stk_dt_link
   where lot_cd =:lotNo
   and ref_No =:refNo
   into :unitCost ;
   if (unitCost >0) then
   begin
     update ic_stockcard
     set unit_cost =:unitCost
     where doc_NO =:DOCno
     and lot_cd =:lotNo
     and ref_No =:refNo
     and   DESCS LIKE '%Stock Adjustment%'
     and mode ='O'
     and unit_cost =0   ;
   end
  --suspend;
end
suspend;
end^


ALTER PROCEDURE X_PL_GET_MELT (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AMELT_SUFFIX VARCHAR(4),
    ACAP FLOAT,
    ASTART_MELT SMALLINT,
    ATOTAL_MELT SMALLINT)
AS
DECLARE VARIABLE LINENO SMALLINT;
DECLARE VARIABLE TOTALMELT SMALLINT;
DECLARE VARIABLE MELTNO VARCHAR(10);
DECLARE VARIABLE ORDERQTY FLOAT;
DECLARE VARIABLE ESTIMATEWEIGHT FLOAT;
DECLARE VARIABLE CUSTCODE VARCHAR(10);
DECLARE VARIABLE ITEMCODE VARCHAR(15);
DECLARE VARIABLE ORDERNO VARCHAR(15);
DECLARE VARIABLE ORDERDATE TIMESTAMP;
DECLARE VARIABLE UOM VARCHAR(4);
DECLARE VARIABLE ITEMDESCS VARCHAR(60);
DECLARE VARIABLE CUSTNAME VARCHAR(60);
begin
  /* Procedure Text */
        lineno =   :ASTART_MELT;
        ACAP = 15000;

        DELETE FROM pl_pro_plan_dt WHERE PLAN_DOC =:ADOC_NO;
        TOTALMELT = 0;

  FOR SELECT SO_ORDER_HD.CUST_CODE,
  SO_ORDER_HD.name,
  SO_ORDER_HD.ORDER_NO,
  SO_ORDER_HD.ORDER_DATE,
  SO_ORDER_DT.ITEM_CODE,
   SO_ORDER_DT.item_descs,
  SO_ORDER_DT.UOM,

  SO_ORDER_DT.QTY
    FROM SO_ORDER_HD
   INNER JOIN SO_ORDER_DT ON (SO_ORDER_HD.ORDER_NO = SO_ORDER_DT.ORDER_NO) AND (SO_ORDER_HD.ORDER_DATE = SO_ORDER_DT.ORDER_DATE) AND (SO_ORDER_HD.CUST_CODE = SO_ORDER_DT.CUST_CODE)
WHERE 
   (
      (SO_ORDER_HD.STATUS = 'A')
   )
   ORDER BY SO_ORDER_HD.ORDER_DATE, SO_ORDER_HD.update_date
   into :CUSTCODE,:CUSTNAME,:ORDERNO,:ORDERDATE,:ITEMCODE,:ITEMDESCS,:UOM, :ORDERQTY
   DO
   BEGIN

        estimateweight =  :ORDERQTY;


      while (ESTIMATEWEIGHT >= :ACAP) do
         begin
            estimateweight  = :ESTIMATEWEIGHT - :acap;
            IF  (estimateweight >0 )THEN
            BEGIN

           IF (LINENO < 10 )then
           BEGIN
             MELTNO ='0'||:LINENO||:amelt_suffix ;
           END ELSE
           BEGIN
              MELTNO =:LINENO||:amelt_suffix;
           END
            INSERT INTO PL_PRO_PLAN_DT (
            PLAN_DATE,    PLAN_DOC,    TRX_TYPE,
            ITEM_CODE,    ORDER_NO,    CUST_CODE,
            ORDER_DATE,    SCHEDULE_DATE,    STATUS,
            LINE_NO,     MELT_NO,     CAL_TO_TIME,
            FOR_TIME,    REMARKS,    ESTIMATED_WEIGHT,
            STIME,    ATTIME,    PRIOR_ATIME,
            PRIOR_STIME,    PRIOR_FOR_TIME,    STOCK_FLAG,
            STOCK_ITEM_CODE,    CUST_NAME,    ITEM_DESCS,
            END_MELT_FLAG,  UOM_CD   )
        
           values (:adoc_date,:adoc_no,'PL',:itemcode, :orderno,:custcode, :ORDERDATE,
           :orderdate, 'P',
           :lineno, :MELTNO,NULL, '10:00:00',' ',:acap,
            NULL,NULL,NULL,null, NULL,'N',:itemcode,:custname,:itemdescs,'N',:UOM);
           END
             LINENO =:LINENO +1;
         end

      /*else
      begin
           IF (LINENO < 10 )then
           BEGIN
             MELTNO =CAST ('0'||:LINENO||:amelt_suffix  AS VARCHAR(10));
           END ELSE
           BEGIN
              MELTNO =CAST(:LINENO||:amelt_suffix  AS VARCHAR(10));
          END
         INSERT INTO PL_PRO_PLAN_DT (
            PLAN_DATE,    PLAN_DOC,    TRX_TYPE,
            ITEM_CODE,    ORDER_NO,    CUST_CODE,
            ORDER_DATE,    SCHEDULE_DATE,    STATUS,
            LINE_NO,     MELT_NO,     CAL_TO_TIME,
            FOR_TIME,    REMARKS,    ESTIMATED_WEIGHT,
            STIME,    ATTIME,    PRIOR_ATIME,
            PRIOR_STIME,    PRIOR_FOR_TIME,    STOCK_FLAG,
            STOCK_ITEM_CODE,    CUST_NAME,    ITEM_DESCS,
            END_MELT_FLAG,  UOM_CD   )
        
           values (:adoc_date,:adoc_no,'PL',:itemcode, :orderno,:custcode, :ORDERDATE,
           :orderdate, 'P',
           :lineno, :MELTNO,NULL, '10:00:00',' ',:ORDERQTY,
            NULL,NULL,NULL,null, NULL,'N',:itemcode,:custname,:itemdescs,'N',:UOM);
            LINENO = :LINENO +1;

      end   */




   END

end^


ALTER PROCEDURE X_PLAN_CLOSE (
    PLAN_DOC VARCHAR(15),
    PLAN_DATE TIMESTAMP)
AS
declare variable row1 smallint;
begin
  SELECT COUNT(*)
  FROM pl_pro_plan_dt
  WHERE PLAN_DOC =:PLAN_DOC
  AND PLAN_DATE =:PLAN_DATE
  AND STATUS ='N'
  INTO ROW1;
  if (row1 >0) then
  begin
     exception e_close_plan;
  end
  else
  begin
     update pl_pro_plan_hd
     set status ='X'
     WHERE PLAN_DOC =:PLAN_DOC
     AND PLAN_DATE =:PLAN_DATE
     AND STATUS ='P';
  end
  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_PO_AUTOMATIC_CLOSE (
    ADAYS SMALLINT)
AS
begin

  update po_order_hd
  set status ='O' --Set to close
  where status ='A'
  and order_date < current_date - :adays ;


  
  update po_order_dt
  set status ='O' --Set to close
  where status ='A'
  and order_date < current_date - :adays ;
  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_PO_ORDER_STATUS (
    SUPP_CODE VARCHAR(10),
    ORDER_NO VARCHAR(15),
    ORDER_DATE TIMESTAMP,
    STATUS VARCHAR(1))
AS
declare variable ROWSNUM smallint;
begin
  select count(*)
  from po_order_hd , po_order_dt
  where po_order_dt.supp_code = po_order_dt.supp_code
  and po_order_dt.order_no = po_order_hd.order_no
  and po_order_dt.order_date = po_order_hd.order_date
  and po_order_hd.status  in ( 'N','A')
  into :ROWSNUM;

  if (ROWSNUM <= 0) then
  begin
     exception e_no_row;
  end
  else

  begin
    UPDATE PO_ORDER_HD
    SET STATUS = :STATUS
    WHERE SUPP_CODE =:SUPP_CODE
    AND ORDER_NO = :ORDER_NO
    AND ORDER_DATE = :ORDER_DATE;

    UPDATE PO_ORDER_DT
    SET STATUS = :STATUS
    WHERE SUPP_CODE =:SUPP_CODE
    AND ORDER_NO = :ORDER_NO
    AND ORDER_DATE = :ORDER_DATE;
  
    /* Procedure Text */
  END
  suspend;
end^


ALTER PROCEDURE X_PO_UPD_STOCK_EMPTY
AS
DECLARE VARIABLE PURCHASE_NO VARCHAR(15);
DECLARE VARIABLE PURCHASE_DATE TIMESTAMP;
declare variable ITEM_CODE VARCHAR(15);
BEGIN
  FOR SELECT STOCK_CD,LOT_CD ,PURCHASE_DATE
  FROM ic_mat_stk_dt
  WHERE ONHAND_QTY <=0
  INTO :ITEM_CODE,:PURCHASE_NO,:purchase_date
  DO
  BEGIN
    UPDATE PO_ORDER_HD
    SET STOCK_EMPTY ='Y'
    WHERE ORDER_NO =:PURCHASE_NO
    AND ORDER_DATE =:PURCHASE_DATE
    AND STOCK_EMPTY='N' ;

    UPDATE PO_ORDER_DT
    SET STOCK_EMPTY ='Y'
    WHERE ORDER_NO =:PURCHASE_NO
    AND ORDER_DATE =:PURCHASE_DATE
    AND ITEM_CODE =:item_code
    AND STOCK_EMPTY='N'  ;

  END

  SUSPEND;
END^


ALTER PROCEDURE X_PO_UPDATE_GRN_QTY (
    ASUPP_CODE VARCHAR(10),
    AORDER_NO VARCHAR(15),
    AORDER_DATE TIMESTAMP)
AS
declare variable supp_code varchar(10);
declare variable order_no varchar(15);
declare variable order_date timestamp;
declare variable item_code varchar(10);
declare variable grn_qty float;
declare variable order_qty float;
declare variable markup_qty float;
declare variable status varchar(1);
declare variable markup_rate smallint;
declare variable status_detail_count smallint;
begin
   STATUS ='O';
  for select d.supp_code,d.order_no,d.order_date,d.item_code ,d.mark_up,d.order_qty
  from po_grn_hd h , po_grn_dt d
  where h.supp_code = d.supp_code
  and h.grn_no = d.grn_no
  and h.grn_date = d.grn_date
/*  and d.supp_code =:asupp_code
  and d.order_no =:aorder_no
  and d.order_date =:aorder_date*/
  order by d.order_date
  into :supp_code,:order_no,:order_date,:item_code  ,:markup_rate,:order_qty
  do
  begin
    if (order_qty >0) then
    begin
           if (markup_rate is null) then
           begin
              markup_rate =10;
           end
           select sum(grn_qty)
           from po_grn_hd h , po_grn_dt d
           where h.supp_code = d.supp_code
           and h.grn_no = d.grn_no
           and h.grn_date = d.grn_date
           and d.order_no =  :order_no
           and d.order_date =:order_date
           and d.supp_code =:supp_code
           into :grn_qty;
           if (grn_qty is null ) then   grn_qty =0;
        
           markup_qty = (order_qty * markup_rate/100) ;
           if (MARKUP_QTY IS NULL) then MARKUP_QTY =0;
           if (grn_qty > 0) then
           begin
              update po_order_dt
              set grn_qty =:grn_qty
              where supp_code =:supp_code
              and order_no =:order_no
              and order_date =:order_date
              and item_code =:item_code;
              if ((grn_qty >= (order_qty - markup_qty) ) AND (grn_qty <=(order_qty + markup_qty)) )then
              begin

                 update po_order_dt
                 set status ='O'
                 where order_no =:order_no
                 and supp_code =:supp_code
                 and order_date =:order_date
                 and item_code =:item_code;


              end
              ELSE
              BEGIN
              update po_order_dt
                 set status ='A'
                 where order_no =:order_no
                 and supp_code =:supp_code
                 and order_date =:order_date
                 and item_code =:item_code;

              END
              /**FINALLY UPDATE HEADER STATUS*/
              begin
                 select count(*)
                 from po_order_dt
                 where order_no =:order_no
                 and supp_code =:supp_code
                 and order_date =:order_date
                 and status ='A'
                 into :status_detail_count;
                 if (status_detail_count=0) then
                 begin
                    update po_order_hd
                    set status ='O'
                    where order_no =:order_no
                    and supp_code =:supp_code
                    and order_date =:order_date;
    
    
                 end
                 else
                 begin
                   update po_order_hd
                    set status ='A'
                    where order_no =:order_no
                    and supp_code =:supp_code
                    and order_date =:order_date;
                 end
              END

 
           end
    end

  end

  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_POST_DET (
    VDOC_NO VARCHAR(15),
    VDOC_DATE DATE,
    VCUST_CODE VARCHAR(10))
AS
declare variable DOC_NO varchar(15);
declare variable DOC_DATE timestamp;
declare variable REF_NO varchar(15);
declare variable REF_DATE timestamp;
declare variable DESCS varchar(60);
declare variable UPDATE_USER varchar(10);
declare variable UPDATE_DATE timestamp;
declare variable CUST_CODE varchar(10);
declare variable ITEM_CODE varchar(15);
declare variable QTY float;
declare variable UNIT_COST float;
declare variable TOTAL_AMT float;
declare variable TAX_AMT float;
declare variable TAX_CD varchar(2);
declare variable LINE_NO integer;
declare variable DESCS1 varchar(60);
declare variable UOM_CD varchar(4);
declare variable MODE varchar(1);
declare variable MELT_NO varchar(10);
declare variable ORDER_NO varchar(15);
declare variable ORDER_DATE timestamp;
declare variable ORDER_QTY float;
declare variable ONHAND_QTY float;
declare variable BUNDLE_QTY integer;
declare variable ROWCOUNT integer;
declare variable DET_QTY float;
declare variable MARKUP_RATE smallint;
declare variable MARKUP_QTY float;
declare variable ORDER_ROW smallint;
begin
  select count(*)
  FROM SO_DET_DT D, SO_DET_HD H
  WHERE D.DELIVERY_NO = H.DELIVERY_NO
     AND D.DELIVERY_DATE = H.DELIVERY_DATE
     AND D.CUST_CODE = H.CUST_CODE
     AND H.STATUS <> 'X'
     AND D.DELIVERY_NO = :VDOC_NO
     AND D.DELIVERY_DATE = :VDOC_DATE
     AND D.CUST_CODE = :VCUST_CODE
  into :rowcount;
  if(rowcount >= 1) then
  begin

      BEGIN
      MODE ='O';
      SELECT DELIVERY_NO,DELIVERY_DATE,CUST_CODE,UPDATE_USER,
                 UPDATE_DATE,REF_NO,REF_DATE,DESCS
          FROM SO_DET_HD
          WHERE  DELIVERY_NO = :VDOC_NO
             AND DELIVERY_DATE = :VDOC_DATE
             AND CUST_CODE = :VCUST_CODE
    
          INTO   :DOC_NO,:DOC_DATE,:CUST_CODE,:UPDATE_USER,:UPDATE_DATE,
                 :REF_NO,:REF_DATE,:DESCS1;
    
          INSERT INTO SO_INVOICE_HD (DOC_NO,DOC_DATE,DESCS,TAX_INV_NO,CUST_CODE,DOC_AMT,REF_NO,REF_DATE,STATUS,UPDATE_USER,UPDATE_DATE,TAX_INV_DATE)
          VALUES (:DOC_NO,:DOC_DATE,:DESCS1,'',:CUST_CODE,0.00,:REF_NO,:REF_DATE,'N',:UPDATE_USER,:UPDATE_DATE,:DOC_DATE);
      END
      /*FETCH FROM SO DET HD TO SO INVOICE HD*/
    
    
      LINE_NO = 0;
      FOR    SELECT D.DELIVERY_NO,D.ORDER_NO,D.ORDER_DATE,D.ITEM_CODE,MAX(D.DESCS),D.DELIVERY_DATE,D.CUST_CODE,
      SUM(D.DET_QTY),MAX(D.UNIT_COST),SUM(D.TOTAL_AMT),SUM(D.TAX_AMT),MAX(D.TAX_CD),MAX(D.UOM),D.MELT_NO ,count(D.BUNDLE_NO),max(mark_up)
          FROM SO_DET_DT D, SO_DET_HD H
          WHERE D.DELIVERY_NO = H.DELIVERY_NO
            AND D.DELIVERY_DATE = H.DELIVERY_DATE
            AND D.CUST_CODE = H.CUST_CODE
            AND H.STATUS <> 'X'
            AND D.DELIVERY_NO = :VDOC_NO
            AND D.DELIVERY_DATE = :VDOC_DATE
            AND D.CUST_CODE = :VCUST_CODE
      GROUP BY  D.DELIVERY_NO, D.ORDER_NO,D.ORDER_DATE,D.ITEM_CODE,D.DELIVERY_DATE,D.CUST_CODE,D.MELT_NO
    
    
          INTO :DOC_NO, :ORDER_NO,:ORDER_DATE,:ITEM_CODE,:DESCS,:DOC_DATE, :CUST_CODE,
          :QTY, :UNIT_COST, :TOTAL_AMT,:TAX_AMT,:TAX_CD,:UOM_CD,:MELT_NO, :BUNDLE_QTY,:markup_rate
      DO
      BEGIN
          LINE_NO = LINE_NO+1;
          if (markup_rate is null ) then markup_rate =5;
          det_qty =qty;
          SELECT SUM(ONHAND_QTY)   /*SELECT SUM TO AVOID MULTIPLE ROW SELECT IN SINGLETON*/
          FROM SO_SALES_ITEM_STOCK
          WHERE ITEM_CODE =:ITEM_CODE
          AND   MELT_NO =:MELT_NO
          AND   UOM_CD =:UOM_CD

          INTO :ONHAND_QTY;
         /* if (ONHAND_QTY > QTY) then
          BEGIN  */
    
              BEGIN
                INSERT INTO SO_INVOICE_DT (DOC_NO,DOC_DATE,ORDER_NO,ORDER_DATE,ITEM_CODE,CUST_CODE,LINE_NO,ITEM_DESCS,QTY,UNIT_COST,TOTAL_AMT,BASE_AMT,TAX_AMT,DISCS_AMT,TAX_CD,DISCS_CD,MELT_NO)
                VALUES (:DOC_NO,:DOC_DATE,:ORDER_NO,:ORDER_DATE,:ITEM_CODE,:CUST_CODE,:LINE_NO,:DESCS,:QTY,:UNIT_COST,:TOTAL_AMT,:QTY*:UNIT_COST,:TAX_AMT,0.00,:TAX_CD,'',:MELT_NO);
        
        
                INSERT INTO SO_LEDGER (DOC_NO,DOC_DATE,ORDER_NO,ORDER_DATE,REF_NO,REF_DATE,ITEM_CODE,CUST_CODE,LINE_NO,DESCS,QTY,UNIT_COST,TOTAL_AMT,BASE_AMT,TAX_AMT,DISCS_AMT,TAX_CD,DISCS_CD,UOM_CD,MODE,MELT_NO,ONHAND_QTY,BUNDLE_QTY)
                VALUES (:DOC_NO,:DOC_DATE,:ORDER_NO,:ORDER_DATE,:REF_NO,:REF_DATE,:ITEM_CODE,:CUST_CODE,:LINE_NO,:DESCS1,:QTY*(-1),:UNIT_COST,:TOTAL_AMT,:QTY*:UNIT_COST,:TAX_AMT,0.00,:TAX_CD,'',:UOM_CD,:MODE,:MELT_NO,:ONHAND_QTY,-:BUNDLE_QTY);
              END
    
    

              BEGIN
                UPDATE SO_SALES_ITEM_STOCK
                SET ONHAND_QTY = ONHAND_QTY -:QTY ,
                    RESERVED_QTY =RESERVED_QTY -:QTY,
                    BUNDLE_QTY = BUNDLE_QTY -:BUNDLE_QTY
                WHERE ITEM_CODE =:ITEM_CODE
                 AND   MELT_NO =:MELT_NO
                 AND   UOM_CD =:UOM_CD;
              END
              BEGIN
                 SELECT sum(QTY) FROM SO_ORDER_DT
                 WHERE ORDER_NO =:ORDER_NO
                 AND ORDER_DATE =:ORDER_DATE
                 AND CUST_CODE =:CUST_CODE
                 AND ITEM_CODE =:ITEM_CODE
                 AND STATUS ='A'
                 INTO :ORDER_QTY;
                 markup_qty = (order_qty*markup_rate)/100;
            
                 UPDATE SO_ORDER_DT
                 SET DET_QTY =DET_QTY + :QTY
                 WHERE ORDER_NO =:ORDER_NO
                 AND ORDER_DATE =:ORDER_DATE
                 AND CUST_CODE =:CUST_CODE
                 AND ITEM_CODE =:ITEM_CODE
                 AND STATUS ='A' ;


                 select sum(det_qty)
                 FROM SO_ORDER_DT
                 WHERE ORDER_NO =:ORDER_NO
                 AND ORDER_DATE =:ORDER_DATE
                 AND CUST_CODE =:CUST_CODE
                 AND ITEM_CODE =:ITEM_CODE
                 AND STATUS ='A'
                 into:det_qty;

                 if ((det_QTY >= order_qty - markup_qty) and (det_qty <=order_qty + markup_qty)) then
                 BEGIN
                     /**Close Sale Order When order qty = det_qty*/
                     UPDATE SO_ORDER_DT
                     SET STATUS ='O' /*Change status from c to o prevoiusly c is wrong*/
                     WHERE ORDER_NO =:ORDER_NO
                     AND ORDER_DATE =:ORDER_DATE
                     AND CUST_CODE =:CUST_CODE
                     AND ITEM_CODE =:ITEM_CODE
                     AND STATUS ='A' ;

                     SELECT COUNT(*)
                     FROM SO_ORDER_DT
                     WHERE ORDER_NO =:ORDER_NO
                     AND ORDER_DATE =:ORDER_DATE
                     AND CUST_CODE =:CUST_CODE
                 /*    AND ITEM_CODE =:ITEM_CODE*/ /*STATUS OF SO_ORDER_HD WILL BE WRONG IF CHECK FOR ITEM 200041126*/
                     AND STATUS ='A'
                     INTO:ORDER_ROW;
                     /*UPDATE HEADER STATUS if (THERE ARE NO DETAIL ROW ACTIVE AS 'A') then*/
                     if (ORDER_ROW =0) then
                     BEGIN
                       UPDATE SO_ORDER_HD
                       SET STATUS ='O'/*Change status from c to o prevoiusly c is wrong*/
                        WHERE ORDER_NO =:ORDER_NO
                       AND ORDER_DATE =:ORDER_DATE
                       AND CUST_CODE =:CUST_CODE;
                     END
                     /**27 Dec,2010 also delete from order rev**/
                     DELETE FROM so_order_revision_dt
                     WHERE ORDER_NO =:ORDER_NO
                     AND ORDER_DATE =:ORDER_DATE
                     AND CUST_CODE =:CUST_CODE
                     AND ITEM_CODE =:ITEM_CODE    ;
                END

              END
              BEGIN
                  UPDATE SO_DET_HD
                  SET STATUS = 'X'
                  WHERE DELIVERY_NO = :VDOC_NO
                  AND   DELIVERY_DATE = :VDOC_DATE
                  AND   CUST_CODE = :VCUST_CODE;
              END
              BEGIN
                DELETE FROM so_det_dt_link
                 WHERE DELIVERY_NO = :VDOC_NO
                  AND   DELIVERY_DATE = :VDOC_DATE  ;

              END


    /*      END
          if (ONHAND_QTY < QTY) then
          BEGIN
              EXCEPTION ex_sales_stock;
          END */
      END
      /*UPDATE STATUS ON SO DELIVERY HD*/
  end
  else
  begin
     exception e_no_row;
     exit;
  end
  suspend;
end^


ALTER PROCEDURE X_POST_DROSS_RECEIVE (
    AMELT_NO VARCHAR(10),
    ARECEIVE_DOC VARCHAR(15),
    AUSERID VARCHAR(10))
AS
DECLARE VARIABLE ROWSNUM SMALLINT;
DECLARE VARIABLE CHECKBALANCEEXIST SMALLINT;
DECLARE VARIABLE BALANCEONHANDQTY FLOAT;
DECLARE VARIABLE DROSSTYPE SMALLINT;
begin
  ROWSNUM =0;
  checkBalanceExist =0;
  select count(*)
  FROM  PL_DROSS_HD H , pl_dross_dt D
    WHERE H.melt_no =D.MELT_NO
    AND H.receive_doc = D.receive_doc
    AND H.receive_date = D.receive_date
    and h.melt_no =:amelt_no
    and h.receive_doc =:areceive_doc
    AND H.status ='N' into :ROWSNUM ;
   if (ROWSNUM > 0) then
   begin
   BEGIN
    INSERT INTO PL_DROSS_LEDGER (
    MELT_NO,
    DROSS_TYPE,
    QTY,
    TRX_DATE,
    DESCS,
    TRX_NO,
    UPDATE_USER,
    UPDATE_DATE)
    SELECT H.melt_no,D.dross_type,
    D.net_weight,D.receive_date,
    D.descs,
    D.receive_doc,:auserid,current_timestamp
    FROM  PL_DROSS_HD H , pl_dross_dt D
    WHERE H.melt_no =D.MELT_NO
    AND H.receive_doc = D.receive_doc
    AND H.receive_date = D.receive_date
    and h.melt_no =:amelt_no
    and h.receive_doc =:areceive_doc
    AND H.status ='N'  ;
    WHEN SQLCODE -530DO
        exception e_insert_dross_ledger;
    END
    -- SUSPEND;

   /*INSER PL_DROSS LEDGER*/

   BEGIN
    for
      select sum(qty),dross_type
      from pl_dross_ledger
      where melt_no =  :amelt_no
      group by melt_no,dross_type


      into :balanceOnhandQty,:drossType
      do
      begin
         select count(*)
        from
        PL_DROSS_BALANCE 
        WHERE MELT_NO =:amelt_no
        AND DROSS_TYPE =:DROSSTYPE
        into   :checkBalanceExist;
    if (checkBalanceExist <=0) then
    begin
       begin
        INSERT INTO PL_DROSS_BALANCE (
        MELT_NO,
        DROSS_TYPE,
        ONHAND_QTY
       )
         SELECT H.melt_no,D.dross_type,
        D.net_weight
        FROM  PL_DROSS_HD H , pl_dross_dt D
        WHERE H.melt_no =D.MELT_NO
        AND H.receive_doc = D.receive_doc
        AND H.receive_date = D.receive_date
        and h.melt_no = :amelt_no
        and d.dross_type =:drosstype
        and h.receive_doc =:areceive_doc
          AND H.status ='N'  ;
            WHEN SQLCODE -530DO   exception e_insert_dross_balance;
        END
    end
    else
    begin

            update   PL_DROSS_BALANCE 
            set onhand_qty = :balanceOnhandQty
            where melt_no =:amelt_no
            and dross_type =:drossType  ;
         end
      end
    end
    update pl_dross_hd
    set status ='X'
    WHERE MELT_NO =:amelt_no
    AND RECEIVE_DOC =:areceive_doc;
  end
  else exception e_no_row;
  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_POST_FNG_ADJUST (
    DOC_NO VARCHAR(15),
    DOC_DATE TIMESTAMP)
AS
DECLARE VARIABLE MODE VARCHAR(1);
DECLARE VARIABLE DESCS VARCHAR(60);
DECLARE VARIABLE MELT_NO VARCHAR(10);
DECLARE VARIABLE ITEM_CODE VARCHAR(15);
DECLARE VARIABLE UOM_CD VARCHAR(4);
DECLARE VARIABLE QTY FLOAT;
DECLARE VARIABLE UNIT_COST FLOAT;
DECLARE VARIABLE TOTAL_COST FLOAT;
DECLARE VARIABLE RECOVERY_WEIGHT FLOAT;
DECLARE VARIABLE FMONTH SMALLINT;
DECLARE VARIABLE FYEAR SMALLINT;
DECLARE VARIABLE BUNDLE_QTY INTEGER;
DECLARE VARIABLE ONHAND_QTY FLOAT;
DECLARE VARIABLE ADJ_BUNDLE_QTY FLOAT;
DECLARE VARIABLE CHKROW INTEGER;
DECLARE VARIABLE ROWCOUNT INTEGER;
begin
  MODE ='I';
    select count(*)
    FROM PL_FNG_ADJ_HD H,PL_FNG_ADJ_DT D
    WHERE
        D.DOC_NO = H.DOC_NO
        AND D.DOC_DATE = H.DOC_DATE
        AND H.DOC_NO =:DOC_NO
        AND H.DOC_DATE =:DOC_DATE
        AND H.STATUS ='N'
    into :rowcount;
    if(rowcount >= 1) then
    begin
        FOR SELECT
            d.MELT_NO,
            d.ITEM_CODE,
            MAX(H.DESCS),
            MAX(D.UOM_CD),
            SUM(D.QTY),
            SUM(d.BUNDLE_QTY)
            FROM PL_FNG_ADJ_HD H,PL_FNG_ADJ_DT D
            WHERE
            D.DOC_NO = H.DOC_NO
            AND D.DOC_DATE = H.DOC_DATE
            AND H.DOC_NO =:DOC_NO
            AND H.DOC_DATE =:DOC_DATE
            AND H.STATUS ='N'
            group by  d.MELT_NO ,D.ITEM_CODE

            INTO :melt_no,:item_code,:descs,:uom_cd,
            :qty,:ADJ_BUNDLE_QTY
         do
         BEGIN
           if (qty < 0) then mode ='O';
           if (qty >0 ) then mode ='I';
           FYEAR = extract(YEAR FROM DOC_DATE);
           FMONTH = EXTRACT(MONTH FROM DOC_DATE);
           /**This calculation wrong must taken f GROUP_ID actual usaged weight***/
    

           /* SELECT SUM(d.unit_cost*d.QTY)
           FROM pl_req_dt d ,pl_req_hd h
           WHERE h.MELT_NO =:MELT_NO
           and h.doc_no = d.doc_no
           and h.doc_date = d.doc_date
           and h.trx_type = d.trx_type
           and h.ic_mode ='O'
           and h.status ='X'
           INTO :TOTAL_COST;  */
           /**ACTUAL UNIT_COST = ACTUAL USAGED MATERIAL*UNIT_COST / ACTUAL RECOVERY_WEIGHT**/
           TOTAL_COST = 0;
           RECOVERY_WEIGHT = QTY;


           /* UNIT_COST = TOTAL_COST/RECOVERY_WEIGHT;  */
           UNIT_COST = 0;
           BEGIN
              select sum(onhand_qty), sum(bundle_qty)
              from so_sales_item_stock
              where item_code = :ITEM_CODE
                  and MELT_NO = :MELT_NO
                  and onhand_qty > 0
              into :ONHAND_QTY,:BUNDLE_QTY;
           END
           BEGIN
             select count(*)
             from so_sales_item_stock
             where item_code = :ITEM_CODE
             and MELT_NO = :MELT_NO
             into :chkrow;
             if(chkrow = 1) then
             begin
                UPDATE SO_SALES_ITEM_STOCK
                SET ONHAND_QTY = ONHAND_QTY + :QTY,
                    BUNDLE_QTY = BUNDLE_QTY + :ADJ_BUNDLE_QTY
                WHERE ITEM_CODE = :ITEM_CODE
                   AND MELT_NO = :MELT_NO ;

                   select sum(bundle_qty),sum(onhand_qty)
                   from so_sales_item_stock
                   WHERE ITEM_CODE = :ITEM_CODE
                   AND MELT_NO = :MELT_NO
                   into :bundle_qty,:onhand_qty  ;


             end
             else
             begin
                INSERT INTO SO_SALES_ITEM_STOCK (ITEM_CODE,UOM_CD,ONHAND_QTY,RESERVED_QTY,CUST_CODE,DOC_NO,DOC_DATE,UNIT_COST,TOTAL_COST,MELT_NO,BUNDLE_QTY)
                VALUES (:ITEM_CODE,:UOM_CD,:QTY,0.00,'STOCK',:DOC_NO,:DOC_DATE,:UNIT_COST,:TOTAL_COST,:MELT_NO, :ADJ_BUNDLE_QTY);
                BUNDLE_QTY = ADJ_BUNDLE_QTY;
             end
          END
          BEGIN
                /*20070203
                passing :adj_buldle_qty instead of bundle_qty
                due to stock record_version card report using bundle qty
                */
                BUNDLE_QTY = ADJ_BUNDLE_QTY;
                INSERT INTO SO_LEDGER (CUST_CODE,CUST_NAME,DOC_NO,DOC_DATE,BASE_AMT,TAX_AMT,DISCS_AMT,TAX_INV_NO,UPDATE_USER,ITEM_CODE,UPDATE_DATE,DESCS,QTY,UNIT_COST,TOTAL_AMT,TAX_CD,DISCS_CD,REF_NO,REF_DATE,TAX_INV_DATE,LINE_NO,UOM_CD,MODE,MELT_NO,BUNDLE_QTY,ONHAND_QTY,ADJ_BUNDLE_QTY)
                VALUES ('STOCK','REMELT CUSTOMER',:DOC_NO,:DOC_DATE,0.00,0.00,0.00,'','BRD',:ITEM_CODE,current_timestamp,:descs,:QTY,:UNIT_COST,:TOTAL_COST,'','',:MELT_NO,current_timestamp,current_timestamp,0,:UOM_CD,:MODE,:MELT_NO,:BUNDLE_QTY,:ONHAND_QTY,:ADJ_BUNDLE_QTY );
          END

        BEGIN
           UPDATE pl_fng_adj_hd
           SET STATUS ='X'
           WHERE DOC_NO =:DOC_NO
           AND DOC_DATE =:DOC_DATE;
        END
      END
     end
     else
     begin
       exception e_no_row;
       exit;
     end

       suspend;
end^


ALTER PROCEDURE X_POST_FNG_RECEIVE (
    DOC_NO VARCHAR(15),
    DOC_DATE DATE)
AS
declare variable MODE varchar(1);
declare variable DESCS varchar(60);
declare variable MELT_NO varchar(10);
declare variable ITEM_CODE varchar(15);
declare variable UOM_CD varchar(4);
declare variable WEIGHT_QTY float;
declare variable QTY float;
declare variable REMELT_ITEM_FLAG varchar(1);
declare variable LINE_NO smallint;
declare variable GROUP_ID varchar(10);
declare variable UNIT_COST float;
declare variable TOTAL_COST float;
declare variable RECOVERY_WEIGHT float;
declare variable FMONTH smallint;
declare variable FYEAR smallint;
declare variable EXIST_MELT_NO smallint;
declare variable BUNDLE_QTY integer;
declare variable ROWCOUNT integer;
declare variable DEFAULT_RECOVERY float;
begin
  MODE ='I';
  DEFAULT_RECOVERY =97;
  select count(*)
  FROM pl_fn_receive_hd H,pl_fn_receive_dt D
  WHERE
  D.DOC_NO = H.DOC_NO
  AND D.DOC_DATE = H.DOC_DATE
  AND H.DOC_NO =:DOC_NO
  AND H.DOC_DATE =:DOC_DATE
  AND H.STATUS ='N'
  into :rowcount;
  if(rowcount >= 1) then
  begin
      FOR SELECT
      MAX(H.DESCS),
      H.MELT_NO,
      H.ITEM_CODE,
      MAX(D.UOM_CD),
      SUM(D.WEIGHT_QTY),
      SUM(D.QTY),
      D.REMELT_ITEM_FLAG ,
      MAX(D.LINE_NO) ,
      MAX(d.group_id),
      MAX(H.BUNDLE_QTY)
      FROM pl_fn_receive_hd H,pl_fn_receive_dt D
      WHERE
      D.DOC_NO = H.DOC_NO
      AND D.DOC_DATE = H.DOC_DATE
      AND H.DOC_NO =:DOC_NO
      AND H.DOC_DATE =:DOC_DATE
      AND H.STATUS ='N'
      group by  H.MELT_NO ,H.ITEM_CODE, D.REMELT_ITEM_FLAG

      INTO :descs,:melt_no,:item_code,:uom_cd,
      :weight_qty,:qty,:remelt_item_flag,
      :line_no,:group_id, :BUNDLE_QTY
      do
      BEGIN

        FYEAR = extract(YEAR FROM DOC_DATE);
        FMONTH = EXTRACT(MONTH FROM DOC_DATE);
         /**This calculation wrong must taken from actual usaged weight***/
    

        /* SELECT SUM(d.unit_cost*d.QTY)
          FROM pl_req_dt d ,pl_req_hd h
          WHERE h.MELT_NO =:MELT_NO
          and h.doc_no = d.doc_no
          and h.doc_date = d.doc_date
          and h.trx_type = d.trx_type
          and h.ic_mode ='O'
          and h.status ='X'
          INTO :TOTAL_COST;  */
          /**ACTUAL UNIT_COST = ACTUAL USAGED MATERIAL*UNIT_COST / ACTUAL RECOVERY_WEIGHT**/
         TOTAL_COST = 0;
         RECOVERY_WEIGHT = QTY;


          /* UNIT_COST = TOTAL_COST/RECOVERY_WEIGHT;  */
         UNIT_COST = 0;

         if (remelt_item_flag ='N') then
         BEGIN
            if (BUNDLE_QTY > 0) then
            begin
            BEGIN
               INSERT INTO SO_SALES_ITEM_STOCK (ITEM_CODE,UOM_CD,ONHAND_QTY,RESERVED_QTY,CUST_CODE,DOC_NO,DOC_DATE,UNIT_COST,TOTAL_COST,MELT_NO,BUNDLE_QTY)
               VALUES (:ITEM_CODE,:UOM_CD,:QTY,0.00,'STOCK',:DOC_NO,:DOC_DATE,:UNIT_COST,:TOTAL_COST,:MELT_NO, :BUNDLE_QTY);

            END
            BEGIN
               INSERT INTO SO_LEDGER (CUST_CODE,CUST_NAME,DOC_NO,DOC_DATE,BASE_AMT,TAX_AMT,DISCS_AMT,TAX_INV_NO,UPDATE_USER,ITEM_CODE,UPDATE_DATE,DESCS,QTY,UNIT_COST,TOTAL_AMT,TAX_CD,DISCS_CD,REF_NO,REF_DATE,TAX_INV_DATE,LINE_NO,UOM_CD,MODE,MELT_NO,BUNDLE_QTY)
               VALUES ('STOCK','REMELT CUSTOMER',:DOC_NO,:DOC_DATE,0.00,0.00,0.00,'','BRD',:ITEM_CODE,current_timestamp,:descs,:QTY,:UNIT_COST,:TOTAL_COST,'','',:MELT_NO,current_timestamp,current_timestamp,0,:UOM_CD,:MODE,:MELT_NO,:BUNDLE_QTY);
            END
            end
            else
            begin
                EXCEPTION ex_sales_stock;
            end
         END
         if (REMELT_ITEM_FLAG ='Y') then
         BEGIN
            /***if Remelt item already exist only update quantity*/
            BEGIN
               SELECT COUNT(*)
               FROM IC_MAT_STK_HD
               WHERE STOCK_CD =:MELT_NO
               INTO :exist_melt_no;
            END
            if (exist_melt_no > 0) then
            begin
             /*still insert new lot_no when for new receive item-- 20070720*/
                 BEGIN
                      INSERT INTO PO_ORDER_DT (ITEM_CODE,LINE_NO,ORDER_DATE,SUPP_CODE,UOM,ORDER_NO,ITEM_DESCS,UNIT_COST,TOTAL_AMT,REMARKS,DISCS_AMT,TAX_AMT,BASE_AMT,TAX_CD,DISCS_CD,QTY,TAX_RATE,STATUS,GRN_QTY,LOT_NO,GROUP_ID,MARKUP)
                          VALUES (:MELT_NO,:LINE_NO,:DOC_DATE,'SUPP',:UOM_CD,:DOC_NO,:MELT_NO,:UNIT_COST,:TOTAL_COST,'',0,0,:TOTAL_COST,'','',:QTY,0,'A',0,:MELT_NO,:GROUP_ID,0);
                       END
            
                     BEGIN
                          INSERT INTO IC_MAT_STK_DT (STOCK_CD,GROUP_ID,UOM_CD,LOT_CD,UNIT_COST,LAST_PURCHASE_PRICE,PURCHASE_DATE,ONHAND_QTY,RESERVED_QTY,STOCK_VALUE,TOTAL_COST,ACCT_CODE,ORDER_LINE)
                          VALUES (:MELT_NO,:GROUP_ID,:UOM_CD,:DOC_NO,:UNIT_COST,:UNIT_COST,:DOC_DATE,:QTY,0,:TOTAL_COST,:TOTAL_COST,:MELT_NO,:LINE_NO);
                       END
                       BEGIN
                       /* 20070519UPDATE LAST PURCHASE PRICE AS TOTAL COST*/
                          INSERT INTO IC_MAT_STK_DT_LINK (STOCK_CD,GROUP_ID,UOM_CD,LOT_CD,UNIT_COST,LAST_PURCHASE_PRICE,PURCHASE_DATE,ONHAND_QTY,RESERVED_QTY,STOCK_VALUE,TOTAL_COST,ACCT_CODE,ORDER_LINE,REF_NO,REF_DATE)
                          VALUES (:MELT_NO,:GROUP_ID,:UOM_CD,:DOC_NO,:UNIT_COST,:UNIT_COST,:DOC_DATE,:QTY,:UNIT_COST,:TOTAL_COST,:TOTAL_COST,:MELT_NO,:LINE_NO,:DOC_NO,:DOC_DATE);
                       END

            end
            else
            begin
                begin

                       BEGIN
                          INSERT INTO PO_ORDER_DT (ITEM_CODE,LINE_NO,ORDER_DATE,SUPP_CODE,UOM,ORDER_NO,ITEM_DESCS,UNIT_COST,TOTAL_AMT,REMARKS,DISCS_AMT,TAX_AMT,BASE_AMT,TAX_CD,DISCS_CD,QTY,TAX_RATE,STATUS,GRN_QTY,LOT_NO,GROUP_ID,MARKUP)
                          VALUES (:MELT_NO,:LINE_NO,:DOC_DATE,'SUPP',:UOM_CD,:DOC_NO,:MELT_NO,:UNIT_COST,:TOTAL_COST,'',0,0,:TOTAL_COST,'','',:QTY,0,'A',0,:MELT_NO,:GROUP_ID,0);
                       END
            
            
                       BEGIN
                          INSERT INTO IC_MAT_STK_HD (STOCK_CD,EN_DESCS,TH_DESCS,SHORT_DESCS,ONHAND_QTY,UNIT_COST,TOTAL_COST,UOM_CD,GROUP_ID,RECOVERY,MARKED_UP,UPDATE_USER,UPDATE_DATE,DEFAULT_ELEMENT_DETAIL)
                          VALUES (:MELT_NO,'REMELT ITEM ','REMELT ITEM ','REMELT ITEM ',0,0,0,:UOM_CD,:GROUP_ID,:DEFAULT_RECOVERY,0,'BRD',current_timestamp,'N');
                       END
                       BEGIN
                          INSERT INTO IC_MAT_STK_DT (STOCK_CD,GROUP_ID,UOM_CD,LOT_CD,UNIT_COST,LAST_PURCHASE_PRICE,PURCHASE_DATE,ONHAND_QTY,RESERVED_QTY,STOCK_VALUE,TOTAL_COST,ACCT_CODE,ORDER_LINE)
                          VALUES (:MELT_NO,:GROUP_ID,:UOM_CD,:DOC_NO,:UNIT_COST,:UNIT_COST,:DOC_DATE,:QTY,0,:TOTAL_COST,:TOTAL_COST,:MELT_NO,:LINE_NO);
                       END
                       BEGIN
                       /* 20070519UPDATE LAST PURCHASE PRICE AS TOTAL COST*/
                          INSERT INTO IC_MAT_STK_DT_LINK (STOCK_CD,GROUP_ID,UOM_CD,LOT_CD,UNIT_COST,LAST_PURCHASE_PRICE,PURCHASE_DATE,ONHAND_QTY,RESERVED_QTY,STOCK_VALUE,TOTAL_COST,ACCT_CODE,ORDER_LINE,REF_NO,REF_DATE)
                          VALUES (:MELT_NO,:GROUP_ID,:UOM_CD,:DOC_NO,:UNIT_COST,:UNIT_COST,:DOC_DATE,:QTY,:UNIT_COST,:TOTAL_COST,:TOTAL_COST,:MELT_NO,:LINE_NO,:DOC_NO,:DOC_DATE);
                       END
                 end


            END /**IF NOT RECORD EXIST*/
            BEGIN
                /*20070305
                REMELT ITEM MUST INSERTACCT_CD WITH MELT_NO
                IT WILL LATER LINK TO IC_MAT_STK_DT_LINK.acct_code
                REF_NO COULD BE SAME AS DOC_NO AND REF_DATE MUST BE THE SAME*/
               INSERT INTO IC_STOCKCARD (ACCT_CD,DOC_NO,DOC_DATE,REF_NO,REF_DATE,QTY,UNIT_COST,TOTAL_COST,LOT_CD,GROUP_ID,UOM_CD,STOCK_VALUE,FMONTH,FYEAR,MODE,STOCK_CD,UPDATE_USER,UPDATE_DATE,MODULE,ORDER_LINE,descs,TRX_TYPE,ONHAND_QTY,RESERVED_QTY,MELT_NO,purchase_date)
               VALUES (:MELT_NO,:DOC_NO,:DOC_DATE,:DOC_NO,:DOC_DATE,:QTY,:UNIT_COST,:TOTAL_COST,:DOC_NO,:GROUP_ID,:UOM_CD,:TOTAL_COST,:FMONTH,:FYEAR,:MODE,:MELT_NO,'BRD',current_timestamp,'IC',0,'Remelt Item automatic insert ','RM',:QTY,0,:MELT_NO,:doc_date);
               WHEN SQLCODE - 530 DO
               BEGIN
                 EXCEPTION EX_INS_STOCKCARD;
               END
            END
         END/**IF REMELT_ITEM_FLAG ='Y'*/
         BEGIN
           UPDATE pl_fn_receive_hd
           SET STATUS ='X'
           WHERE DOC_NO =:DOC_NO
           AND DOC_DATE =:DOC_DATE;
         END

     END /*END FOR LOOP*/
  end
  else
  Begin
    exception e_no_row;
    exit;
  end
      /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_POST_FNG_RETURN (
    DOC_NO VARCHAR(15),
    DOC_DATE DATE)
AS
declare variable mode varchar(1);
declare variable descs varchar(60);
declare variable melt_no varchar(10);
declare variable item_code varchar(15);
declare variable uom_cd varchar(4);
declare variable qty float;
declare variable remelt_item_flag varchar(1);
declare variable group_id varchar(10);
declare variable unit_cost float;
declare variable total_cost float;
declare variable recovery_weight float;
declare variable FMONTH SMALLINT;
declare variable FYEAR smallint;
declare variable exist_melt_no smallint;
declare variable BUNDLE_QTY integer;
declare variable rowcount integer;

begin
  MODE ='I';
  select count(*)
  FROM PL_FNG_RET_HD H,PL_FNG_RET_DT D
  WHERE
  D.DOC_NO = H.DOC_NO
  AND D.DOC_DATE = H.DOC_DATE
  AND H.DOC_NO =:DOC_NO
  AND H.DOC_DATE =:DOC_DATE
  AND H.STATUS ='N'
  into :rowcount;
  if(rowcount >= 1)then
  begin
      FOR  SELECT
      H.MELT_NO,
      d.ITEM_CODE,
      D.REMELT_ITEM_FLAG ,
      MAX(H.DESCS),
      MAX(D.UOM_CD),
      SUM(D.QTY),
      MAX(d.group_id),
      SUM(H.BUNDLE_QTY)
      FROM PL_FNG_RET_HD H,PL_FNG_RET_DT D
      WHERE
      D.DOC_NO = H.DOC_NO
      AND D.DOC_DATE = H.DOC_DATE
      AND H.DOC_NO =:DOC_NO
      AND H.DOC_DATE =:DOC_DATE
      AND H.STATUS ='N'
      group by  H.MELT_NO ,D.ITEM_CODE, D.REMELT_ITEM_FLAG

      INTO :melt_no,:item_code,:remelt_item_flag,:descs,:uom_cd,
      :qty,:group_id, :BUNDLE_QTY
     do
     BEGIN

       FYEAR = extract(YEAR FROM DOC_DATE);
       FMONTH = EXTRACT(MONTH FROM DOC_DATE);
       /**This calculation wrong must taken f GROUP_ID actual usaged weight***/
    

       /* SELECT SUM(d.unit_cost*d.QTY)
          FROM pl_req_dt d ,pl_req_hd h
          WHERE h.MELT_NO =:MELT_NO
          and h.doc_no = d.doc_no
          and h.doc_date = d.doc_date
          and h.trx_type = d.trx_type
          and h.ic_mode ='O'
          and h.status ='X'
          INTO :TOTAL_COST;  */
         /**ACTUAL UNIT_COST = ACTUAL USAGED MATERIAL*UNIT_COST / ACTUAL RECOVERY_WEIGHT**/
        TOTAL_COST = 0;
        RECOVERY_WEIGHT = QTY;


        /* UNIT_COST = TOTAL_COST/RECOVERY_WEIGHT;  */
        UNIT_COST = 0;

        if (remelt_item_flag ='N') then
        BEGIN
            BEGIN
               UPDATE SO_SALES_ITEM_STOCK
               SET ONHAND_QTY = ONHAND_QTY + :QTY,
                   BUNDLE_QTY = BUNDLE_QTY + :BUNDLE_QTY
               WHERE ITEM_CODE = :ITEM_CODE
                     AND MELT_NO = :MELT_NO ;

            END
            BEGIN
               INSERT INTO SO_LEDGER (CUST_CODE,CUST_NAME,DOC_NO,DOC_DATE,BASE_AMT,TAX_AMT,DISCS_AMT,TAX_INV_NO,UPDATE_USER,ITEM_CODE,UPDATE_DATE,DESCS,QTY,UNIT_COST,TOTAL_AMT,TAX_CD,DISCS_CD,REF_NO,REF_DATE,TAX_INV_DATE,LINE_NO,UOM_CD,MODE,MELT_NO,BUNDLE_QTY)
               VALUES ('STOCK','REMELT CUSTOMER',:DOC_NO,:DOC_DATE,0.00,0.00,0.00,'','BRD',:ITEM_CODE,current_timestamp,:descs,:QTY,:UNIT_COST,:TOTAL_COST,'','',:MELT_NO,current_timestamp,current_timestamp,0,:UOM_CD,:MODE,:MELT_NO,:BUNDLE_QTY);
            END
         END
         if (REMELT_ITEM_FLAG ='Y') then
         BEGIN
            /***if Remelt item already exist only update quantity*/
            BEGIN
                SELECT COUNT(*)
                FROM IC_MAT_STK_HD
                WHERE STOCK_CD =:MELT_NO
                INTO :exist_melt_no;
            END
            if (exist_melt_no > 0) then
            begin
               UPDATE IC_MAT_STK_DT
               SET ONHAND_QTY = ONHAND_QTY + :QTY
               WHERE IC_MAT_STK_DT.stock_cd =:MELT_NO;

               UPDATE ic_mat_stk_dt_link
               SET ONHAND_QTY = ONHAND_QTY + :QTY
               WHERE ic_mat_stk_dt_link.stock_cd =:MELT_NO;


               UPDATE PO_ORDER_DT
               SET QTY = QTY + :QTY
               WHERE PO_ORDER_DT.item_code =:MELT_NO;

             end
             else
             begin
                BEGIN
                   INSERT INTO PO_ORDER_DT (ITEM_CODE,LINE_NO,ORDER_DATE,SUPP_CODE,UOM,ORDER_NO,ITEM_DESCS,UNIT_COST,TOTAL_AMT,REMARKS,DISCS_AMT,TAX_AMT,BASE_AMT,TAX_CD,DISCS_CD,QTY,TAX_RATE,STATUS,GRN_QTY,LOT_NO,GROUP_ID,MARKUP)
                   VALUES (:MELT_NO,0,:DOC_DATE,'SUPP',:UOM_CD,:DOC_NO,:MELT_NO,:UNIT_COST,:TOTAL_COST,'',0,0,:TOTAL_COST,'','',:QTY,0,'A',0,:MELT_NO,:GROUP_ID,0);
                END
    
    
                BEGIN
                   INSERT INTO IC_MAT_STK_HD (STOCK_CD,EN_DESCS,TH_DESCS,SHORT_DESCS,ONHAND_QTY,UNIT_COST,TOTAL_COST,UOM_CD,GROUP_ID,RECOVERY,MARKED_UP,UPDATE_USER,UPDATE_DATE,DEFAULT_ELEMENT_DETAIL)
                   VALUES (:MELT_NO,'REMELT ITEM ','REMELT ITEM ','REMELT ITEM ',0,0,0,:UOM_CD,:GROUP_ID,95,0,'BRD',current_timestamp,'N');
                END
                BEGIN
                   INSERT INTO IC_MAT_STK_DT (STOCK_CD,GROUP_ID,UOM_CD,LOT_CD,UNIT_COST,LAST_PURCHASE_PRICE,PURCHASE_DATE,ONHAND_QTY,RESERVED_QTY,STOCK_VALUE,TOTAL_COST,ACCT_CODE,ORDER_LINE)
                   VALUES (:MELT_NO,:GROUP_ID,:UOM_CD,:DOC_NO,:UNIT_COST,:UNIT_COST,:DOC_DATE,:QTY,0,:TOTAL_COST,:TOTAL_COST,:MELT_NO,0);
                END
                BEGIN
                   INSERT INTO ic_mat_stk_dt_link (STOCK_CD,GROUP_ID,UOM_CD,LOT_CD,UNIT_COST,LAST_PURCHASE_PRICE,PURCHASE_DATE,ONHAND_QTY,RESERVED_QTY,STOCK_VALUE,TOTAL_COST,ACCT_CODE,ORDER_LINE,REF_NO,REF_DATE)
                   VALUES (:MELT_NO,:GROUP_ID,:UOM_CD,:DOC_NO,:UNIT_COST,:UNIT_COST,:DOC_DATE,:QTY,0,:TOTAL_COST,:TOTAL_COST,:MELT_NO,0,:DOC_NO,:DOC_DATE);
                END

             END /**IF NOT RECORD EXIST*/
             BEGIN
                INSERT INTO IC_STOCKCARD (ACCT_CD,DOC_NO,DOC_DATE,REF_NO,REF_DATE,QTY,UNIT_COST,TOTAL_COST,LOT_CD,GROUP_ID,UOM_CD,STOCK_VALUE,FMONTH,FYEAR,MODE,STOCK_CD,UPDATE_USER,UPDATE_DATE,MODULE,ORDER_LINE,descs,TRX_TYPE,ONHAND_QTY,RESERVED_QTY,MELT_NO,purchase_date)
                VALUES ('SUPP',:DOC_NO,:DOC_DATE,:MELT_NO,current_timestamp,:QTY,:UNIT_COST,:TOTAL_COST,:MELT_NO,:GROUP_ID,:UOM_CD,:TOTAL_COST,:FMONTH,:FYEAR,:MODE,:MELT_NO,'BRD',current_timestamp,'IC',0,'Remelt Item automatic insert ','RM',:QTY,0,:MELT_NO,:doc_date);
                WHEN SQLCODE - 530 DO
                BEGIN
                    EXCEPTION EX_INS_STOCKCARD;
                 END
             END
         END/**IF REMELT_ITEM_FLAG ='Y'*/
         BEGIN
            UPDATE pl_fng_ret_hd
            SET STATUS ='X'
            WHERE DOC_NO =:DOC_NO
            AND DOC_DATE =:DOC_DATE;
         END

     END /*END FOR LOOP*/
    end
    else
    begin
       exception e_no_row;
       exit;
    end

  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_POST_GRN (
    ACCT_CD VARCHAR(10),
    DOC_NO VARCHAR(15),
    DOC_DATE TIMESTAMP,
    UPDATE_USER VARCHAR(10),
    MODULE VARCHAR(2),
    MODE VARCHAR(1))
AS
declare variable REF_NO varchar(15);
declare variable REF_DATE timestamp;
declare variable QTY float;
declare variable UNIT_COST float;
declare variable TOTAL_COST float;
declare variable LOT_CD varchar(15);
declare variable GROUP_ID varchar(10);
declare variable UOM_CD varchar(4);
declare variable STOCK_VALUE float;
declare variable FMONTH smallint;
declare variable FYEAR smallint;
declare variable STOCK_CD varchar(15);
declare variable UPDATE_DATE timestamp;
declare variable ROW_NUM smallint;
declare variable ORDER_LINE smallint;
declare variable ORDER_QTY float;
declare variable DESCS varchar(60);
declare variable ROWSNUM smallint;
declare variable GRN_ROW smallint;
declare variable GRN_QTY float;
declare variable MARKUP_RATE smallint;
declare variable MARKUP_QTY float;
declare variable ONHAND_QTY float;
declare variable MAX_ELEMENT_LINE smallint;
BEGIN

  BEGIN
     UPDATE_DATE = CURRENT_DATE;
     row_num =0;
     FYEAR = extract(YEAR FROM DOC_DATE);
     FMONTH = EXTRACT(MONTH FROM DOC_DATE);
     IF (MODULE ='PO') then     /**GRN TRANSACTION*/
     BEGIN

       SELECT COUNT(*)
       FROM PO_GRN_DT B, PO_GRN_HD A
       WHERE A.supp_code =b.supp_code
       and a.grn_no = b.grn_no
       and b.grn_date =b.grn_date
        AND A.SUPP_CODE =:ACCT_CD
        AND A.GRN_DATE =:DOC_DATE
        AND A.GRN_NO =:DOC_NO
        INTO :row_num;
       if (row_num <= 0 ) then
       begin
         exception E_NO_ROW;
         exit;
       end
       FOR
        SELECT
        A.DESCS ,
        B.SUPP_CODE,
        B.GRN_NO,
        B.GRN_DATE,
        B.ORDER_NO,
        B.ORDER_DATE,
        B.GRN_QTY,
        B.ORDER_QTY,
        B.UNIT_COST,
        B.TOTAL_AMT,
        B.LOT_NO,B.GROUP_ID,B.UOM,
        B.GRN_QTY*B.UNIT_COST,
        B.ITEM_CODE,
        b.order_line,
        b.mark_up
       FROM PO_GRN_DT B , PO_GRN_HD A
       WHERE A.supp_code =b.supp_code
       AND a.grn_no = b.grn_no
       AND b.grn_date =b.grn_date
       AND A.SUPP_CODE =:ACCT_CD
       AND A.GRN_DATE =:DOC_DATE
       AND A.GRN_NO =:DOC_NO
       INTO :DESCS, :ACCT_CD,:DOC_NO,:DOC_DATE,
             :REF_NO,:REF_DATE,:QTY,:ORDER_QTY,
             :UNIT_COST,:TOTAL_COST,
             :LOT_CD,:GROUP_ID,:UOM_CD,
             :STOCK_VALUE,:STOCK_CD,:ORDER_LINE ,:markup_rate
        DO
        BEGIN
            if (markup_rate is null ) then   markup_rate =10;
            markup_qty = (order_qty * markup_rate/100)  ;

            if (:lot_cd <> :ref_no) then    lot_cd =:ref_no;

             /***Update GRN_QTY TO PO_ORDER_DT**/

         /**DO NOT DO UPDATE HERE  COZ DONE SINCE ENTRY AON 20040108
          /*
             UPDATE PO_ORDER_DT
             SET GRN_QTY = GRN_QTY + :QTY
             WHERE ORDER_NO =:REF_NO
             AND ORDER_DATE = :REF_DATE
             AND ITEM_CODE =:STOCK_CD
             AND GROUP_ID =:GROUP_ID
             AND UOM =:UOM_CD;   */
             /*MUST GET FROM PO_GRN_DT INSTEAD PO_ORDER_DT*/
             SELECT SUM(GRN_QTY)
             FROM PO_GRN_DT
             WHERE ORDER_NO =:REF_NO
             AND ORDER_DATE = :REF_DATE
             AND ITEM_CODE =:STOCK_CD
             AND GROUP_ID =:GROUP_ID
             AND UOM =:UOM_CD
             into :GRN_QTY;

            if ((GRN_QTY >= (ORDER_QTY -markup_qty) ) and (grn_qty <=(order_qty + markup_qty))) then
            BEGIN
             BEGIN
                UPDATE PO_ORDER_DT
                SET STATUS ='O'
                 WHERE ORDER_NO =:REF_NO
                 AND ORDER_DATE = :REF_DATE
                 AND SUPP_CODE =:ACCT_CD
                 AND ITEM_CODE =:STOCK_CD
                 AND GROUP_ID =:GROUP_ID
                 AND UOM =:UOM_CD ;
              END
              BEGIN

                SELECT COUNT(*)
                 FROM PO_ORDER_DT
                 WHERE PO_ORDER_DT.ORDER_NO =:REF_NO
                 AND PO_ORDER_DT.ORDER_DATE = :REF_DATE
                 AND PO_ORDER_DT.SUPP_CODE =:ACCT_CD
                 AND PO_ORDER_DT.STATUS ='A'
                 INTO :GRN_ROW;
               END
               if (GRN_ROW =0) then
               BEGIN
                UPDATE PO_ORDER_HD
                SET STATUS ='O'
                WHERE PO_ORDER_HD.ORDER_NO =:REF_NO
                AND PO_ORDER_HD.order_date =:REF_DATE
                AND PO_ORDER_HD.supp_code =:ACCT_CD;
               END
             END
       BEGIN /**Insert into STOCK DETAIL*/


         SELECT COUNT(*)
         FROM IC_MAT_STK_DT
         WHERE STOCK_CD =:STOCK_CD
         AND GROUP_ID =:GROUP_ID
         AND UOM_CD =:UOM_CD
         AND LOT_CD =:REF_NO
         AND PURCHASE_DATE =:REF_DATE
         AND ACCT_CODE = :ACCT_CD
         INTO :ROWSNUM;
         if (ROWSNUM =0) then
         BEGIN
             INSERT INTO IC_MAT_STK_DT (
               STOCK_CD             ,
               GROUP_ID             ,
               UOM_CD               ,
               LOT_CD               ,
               UNIT_COST            ,
               LAST_PURCHASE_PRICE  ,
               PURCHASE_DATE        ,
               ONHAND_QTY           ,
               RESERVED_QTY         ,
               STOCK_VALUE          ,
               TOTAL_COST           ,
               ACCT_CODE            ,
               ORDER_LINE    )
               values(:STOCK_CD,
               :GROUP_ID,
               :UOM_CD,
               :REF_NO,
               :UNIT_COST,
               :UNIT_COST,
               :REF_DATE,
               :QTY,
               0,
               :STOCK_VALUE,
               :TOTAL_COST,
               :ACCT_CD,
               :ORDER_LINE);
                WHEN SQLCODE - 530 DO
                BEGIN
                    EXCEPTION EX_INS_STK_DT;
                END
         END
         if (ROWSNUM> 0) then
         BEGIN
            UPDATE  IC_MAT_STK_DT
            SET ONHAND_QTY =ONHAND_QTY +:QTY
            WHERE STOCK_CD =:STOCK_CD
            AND GROUP_ID =:GROUP_ID
            AND UOM_CD =:UOM_CD
            AND PURCHASE_DATE =:REF_DATE
            AND ACCT_CODE = :ACCT_CD
            AND LOT_CD =:REF_NO;
         END

        END

        BEGIN
           ROWSNUM = 0;
           /**20 oct,2010 check if row already exist trying not to insert */
           select count(*) from
           ic_mat_stk_dt_link
           where stock_cd =:STOCK_CD
           and group_id =:GROUP_ID
           and lot_cd =:ref_no --Changed from ref_no
           and purchase_date =:REF_DATE
           and ref_no =:doc_no
           and ref_date =:doc_date into :ROWSNUM  ;
           if (ROWSNUM <=0 )then
           begin




                   INSERT INTO IC_MAT_STK_DT_LINK (STOCK_CD,GROUP_ID,UOM_CD,LOT_CD,UNIT_COST,LAST_PURCHASE_PRICE,PURCHASE_DATE,ONHAND_QTY,RESERVED_QTY,STOCK_VALUE,TOTAL_COST,ACCT_CODE,ORDER_LINE,REF_NO,REF_DATE)
                   VALUES(:STOCK_CD,:GROUP_ID,:UOM_CD,:REF_NO,:UNIT_COST,:UNIT_COST,:REF_DATE,:QTY,0,:STOCK_VALUE,:TOTAL_COST,:ACCT_CD,:ORDER_LINE,:DOC_NO,:DOC_DATE);

                            --Also insert into IC_MAT_ELEMENT 7 March ,2011
                    insert into ic_mat_element (STOCK_CD,GROUP_ID,UOM_CD,LOT_CD,PURCHASE_DATE,REF_NO,REF_DATE,ACCT_CD,LINE_NO)
                    valueS (:STOCK_CD,:GROUP_ID,:UOM_CD,:ref_no,:REF_DATE,:doc_no,:DOC_DATE,:acct_cd,(SELECT GEN_ID( mygenerator, 1 )  from rdb$database));

           end
           else
           begin
              update      ic_mat_stk_dt_link
              set  unit_cost = :UNIT_COST ,
              stock_value =onhand_qty*unit_cost,
              total_cost =stock_value
               where stock_cd =:STOCK_CD
               and group_id =:GROUP_ID
               and lot_cd =:ref_no
               and purchase_date =:REF_DATE
               and ref_no =:doc_no
               and ref_date =:doc_date;


               SELECT MAX(LINE_NO)
               FROM IC_MAT_ELEMENT
                where stock_cd =:STOCK_CD
               and group_id =:GROUP_ID
               and lot_cd =:ref_no
               and purchase_date =:REF_DATE
               and ref_no =:doc_no
               and ref_date =:doc_date
               INTO :MAX_ELEMENT_LINE;
                MAX_ELEMENT_LINE = :MAX_ELEMENT_LINE +1   ;

              --insert into ic_mat_element (STOCK_CD,GROUP_ID,UOM_CD,LOT_CD,PURCHASE_DATE,REF_NO,REF_DATE,ACCT_CD,LINE_NO)
              --valueS (:STOCK_CD,:GROUP_ID,:UOM_CD,:LOT_CD,:REF_DATE,:doc_no,:DOC_DATE,:acct_cd,:MAX_ELEMENT_LINE);

           end
         /**20 oct,2010 check if row already exist trying not to insert */
        END
        BEGIN
          SELECT SUM(ONHAND_QTY) ,SUM(STOCK_VALUE) ,SUM(TOTAL_COST)
          FROM IC_MAT_STK_DT_LINK
          WHERE STOCK_CD =:STOCK_CD
            AND GROUP_ID =:GROUP_ID
            AND UOM_CD =:UOM_CD
            AND PURCHASE_DATE =:REF_DATE
            AND ACCT_CODE = :ACCT_CD
            AND LOT_CD =:REF_NO
         INTO :ONHAND_QTY,:STOCK_VALUE,:TOTAL_COST;

        END
        /**GET NEW ONHAND VALUE UPDATE TO STOCKCARD**/
        BEGIN
            /*20070305
            REF_NO , REF_DATE WHEN DO GRN SHUOLD BE MATCHED WITH
            GRN_NO AND GRN_DATE NOT LOT_DATE AND PURCHASE_DATE*/
           INSERT INTO IC_STOCKCARD (ACCT_CD,DOC_NO,DOC_DATE,REF_NO,REF_DATE,QTY,UNIT_COST,TOTAL_COST,LOT_CD,purchase_date,GROUP_ID,UOM_CD,STOCK_VALUE,FMONTH,FYEAR,MODE,STOCK_CD,UPDATE_USER,UPDATE_DATE,MODULE,ORDER_LINE,DESCS,TRX_TYPE,ONHAND_QTY,RESERVED_QTY)
           VALUES (:ACCT_CD,:DOC_NO,:DOC_DATE,:DOC_NO,:DOC_DATE,:QTY,:UNIT_COST,:TOTAL_COST,:ref_no,:ref_date,:GROUP_ID,:UOM_CD,:STOCK_VALUE,:FMONTH,:FYEAR,:MODE,:STOCK_CD,:UPDATE_USER,:UPDATE_DATE,:MODULE,:ORDER_LINE,:DESCS,'GR',:ONHAND_QTY,0.00);
           WHEN SQLCODE - 530 DO
           BEGIN
             EXCEPTION EX_INS_STOCKCARD;
           END
        END

        BEGIN
          UPDATE PO_GRN_HD
             SET STATUS ='X'
             WHERE SUPP_CODE =:ACCT_CD
             AND GRN_DATE =:DOC_DATE
             AND GRN_NO =:DOC_NO;
        END
        END /*End for*/
     END /*End if (MODULE = PO) then*/

  END

  SUSPEND;
END^


ALTER PROCEDURE X_POST_MAT_STOCK_ADJUST (
    DOC_NO VARCHAR(15),
    DOC_DATE DATE,
    MODULE VARCHAR(2))
AS
declare variable STOCK_CD varchar(15);
declare variable GROUP_ID varchar(10);
declare variable UOM_CD varchar(4);
declare variable REF_NO varchar(15);
declare variable UNIT_COST float;
declare variable LOT_CD varchar(15);
declare variable REF_DATE timestamp;
declare variable QTY float;
declare variable STOCK_VALUE float;
declare variable TOTAL_COST float;
declare variable ONHAND_QTY float;
declare variable ACCT_CD varchar(10);
declare variable ORDER_LINE smallint;
declare variable DESCS varchar(60);
declare variable UPDATE_USER varchar(10);
declare variable UPDATE_DATE timestamp;
declare variable FMONTH smallint;
declare variable FYEAR smallint;
declare variable TRX_TYPE varchar(2);
declare variable MODE varchar(1);
declare variable ROWCOUNT integer;
declare variable MELT_NO varchar(10);
declare variable GRN_NO varchar(15);
declare variable GRN_DATE timestamp;
declare variable TOTALVALUE float;
declare variable ONHANDQTY float;
declare variable PURCHASE_DATE timestamp;
BEGIN
    ORDER_LINE=0;

    SELECT COUNT(*) 
    FROM ic_stock_adjust_hd A,
         ic_stock_adjust_DT B
    WHERE B.DOC_NO =A.DOC_NO
    AND A.DOC_DATE = B.DOC_DATE
    AND A.DOC_NO =:DOC_NO
    AND A.DOC_DATE =:DOC_DATE
    AND A.STATUS = 'N'
    into :rowcount;
    if(rowcount >= 1) then
    begin
        REF_NO =DOC_NO;
        REF_DATE =DOC_DATE;
      /*  ACCT_CD ='ICMODULE';*/
/*        trx_type = 'IS';*/
        FOR SELECT
            A.DESCS,
            A.UPDATE_USER,
            A.UPDATE_DATE,
            A.TRX_TYPE,
            A.MELT_NO,
            B.ITEM_CODE,
            B.UOM_CD,
            B.GROUP_ID,
            B.LOT_NO,
            B.QTY,
            B.ONHAND_QTY,
            B.UNIT_COST,
            B.TOTAL_COST,
            B.QTY*B.UNIT_COST,
            B.REF_NO,
            B.REF_DATE               ,
            B.purchase_date,
            B.acct_cd
            FROM ic_stock_adjust_hd A,
                 ic_stock_adjust_DT B
            WHERE B.DOC_NO =A.DOC_NO
            AND A.DOC_DATE = B.DOC_DATE
            AND A.DOC_NO =:DOC_NO
            AND A.DOC_DATE =:DOC_DATE
            AND A.STATUS = 'N'
            INTO
            :DESCS,
            :UPDATE_USER,
            :UPDATE_DATE,
            :trx_type,
            :melt_no,
            :STOCK_CD,
            :UOM_CD,
            :GROUP_ID,
            :LOT_CD,
            :QTY,
            :ONHAND_QTY,
            :UNIT_COST,
            :TOTAL_COST,
            :STOCK_VALUE,
            :grn_no,
            :grn_date ,
            :PURCHASE_DATE,
            :ACCT_CD
        DO
        BEGIN
            ORDER_LINE =ORDER_LINE+1;
            FYEAR = extract(YEAR FROM DOC_DATE);
            FMONTH = EXTRACT(MONTH FROM DOC_DATE);

            update_date  = current_timestamp;

          if(QTY > 0) THEN
          BEGIN
             mode = 'I';
          END
          else
          if(QTY < 0) THEN
          BEGIN
             mode = 'O';
          END

        BEGIN
            BEGIN
                UPDATE ic_mat_stk_dt_link
                SET  ONHAND_QTY = ONHAND_QTY +:QTY
                WHERE LOT_CD = :LOT_CD
                AND GROUP_ID = :GROUP_ID
                AND UOM_CD = :UOM_CD
                AND ACCT_CODE =:ACCT_CD
                AND PURCHASE_DATE =:PURCHASE_DATE
                AND STOCK_CD = :STOCK_CD
                AND REF_NO = :grn_no
                AND REF_DATE = :grn_date;
                UPDATE IC_MAT_STK_DT_LINK
                SET ONHAND_QTY =0
                 WHERE LOT_CD = :LOT_CD
                AND GROUP_ID = :GROUP_ID
                AND UOM_CD = :UOM_CD
                AND ACCT_CODE =:ACCT_CD
                AND PURCHASE_DATE =:PURCHASE_DATE
                AND STOCK_CD = :STOCK_CD
                AND REF_NO = :grn_no
                AND REF_DATE = :grn_date
                AND ONHAND_QTY < 0;

            END
            BEGIN
               UPDATE ic_mat_stk_dt_link
               SET  TOTAL_COST =:UNIT_COST*ONHAND_QTY,
                    STOCK_VALUE =:UNIT_COST*ONHAND_QTY
             WHERE LOT_CD =:LOT_CD
             AND ACCT_CODE =:ACCT_CD
             AND PURCHASE_DATE =:PURCHASE_DATE
               AND GROUP_ID =:GROUP_ID
               AND UOM_CD = :UOM_CD
               AND STOCK_CD =:STOCK_CD;
            END
        END
        BEGIN
            BEGIN
                SELECT SUM(UNIT_COST*ONHAND_QTY), SUM(ONHAND_QTY)
                FROM IC_MAT_STK_DT_LINK
                WHERE LOT_CD =:LOT_CD
                AND ACCT_CODE =:ACCT_CD
                AND PURCHASE_DATE =:PURCHASE_DATE
                AND GROUP_ID =:GROUP_ID
                AND UOM_CD = :UOM_CD
                AND STOCK_CD =:STOCK_CD
                INTO :totalvalue,:onhandqty;
            END
            BEGIN
                UPDATE ic_mat_stk_dt
                SET  ONHAND_QTY =ONHAND_QTY +:QTY
                WHERE LOT_CD =:LOT_CD
                AND ACCT_CODE =:ACCT_CD
                AND PURCHASE_DATE =:PURCHASE_DATE
                AND GROUP_ID =:GROUP_ID
                AND UOM_CD = :UOM_CD
                AND STOCK_CD = :STOCK_CD;
            END
               /**Calculate new stock value according to new unit cost adjusted*/
            if (onhandqty > 0) then
            BEGIN
               UPDATE ic_mat_stk_dt
               SET  TOTAL_COST = :totalvalue,
                    STOCK_VALUE = :totalvalue,
                    UNIT_COST = :totalvalue/:onhandqty
               WHERE LOT_CD = :LOT_CD
               AND ACCT_CODE =:ACCT_CD
               AND PURCHASE_DATE =:PURCHASE_DATE
               AND GROUP_ID = :GROUP_ID
               AND UOM_CD = :UOM_CD
               AND STOCK_CD = :STOCK_CD;
            END

        END
        /**BECAUSE ONHAND_QTY THAT UPDATE TO IC_STOCKCARD WAS WRONG*/
              /*BY RIGHT AFTER UPDATE MUST GET FROM IC_MAT_STK_DT_LINK AFTER UPDATE*/
        BEGIN
              if (onhandqty > 0) then
              BEGIN
                 ONHAND_QTY =onhandqty;
                 total_cost = totalvalue;
                 stock_value = totalvalue;
              END
        END
        BEGIN
              INSERT INTO IC_STOCKCARD
              (ACCT_CD,DOC_NO,DOC_DATE,
              REF_NO,REF_DATE,
              UNIT_COST,TOTAL_COST,
              LOT_CD,GROUP_ID,UOM_CD,
              STOCK_VALUE,
              FMONTH,FYEAR,
              MODE,STOCK_CD,
              UPDATE_USER,UPDATE_DATE,
              MODULE,
              ORDER_LINE,
              DESCS,
              ONHAND_QTY,
              QTY,
              RESERVED_QTY,
              TRX_TYPE  ,PURCHASE_DATE
              )
              VALUES
              (:ACCT_CD,:DOC_NO,:DOC_DATE,
              :grn_no,:grn_date,
              :UNIT_COST,:TOTAL_COST,
              :LOT_CD,:GROUP_ID,:UOM_CD,
              :STOCK_VALUE,
              :FMONTH,:FYEAR,
              :MODE,:STOCK_CD,
              :UPDATE_USER,:UPDATE_DATE,
              :MODULE,
              :ORDER_LINE,
              :DESCS,:onhandqty,:QTY,0,:TRX_TYPE,:PURCHASE_DATE);
              WHEN SQLCODE - 530 DO
              BEGIN
                  EXCEPTION EX_INS_STOCKCARD;
              END
          END

          BEGIN
              UPDATE IC_STOCK_ADJUST_HD
              SET STATUS ='X'
              WHERE DOC_NO =:DOC_NO
              AND DOC_DATE =:DOC_DATE;
          END


     END /**FOR SELEC FROM IC_STOCK_ADJUST_HD*/
    end
    else
     begin
       exception e_no_row;
       exit;
     end
     suspend;
end^


ALTER PROCEDURE X_POST_MATERIAL (
    ACCT_CD VARCHAR(10),
    DOC_NO VARCHAR(15),
    DOC_DATE DATE,
    UPDATE_USER VARCHAR(10),
    MODULE VARCHAR(2),
    MODE VARCHAR(1))
AS
DECLARE VARIABLE REF_NO VARCHAR(15);
DECLARE VARIABLE REF_DATE TIMESTAMP;
DECLARE VARIABLE QTY FLOAT;
DECLARE VARIABLE UNIT_COST FLOAT;
DECLARE VARIABLE TOTAL_COST FLOAT;
DECLARE VARIABLE LOT_CD VARCHAR(15);
DECLARE VARIABLE GROUP_ID VARCHAR(10);
DECLARE VARIABLE UOM_CD VARCHAR(4);
DECLARE VARIABLE STOCK_VALUE FLOAT;
DECLARE VARIABLE FMONTH SMALLINT;
DECLARE VARIABLE FYEAR SMALLINT;
DECLARE VARIABLE STOCK_CD VARCHAR(15);
DECLARE VARIABLE UPDATE_DATE TIMESTAMP;
DECLARE VARIABLE ROW_NUM SMALLINT;
DECLARE VARIABLE ORDER_LINE SMALLINT;
DECLARE VARIABLE USAGE_QTY FLOAT;
DECLARE VARIABLE DESCS VARCHAR(60);
DECLARE VARIABLE TRX_TYPE VARCHAR(2);
DECLARE VARIABLE MELT_NO VARCHAR(10);
DECLARE VARIABLE ONHAND_QTY FLOAT;
DECLARE VARIABLE RESERVED_QTY FLOAT;
DECLARE VARIABLE ROWCOUNT INTEGER;
DECLARE VARIABLE GRN_NO VARCHAR(15);
DECLARE VARIABLE GRN_DATE TIMESTAMP;
DECLARE VARIABLE PURCHASE_DATE TIMESTAMP;
DECLARE VARIABLE PLAN_DOC VARCHAR(15);
DECLARE VARIABLE PLAN_DATE TIMESTAMP;
DECLARE VARIABLE POSTED_STATUS VARCHAR(3);
DECLARE VARIABLE CURRENT_GRN_ONHAND_QTY FLOAT;
DECLARE VARIABLE CURRENT_GRN_RESERVED_QTY FLOAT;
DECLARE VARIABLE CURRENT_LOT_ONHAND_QTY FLOAT;
DECLARE VARIABLE CURRENT_LOT_RESERVED_QTY FLOAT;
BEGIN
   select count(*)
   FROM  pl_req_dt D , PL_REQ_HD A
   WHERE
       D.doc_no = A.DOC_NO
   AND D.DOC_DATE = D.doc_date
   AND D.TRX_TYPE = A.TRX_TYPE
   AND A.DOC_NO =:DOC_NO
   AND A.DOC_DATE =:DOC_DATE
  -- AND IC_MODE =:MODE
   AND A.STATUS <> 'X'
   into :rowcount;
   if(rowcount >= 1) then
   begin
 
       BEGIN
         UPDATE_DATE = current_timestamp;
         row_num =0;
         FYEAR = extract(YEAR FROM DOC_DATE);
         FMONTH = EXTRACT(MONTH FROM DOC_DATE);
         IF (MODULE ='PL') then
         BEGIN
           order_line =0;
            FOR
             SELECT A.DOC_NO,
                    A.DOC_DATE,
                    A.req_by,
                    A.req_date,
                    ROUND(D.QTY,3), /*To avoid rounding problem 20040324*/
                    D.usaged_qty ,
                    D.UNIT_COST,
                    D.TOTAL_COST,
                    D.LOT_NO,
                    D.GROUP_ID ,
                    D.UOM,
                    D.QTY*D.UNIT_COST,
                    D.ITEM_CODE,a.descs ,
                    A.trx_type,
                    A.melt_no,
                    D.REF_NO,
                    D.REF_DATE  ,
                    d.purchase_date   ,
                    D.ACCT_CD  ,
                    a.plan_doc, 
                    a.plan_date
             FROM  pl_req_dt D , PL_REQ_HD A
             WHERE
                 D.doc_no = A.DOC_NO
             AND D.DOC_DATE = D.doc_date
             AND D.TRX_TYPE = A.TRX_TYPE
             AND A.DOC_NO =:DOC_NO
             AND A.DOC_DATE =:DOC_DATE
             AND IC_MODE =:MODE
             AND A.STATUS <> 'X'
             AND D.qty > 0 --eliminate zero value insert to stockcard 20071103
             ORDER BY    D.DOC_DATE,D.item_code      /*MUST ADD ORDER by AON 20040521 10:00AM*/
             INTO :DOC_NO,:DOC_DATE,
                  :REF_NO,:REF_DATE,:QTY,:usage_qty ,
                  :UNIT_COST,:TOTAL_COST,
                  :LOT_CD,:GROUP_ID,:UOM_CD,
                  :STOCK_VALUE,:STOCK_CD,:descs,
                  :trx_type,:melt_no,:grn_no,:grn_date,:purchase_date,:ACCT_CD ,:plan_doc,:plan_date
             DO
             BEGIN
    
           /***/
              /* ACCT_CD ='PLMODULE';*/
              /*22/01/2008
              1.Melt validate if (not previouse melt no posted could not post a current) then raise exception
              2.if issue date is early that ref_date of goods received then raise exception*/
            --  select CAST( result AS VARCHAR(3)) from X_IS_PREV_MELT_POSTED (:plan_doc,:plan_date, :MELT_NO) into :posted_status;
            -- if (posted_status = 'NO') then
             -- Begin
               /*case 1. rollback*/
                --  exception ex_melt_no_post_error;
                 -- exit;
              -- end
               /*case 2 rollback*/
               if (doc_date > ref_date) then
               begin
                   exception ex_grn_date_check;
                   exit;
               end
               order_line = order_line +1 ;
               if (ACCT_CD='SUPP') then
               BEGIN
                   ACCT_CD=STOCK_CD;
               END

               if (MODE='O') then
                    /**Insert melt_no instead of ref_no into stock card*/
               BEGIN
                   INSERT INTO IC_STOCKCARD (ACCT_CD,DOC_NO,DOC_DATE,REF_NO,REF_DATE,QTY,UNIT_COST,TOTAL_COST,LOT_CD,GROUP_ID,UOM_CD,STOCK_VALUE,FMONTH,FYEAR,MODE,STOCK_CD,UPDATE_USER,UPDATE_DATE,MODULE,ORDER_LINE,descs,TRX_TYPE,MELT_NO,RESERVED_QTY,ONHAND_QTY,PURCHASE_DATE)
                   VALUES (:ACCT_CD,:DOC_NO,:DOC_DATE,:grn_no,:grn_date,-:QTY,:UNIT_COST,:TOTAL_COST,:LOT_CD,:GROUP_ID,:UOM_CD,:STOCK_VALUE,:FMONTH,:FYEAR,:MODE,:STOCK_CD,:UPDATE_USER,:UPDATE_DATE,:MODULE,:ORDER_LINE,:descs,:TRX_TYPE,:MELT_NO,0,:ONHAND_QTY,:PURCHASE_DATE);
                   WHEN SQLCODE - 530 DO
                   BEGIN
                     EXCEPTION EX_INS_STOCKCARD;
                   END
               END
               ELSE
               BEGIN
                 INSERT INTO IC_STOCKCARD (ACCT_CD,DOC_NO,DOC_DATE,REF_NO,REF_DATE,QTY,UNIT_COST,TOTAL_COST,LOT_CD,GROUP_ID,UOM_CD,STOCK_VALUE,FMONTH,FYEAR,MODE,STOCK_CD,UPDATE_USER,UPDATE_DATE,MODULE,ORDER_LINE,descs,TRX_TYPE,MELT_NO,RESERVED_QTY,ONHAND_QTY,PURCHASE_DATE)
                   VALUES (:ACCT_CD,:DOC_NO,:DOC_DATE,:grn_no,:grn_date,:QTY,:UNIT_COST,:TOTAL_COST,:LOT_CD,:GROUP_ID,:UOM_CD,:STOCK_VALUE,:FMONTH,:FYEAR,:MODE,:STOCK_CD,:UPDATE_USER,:UPDATE_DATE,:MODULE,:ORDER_LINE,:descs,:TRX_TYPE,:MELT_NO,0,:ONHAND_QTY,:PURCHASE_DATE);
                   WHEN SQLCODE - 530 DO
                   BEGIN
                     EXCEPTION EX_INS_STOCKCARD;
                   END

               END
                       /*Stock Requestransaction */
               if (MODE ='O') then
               BEGIN

                 /**RESET STOCK RESERVED*/
                  DELETE FROM ic_stock_reserved
                  WHERE STOCK_CD = :STOCK_CD
                  AND GROUP_ID = :GROUP_ID
                  AND LOT_CD = :LOT_CD
                  AND PURCHASE_DATE =:PURCHASE_DATE
                  AND UOM_CD = :UOM_CD
                  AND REF_NO = :grn_no
                  AND REF_DATE = :grn_date
                  AND DOC_NO =:doc_no
                  AND DOC_DATE=:DOC_DATE;

               END
               /*getting currrent value 20008/06/12**/
               select sum(qty)
               from ic_stockcard
                WHERE STOCK_CD = :STOCK_CD
                AND GROUP_ID = :GROUP_ID
                AND LOT_CD = :LOT_CD
                AND PURCHASE_DATE =:PURCHASE_DATE
                AND UOM_CD = :UOM_CD
                into :CURRENT_LOT_ONHAND_QTY;

                select sum(qty)
                from ic_stockcard
                WHERE STOCK_CD = :STOCK_CD
                AND GROUP_ID = :GROUP_ID
                AND LOT_CD = :LOT_CD
                AND PURCHASE_DATE =:PURCHASE_DATE
                AND UOM_CD = :UOM_CD
                AND REF_NO = :grn_no
                AND REF_DATE = :grn_date
                into :CURRENT_GRN_ONHAND_QTY;
                select sum(qty)
                from ic_stock_reserved
                WHERE STOCK_CD = :STOCK_CD
                  AND GROUP_ID = :GROUP_ID
                  AND LOT_CD = :LOT_CD
                  AND PURCHASE_DATE =:PURCHASE_DATE
                  AND UOM_CD = :UOM_CD
                  AND REF_NO = :grn_no
                  AND REF_DATE = :grn_date
                  into :current_grn_reserved_qty;

                select sum(qty)
                from ic_stock_reserved
                WHERE STOCK_CD = :STOCK_CD
                  AND GROUP_ID = :GROUP_ID
                  AND LOT_CD = :LOT_CD
                  AND PURCHASE_DATE =:PURCHASE_DATE
                  AND UOM_CD = :UOM_CD
                into :current_lot_reserved_qty;
                if ((current_lot_onhand_qty <0) or(current_grn_onhand_qty <0)) then
                begin
                   --temporary took out 22/4/2010 :TODO Check it later
                 -- exception ex_ic_onhand_error;
                end
                else
                begin
                      if (current_grn_reserved_qty is null) then current_grn_reserved_qty =0 ;
                      if (current_lot_reserved_qty is null) then current_lot_reserved_qty =0;
                      UPDATE IC_MAT_STK_DT_LINK
                      SET ONHAND_QTY = :CURRENT_GRN_ONHAND_QTY  ,
                          RESERVED_QTY=:current_grn_reserved_qty
                      WHERE STOCK_CD = :STOCK_CD
                      AND GROUP_ID = :GROUP_ID
                      AND LOT_CD = :LOT_CD
                      AND ACCT_CODE =:ACCT_CD
                      AND PURCHASE_DATE =:PURCHASE_DATE
                      AND UOM_CD = :UOM_CD
                      AND REF_NO = :grn_no
                      AND REF_DATE = :grn_date;

                      UPDATE IC_MAT_STK_DT
                      SET ONHAND_QTY = :CURRENT_LOT_ONHAND_QTY, /**Material Actual Stock Usage QUANTITY**/
                          RESERVED_QTY =:CURRENT_LOT_RESERVED_QTY  /**ALSO UPDATE RESERVED QTY*/
                      WHERE STOCK_CD = :STOCK_CD
                      AND GROUP_ID =:GROUP_ID
                      AND LOT_CD =:LOT_CD
                      AND ACCT_CODE =:ACCT_CD
                      AND PURCHASE_DATE =:PURCHASE_DATE
                      AND UOM_CD =:UOM_CD;

                      UPDATE pl_rawmat_sheet_dt
                      SET ACTUAL_CHARGED_WEIGHT =:QTY
                      WHERE STOCK_CODE = :STOCK_CD
                      AND GROUP_ID =:GROUP_ID
                      AND LOT_NO =:LOT_CD
                      AND UOM =:UOM_CD
                      AND MELT_NO =:MELT_NO;
               END /**if current onhand > 0*/
               BEGIN
                  UPDATE PL_REQ_HD
                  SET STATUS ='X'
                  WHERE DOC_NO =:DOC_NO
                  AND DOC_DATE =:DOC_DATE
                  AND TRX_TYPE =:TRX_TYPE;
               END
    
             END
           END /**MODULE PL*/
      END

   end
   else
   begin
     exception e_no_row;
     exit;
   end

   SUSPEND;
END^


ALTER PROCEDURE X_POST_PHYSICAL_COUNT (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP)
AS
DECLARE VARIABLE ITEM_CODE VARCHAR(15);
DECLARE VARIABLE UOM_CD VARCHAR(4);
DECLARE VARIABLE GROUP_ID VARCHAR(10);
DECLARE VARIABLE LOT_NO VARCHAR(15);
DECLARE VARIABLE PURCHASE_DATE TIMESTAMP;
DECLARE VARIABLE QTY FLOAT;
DECLARE VARIABLE UNIT_COST FLOAT;
DECLARE VARIABLE TOTAL_COST FLOAT;
DECLARE VARIABLE ONHAND_QTY FLOAT;
DECLARE VARIABLE REF_NO VARCHAR(15);
DECLARE VARIABLE REF_DATE TIMESTAMP;
DECLARE VARIABLE ACCT_CD VARCHAR(10);
DECLARE VARIABLE VQTY FLOAT;
DECLARE VARIABLE TRX_TYPE VARCHAR(4);
DECLARE VARIABLE TRX_DESCS VARCHAR(60);
DECLARE VARIABLE ORDER_LINE SMALLINT;
DECLARE VARIABLE FLOT_ONHAND_QTY FLOAT;
begin

  for select
  D.ITEM_CODE, D.UOM_CD,
  D.GROUP_ID, D.LOT_NO, D.PURCHASE_DATE,
  D.QTY, D.UNIT_COST, D.TOTAL_COST, D.ONHAND_QTY,
  H.descs,H.trx_type, D.REF_NO, D.REF_DATE, D.ACCT_CD, D.VQTY,
  DT.order_line
  FROM ic_stock_adjust_dt D , ic_mat_stk_dt_link  dT ,ic_stock_adjust_hd h
  WHERE d.doc_no =h.doc_no
  and d.doc_date =h.doc_date
  and D.item_code=DT.stock_cd
  AND D.group_id=DT.GROUP_ID
  AND D.uom_cd =DT.UOM_CD
  AND D.lot_no =DT.lot_cd
  AND D.PURCHASE_DATE =DT.purchase_date
  AND D.ref_no = DT.REF_NO
  AND D.ref_date =DT.ref_date
  AND D.doc_no=:ADOC_NO
  AND D.doc_date =:ADOC_DATE
  and h.status='N'
  ORDER BY  D.ITEM_CODE,D.GROUP_ID , D.PURCHASE_DATE,d.lot_no, d.ref_no, D.REF_DATE
  INTO
  :ITEM_CODE, :UOM_CD, :GROUP_ID, :LOT_NO, :PURCHASE_DATE,
  :QTY, :UNIT_COST, :TOTAL_COST, :ONHAND_QTY,
  :TRX_DESCS,:TRX_TYPE, :REF_NO, :REF_DATE, :ACCT_CD, :VQTY,
  :order_line
  DO
  /*1 INSERT INTO STOCKCARD WITH NEW VALUE*/
  /*2 update ic_mat_stk_link_dt*/
  /*3.update ic_mat_stk_dt sum onhand from ic_mat_stk_link_dt*/
  BEGIN
     begin
        INSERT INTO IC_STOCKCARD (
        ACCT_CD,    DOC_NO,    DOC_DATE,
        REF_NO, REF_DATE, QTY, UNIT_COST,
        TOTAL_COST,LOT_CD, PURCHASE_DATE,
        GROUP_ID,UOM_CD, STOCK_VALUE,
        FMONTH, FYEAR, MODE  , STOCK_CD,
        UPDATE_USER,UPDATE_DATE,MODULE,
        ORDER_LINE,ONHAND_QTY, RESERVED_QTY,
        DESCS, TRX_TYPE, MELT_NO)
        values (:acct_cd,:adoc_no,:adoc_date,
        :REF_NO,:REF_DATE,:VQTY,:UNIT_COST,
        :VQTY*:UNIT_COST,:LOT_NO,:PURCHASE_DATE,
        :GROUP_ID,:UOM_CD,:VQTY*:UNIT_COST,
        EXTRACT(MONTH FROM :ADOC_DATE),EXTRACT(year FROM :ADOC_DATE),
        'I',:item_code,'BRD',current_timestamp,'IC',
       :ORDER_LINE,:ONHAND_QTY,0,:trx_descs,
       :trx_type,'MELT_NO' );
       end

         BEGIN
           update ic_mat_stk_dt_link
            set onhand_qty =round(:vqty,2),
                reserved_qty =0,
                unit_cost =:unit_cost,
                last_purchase_price=:unit_cost ,
                total_cost =round(onhand_qty*unit_cost,2),
                stock_value=round(onhand_qty*unit_cost,2)
           where stock_cd =:item_code
           and uom_cd =:uom_cd
           and group_id =:group_id
           and lot_cd =:lot_no
           and acct_code =:ACCT_CD
           and purchase_date =:purchase_date
           and ref_no =:ref_no
           and ref_date =:ref_date
           and order_line=:ORDER_LINE;
          END
          begin
              update ic_stock_adjust_dt
              set qty =round(:VQTY,2)
              where doc_no =:adoc_no
              and doc_date =:adoc_date
              and item_code =:ITEM_CODE
              and group_id =:GROUP_ID
              and lot_no =:LOT_NO
              and purchase_date=:PURCHASE_DATE
              and ref_no =:ref_no
              and ref_date =:ref_date
              and uom_cd =:UOM_CD
              and acct_cd =:ACCT_CD ;
          end


       begin
          select sum(onhand_qty)
          from ic_mat_stk_dt_link
           where stock_cd =:item_code
           and uom_cd =:uom_cd
           and group_id =:group_id
           and lot_cd =:lot_no
           and acct_code =:ACCT_CD
           and purchase_date =:purchase_date
           and order_line=:ORDER_LINE
           into :flot_onhand_qty;
    
           begin
             update ic_mat_stk_dt
             set onhand_qty =:flot_onhand_qty,
                 reserved_qty =0,
                 unit_cost =:unit_cost  ,
               total_cost =onhand_qty*unit_cost
            where stock_cd =:item_code
           and uom_cd =:uom_cd
           and group_id =:group_id
           and lot_cd =:lot_no
           and acct_code =:ACCT_CD
           and purchase_date =:purchase_date
           and order_line=:ORDER_LINE;
           end
        end
   END
   BEGIN
    UPDATE ic_stock_adjust_hd
    SET STATUS ='X'
    WHERE DOC_NO =:ADOC_NO
    AND DOC_DATE =:ADOC_DATE
    AND STATUS ='N';
  END
  /* Procedure Text */

  suspend;
end^


ALTER PROCEDURE X_POST_STOCK_ADJUST (
    DOC_NO VARCHAR(15),
    DOC_DATE DATE,
    MODULE VARCHAR(2),
    ADJUST_FLAG VARCHAR(1),
    MODE VARCHAR(1))
AS
declare variable STOCK_CD varchar(15);
declare variable GROUP_ID varchar(10);
declare variable UOM_CD varchar(4);
declare variable REF_NO varchar(15);
declare variable UNIT_COST float;
declare variable LOT_CD varchar(15);
declare variable REF_DATE timestamp;
declare variable QTY float;
declare variable STOCK_VALUE float;
declare variable TOTAL_COST float;
declare variable ONHAND_QTY float;
declare variable ACCT_CD varchar(10);
declare variable ORDER_LINE smallint;
declare variable DESCS varchar(60);
declare variable UPDATE_USER varchar(10);
declare variable UPDATE_DATE timestamp;
declare variable FMONTH smallint;
declare variable FYEAR smallint;
declare variable TRX_TYPE varchar(2);
declare variable ROWCOUNT integer;
declare variable GRN_NO varchar(15);
declare variable GRN_DATE timestamp;
declare variable TOTALVALUE float;
declare variable ONHANDQTY float;
declare variable PURCHASE_DATE timestamp;
declare variable STOCK_DESCS varchar(60);
BEGIN
    ORDER_LINE=0;
    select count(*)
    FROM ic_stock_adjust_hd A,
         ic_stock_adjust_DT B
    WHERE B.DOC_NO =A.DOC_NO
      AND A.DOC_DATE = B.DOC_DATE
      AND A.DOC_NO =:DOC_NO
      AND A.DOC_DATE =:DOC_DATE
    into :rowcount;
    if(rowcount >= 1) then
    begin
    
        BEGIN
          REF_NO =DOC_NO;
          REF_DATE =DOC_DATE;
        /*  ACCT_CD ='ICMODULE';*/
    
            FOR SELECT
                A.DESCS,
                A.UPDATE_USER,
                A.UPDATE_DATE,
                A.TRX_TYPE,
                B.ITEM_CODE,
                B.UOM_CD,
                B.GROUP_ID,
                B.LOT_NO,
                B.QTY,
                B.ONHAND_QTY,
                B.UNIT_COST,
                B.TOTAL_COST,
                B.QTY*B.UNIT_COST,
                B.REF_NO,
                B.REF_DATE    ,
                b.purchase_date,
                b.acct_cd
                FROM ic_stock_adjust_hd A,
                     ic_stock_adjust_DT B
                WHERE B.DOC_NO =A.DOC_NO
                AND A.DOC_DATE = B.DOC_DATE
                AND A.DOC_NO =:DOC_NO
                AND A.DOC_DATE =:DOC_DATE
                INTO
                :DESCS,
                :UPDATE_USER,
                :UPDATE_DATE,
                :TRX_TYPE,
                :STOCK_CD,
                :UOM_CD,
                :GROUP_ID,
                :LOT_CD,
                :QTY,
                :ONHAND_QTY,
                :UNIT_COST,
                :TOTAL_COST,
                :STOCK_VALUE,
                :grn_no,
                :grn_date,
                :purchase_date,
                :acct_cd
            DO
            BEGIN
                update_date = current_timestamp;
                ORDER_LINE =ORDER_LINE+1;
                FYEAR = extract(YEAR FROM DOC_DATE);
                FMONTH = EXTRACT(MONTH FROM DOC_DATE);
                select max(en_descs)
                from ic_mat_stk_hd
                where stock_cd =:stock_cd
                into :stock_descs;
    
            if (ADJUST_FLAG ='I') then
            BEGIN
               TRX_TYPE ='II';
                BEGIN
                INSERT INTO IC_MAT_STK_DT (
                       STOCK_CD             ,
                       GROUP_ID             ,
                       UOM_CD               ,
                       LOT_CD               ,
                       UNIT_COST            ,
                       LAST_PURCHASE_PRICE  ,
                       PURCHASE_DATE        ,
                       ONHAND_QTY           ,
                       RESERVED_QTY         ,
                       STOCK_VALUE          ,
                       TOTAL_COST           ,
                       ACCT_CODE            ,
                       ORDER_LINE    )
                       values(:STOCK_CD,
                       :GROUP_ID,
                       :UOM_CD,
                       :LOT_CD,
                       :UNIT_COST,
                       :UNIT_COST,
                       :REF_DATE,
                       :QTY,
                       0,
                       :STOCK_VALUE,
                       :TOTAL_COST,
                       :ACCT_CD,
                       :ORDER_LINE);
                      WHEN SQLCODE - 530 DO
                      BEGIN
                          EXCEPTION EX_INS_STK_DT;
                      END
                  END
                  BEGIN
                       INSERT INTO IC_MAT_STK_DT_LINK (
                       STOCK_CD             ,
                       GROUP_ID             ,
                       UOM_CD               ,
                       LOT_CD               ,
                       UNIT_COST            ,
                       LAST_PURCHASE_PRICE  ,
                       PURCHASE_DATE        ,
                       ONHAND_QTY           ,
                       RESERVED_QTY         ,
                       STOCK_VALUE          ,
                       TOTAL_COST           ,
                       ACCT_CODE            ,
                       ORDER_LINE           ,
                       REF_NO               ,
                       REF_DATE
                       )
                       values(:STOCK_CD,
                       :GROUP_ID,
                       :UOM_CD,
                       :LOT_CD,
                       :UNIT_COST,
                       :UNIT_COST,
                       :PURCHASE_DATE,
                       :QTY,
                       0,
                       :STOCK_VALUE,
                       :TOTAL_COST,
                       :ACCT_CD,
                       :ORDER_LINE,
                       :grn_no,
                       :grn_date
                     );
                      WHEN SQLCODE - 530 DO
                      BEGIN
                          EXCEPTION EX_INS_STK_DT;
                      END

                  END
                  /**INSERT INTO PO_ORDER DT*/
                  BEGIN
                     INSERT INTO PO_ORDER_DT (ITEM_CODE,LINE_NO,ORDER_DATE,SUPP_CODE,UOM,ORDER_NO,ITEM_DESCS,UNIT_COST,TOTAL_AMT,REMARKS,DISCS_AMT,TAX_AMT,BASE_AMT,TAX_CD,DISCS_CD,QTY,TAX_RATE,STATUS,GRN_QTY,LOT_NO,GROUP_ID,MARKUP)
                     VALUES (:STOCK_CD,:ORDER_LINE,:DOC_DATE,'SUPP',:UOM_CD,:DOC_NO,:STOCK_DESCS,:UNIT_COST,:TOTAL_COST,'',0,0,:TOTAL_COST,'','',:QTY,0,'A',0,:DOC_NO,:GROUP_ID,0);
                  END


            END/**IF ADJUST FLAG ='I'**/
            if (ADJUST_FLAG ='C')  then
              BEGIN
                TRX_TYPE ='IC';
                  BEGIN
                       UPDATE ic_mat_stk_dt_link
                       SET  UNIT_COST = :UNIT_COST,
                            LAST_PURCHASE_PRICE = :UNIT_COST
                       WHERE LOT_CD = :LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE
                       AND GROUP_ID = :GROUP_ID
                       AND UOM_CD = :UOM_CD
                       AND STOCK_CD = :STOCK_CD
                       AND REF_NO = :grn_no
                       AND REF_DATE = :grn_date;
            
                       /**Calculate new stock value according to new unit cost adjusted*/
                       UPDATE ic_mat_stk_dt_link
                       SET  TOTAL_COST = :UNIT_COST*ONHAND_QTY,
                            STOCK_VALUE = :UNIT_COST*ONHAND_QTY
                       WHERE LOT_CD = :LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE

                       AND GROUP_ID = :GROUP_ID
                       AND UOM_CD = :UOM_CD
                       AND STOCK_CD = :STOCK_CD
                       AND REF_NO = :grn_no
                       AND REF_DATE = :grn_date;
                       /**ALSO UPDATE BACK TO PURCHASE ORDER**/
                       /**AND MELT SHEET*/
                       BEGIN
                        /*case when cost update not directly update to unit_Cost but update to update
                        price instead 20040318aon*/
                          UPDATE PO_ORDER_DT
                          SET update_price=:unit_cost
                          where  order_no =:lot_cd
                          AND order_date =:PURCHASE_DATE
                          and item_code =:stock_cd;


                          UPDATE PO_ORDER_DT
                          SET total_amt =:unit_cost*qty  ,
                              update_total_amt =:unit_cost*qty
                          where
                           order_no =:lot_cd
                          AND order_date =:PURCHASE_DATE
                          and item_code =:stock_cd
                          and group_id =:group_id
                          and uom = :uom_cd;

                          UPDATE PL_RAWMAT_SHEET_DT
                          SET UNIT_COST =:UNIT_COST
                          WHERE STOCK_CODE =:STOCK_CD
                          and group_id =:group_id
                          AND LOT_NO =:LOT_CD
                          AND UOM =:UOM_CD;

                          UPDATE PL_RAWMAT_SHEET_DT
                          SET  TOTAL_COST = UNIT_COST*CHARGED_WEIGHT
                          WHERE STOCK_CODE =:STOCK_CD
                          and group_id =:group_id
                          AND LOT_NO =:LOT_CD
                          AND UOM =:UOM_CD;
                         /*20080122 update all update cost back to stockcard*/
                          update ic_stockcard
                          set unit_cost = :UNIT_COST,
                              total_cost = unit_cost*qty,
                              stock_value = unit_cost*qty
                             WHERE LOT_CD = :LOT_CD
                           AND PURCHASE_DATE =:PURCHASE_DATE
                           AND GROUP_ID = :GROUP_ID
                           AND UOM_CD = :UOM_CD
                           AND STOCK_CD = :STOCK_CD
                           AND REF_NO = :grn_no
                           AND REF_DATE = :grn_date  ;
                          -- and doc_date <=:doc_date;
                          --2009/05/26 update unit cost to be latest
                          /*20080122 update all update cost back to stockcard*/

                       END
                  END
                  BEGIN
                     BEGIN
                       SELECT SUM(UNIT_COST*ONHAND_QTY),SUM(ONHAND_QTY)
                       FROM IC_MAT_STK_DT_LINK
                       WHERE LOT_CD = :LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE

                       AND GROUP_ID = :GROUP_ID
                       AND UOM_CD = :UOM_CD
                       AND STOCK_CD = :STOCK_CD
                       INTO :totalvalue,:onhandqty;
                     END
                     if (onhandqty > 0) then
                     BEGIN
                       UPDATE ic_mat_stk_dt
                       SET  UNIT_COST =:totalvalue/:onhandqty
                       WHERE LOT_CD =:LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE

                       AND GROUP_ID =:GROUP_ID
                       AND UOM_CD = :UOM_CD
                       AND STOCK_CD =:STOCK_CD;
                     END
                      /**Calculate new stock value according to new unit cost adjusted*/
                     BEGIN
                       UPDATE ic_mat_stk_dt
                       SET  TOTAL_COST = :totalvalue,
                            STOCK_VALUE = :totalvalue
                       WHERE LOT_CD =:LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE

                       AND GROUP_ID =:GROUP_ID
                       AND UOM_CD = :UOM_CD
                       AND STOCK_CD =:STOCK_CD;
                     END
                 END

              END
            if (ADJUST_FLAG ='Q')  then
            BEGIN
              if (mode ='I') then
                BEGIN
                  TRX_TYPE='IQ';
                   BEGIN
                        UPDATE ic_mat_stk_dt
                        SET  ONHAND_QTY =ONHAND_QTY +:QTY
                        WHERE LOT_CD =:LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE

                        AND GROUP_ID =:GROUP_ID
                        AND UOM_CD = :UOM_CD
                        AND STOCK_CD =:STOCK_CD;
                   END
                   BEGIN
                        UPDATE ic_mat_stk_dt_link
                        SET  ONHAND_QTY =ONHAND_QTY +:QTY
                        WHERE LOT_CD = :LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE

                        AND GROUP_ID = :GROUP_ID
                        AND UOM_CD = :UOM_CD
                        AND STOCK_CD = :STOCK_CD
                        AND REF_NO = :grn_no
                        AND REF_DATE = :grn_date;
                   END
                END
              if (MODE ='O') then
                BEGIN
                   TRX_TYPE='OQ';
                    BEGIN
                      UPDATE ic_mat_stk_dt_link
                      SET  ONHAND_QTY =ONHAND_QTY -:QTY
                      WHERE LOT_CD =:LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE

                      AND GROUP_ID =:GROUP_ID
                      AND UOM_CD = :UOM_CD
                      AND STOCK_CD =:STOCK_CD
                      AND REF_NO = :grn_no
                      AND REF_DATE = :grn_date;

                       /**Calculate new stock value according to new unit cost adjusted*/
                      UPDATE ic_mat_stk_dt_link
                      SET  TOTAL_COST =:UNIT_COST*ONHAND_QTY,
                           STOCK_VALUE =:UNIT_COST*ONHAND_QTY
                      WHERE LOT_CD =:LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE

                      AND GROUP_ID =:GROUP_ID
                      AND UOM_CD = :UOM_CD
                      AND STOCK_CD =:STOCK_CD
                      AND REF_NO = :grn_no
                      AND REF_DATE = :grn_date;
                    END
                    BEGIN
                      BEGIN
                          SELECT SUM(UNIT_COST*ONHAND_QTY),SUM(ONHAND_QTY)
                          FROM ic_mat_stk_dt_link
                          WHERE LOT_CD =:LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE

                          AND GROUP_ID =:GROUP_ID
                          AND UOM_CD = :UOM_CD
                          AND STOCK_CD =:STOCK_CD
                          INTO :totalvalue,:onhandqty;
                      END
                      BEGIN
                          UPDATE ic_mat_stk_dt
                          SET  ONHAND_QTY =ONHAND_QTY -:QTY
                          WHERE LOT_CD =:LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE

                          AND GROUP_ID =:GROUP_ID
                          AND UOM_CD = :UOM_CD
                          AND STOCK_CD =:STOCK_CD;
                      END
                       /**Calculate new stock value according to new unit cost adjusted*/
                       if (onhandqty > 0) then
                      BEGIN
                          UPDATE ic_mat_stk_dt
                          SET  TOTAL_COST = :totalvalue,
                               STOCK_VALUE = :totalvalue,
                               UNIT_COST = :totalvalue/:onhandqty
                          WHERE LOT_CD =:LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE

                          AND GROUP_ID =:GROUP_ID
                          AND UOM_CD = :UOM_CD
                          AND STOCK_CD =:STOCK_CD;
                      END
                    END

                END
            END
            BEGIN
              /**BECAUSE ONHAND_QTY THAT UPDATE TO IC_STOCKCARD WAS WRONG*/
              /*BY RIGHT AFTER UPDATE MUST GET FROM IC_MAT_STK_DT_LINK AFTER UPDATE*/
              if (onhandqty > 0) then
              BEGIN
                 ONHAND_QTY =onhandqty;
                 STOCK_VALUE =totalvalue ;
                 TOTAL_COST =totalvalue;
              END
            END
            BEGIN
                      INSERT INTO IC_STOCKCARD
                      (ACCT_CD,DOC_NO,DOC_DATE,
                      REF_NO,REF_DATE,
                      QTY,UNIT_COST,TOTAL_COST,
                      LOT_CD,GROUP_ID,UOM_CD,
                      STOCK_VALUE,
                      FMONTH,FYEAR,
                      MODE,STOCK_CD,
                      UPDATE_USER,UPDATE_DATE,
                      MODULE,
                      ORDER_LINE,
                      DESCS,
                      ONHAND_QTY,
                      RESERVED_QTY,
                      TRX_TYPE ,PURCHASE_DATE
                      )
                      VALUES
                      (:ACCT_CD,:DOC_NO,:DOC_DATE,
                      :grn_no,:grn_date,
                      :QTY,:UNIT_COST,:TOTAL_COST,
                      :LOT_CD,:GROUP_ID,:UOM_CD,
                      :STOCK_VALUE,
                      :FMONTH,:FYEAR,
                      :MODE,:STOCK_CD,
                      :UPDATE_USER,:UPDATE_DATE,
                      :MODULE,
                      :ORDER_LINE,
                      :DESCS,:onhandqty,0,:TRX_TYPE,:PURCHASE_DATE);
                      WHEN SQLCODE - 530 DO
                      BEGIN
                          EXCEPTION EX_INS_STOCKCARD;
                      END
              END
    
    
              UPDATE IC_STOCK_ADJUST_HD
              SET STATUS ='X'
              WHERE DOC_NO =:DOC_NO
              AND DOC_DATE =:DOC_DATE;
    
     
    
         END /**FOR SELEC FROM IC_STOCK_ADJUST_HD*/
       END
    end
    else
    begin
      exception e_no_row;
      exit;
    end

  suspend;

end^


ALTER PROCEDURE X_POST_STOCK_ADJUST_2 (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AMODE VARCHAR(1),
    AMODULE VARCHAR(2),
    AUSERID VARCHAR(10))
AS
declare variable STOCK_CD varchar(15);
declare variable GROUP_ID varchar(10);
declare variable UOM_CD varchar(4);
declare variable REF_NO varchar(15);
declare variable UNIT_COST float;
declare variable LOT_CD varchar(15);
declare variable REF_DATE timestamp;
declare variable QTY float;
declare variable STOCK_VALUE float;
declare variable TOTAL_COST float;
declare variable ONHAND_QTY float;
declare variable ACCT_CD varchar(10);
declare variable ORDER_LINE smallint;
declare variable DESCS varchar(60);
declare variable UPDATE_USER varchar(10);
declare variable UPDATE_DATE timestamp;
declare variable FMONTH smallint;
declare variable FYEAR smallint;
declare variable TRX_TYPE varchar(2);
declare variable ROWCOUNT integer;
declare variable MELT_NO varchar(10);
declare variable GRN_NO varchar(15);
declare variable GRN_DATE timestamp;
declare variable TOTALVALUE float;
declare variable ONHANDQTY float;
declare variable PURCHASE_DATE timestamp;
BEGIN
    ORDER_LINE=0;

    SELECT COUNT(*) 
    FROM ic_stock_adjust_hd A,
         ic_stock_adjust_DT B
    WHERE B.DOC_NO =A.DOC_NO
    AND A.DOC_DATE = B.DOC_DATE
    AND A.DOC_NO =:ADOC_NO
    AND CAST(A.DOC_DATE AS DATE) =:ADOC_DATE
    AND A.STATUS = 'N'
    into :rowcount;
    if(rowcount >= 1) then
    begin
        REF_NO =ADOC_NO;
        REF_DATE =ADOC_DATE;
      /*  ACCT_CD ='ICMODULE';*/
/*        trx_type = 'IS';*/
        FOR SELECT
            A.DESCS,
            A.UPDATE_USER,
            A.UPDATE_DATE,
            A.TRX_TYPE,
            A.MELT_NO,
            B.ITEM_CODE,
            B.UOM_CD,
            B.GROUP_ID,
            B.LOT_NO,
            B.QTY,
            B.ONHAND_QTY,
            B.UNIT_COST,
            B.TOTAL_COST,
            B.QTY*B.UNIT_COST,
            B.REF_NO,
            B.REF_DATE               ,
            B.purchase_date,
            B.acct_cd
            FROM ic_stock_adjust_hd A,
                 ic_stock_adjust_DT B
            WHERE B.DOC_NO =A.DOC_NO
            AND A.DOC_DATE = B.DOC_DATE
            AND A.DOC_NO =:ADOC_NO
            AND CAST(A.DOC_DATE AS DATE) =:ADOC_DATE
            AND A.STATUS = 'N'
            INTO
            :DESCS,
            :UPDATE_USER,
            :UPDATE_DATE,
            :trx_type,
            :melt_no,
            :STOCK_CD,
            :UOM_CD,
            :GROUP_ID,
            :LOT_CD,
            :QTY,
            :ONHAND_QTY,
            :UNIT_COST,
            :TOTAL_COST,
            :STOCK_VALUE,
            :grn_no,
            :grn_date ,
            :PURCHASE_DATE,
            :ACCT_CD
        DO
        BEGIN
            ORDER_LINE =ORDER_LINE+1;
            FYEAR = extract(YEAR FROM ADOC_DATE);
            FMONTH = EXTRACT(MONTH FROM ADOC_DATE);

            update_date  = current_timestamp;

          if(QTY > 0) THEN
          BEGIN
             amode = 'I';
          END
          else
          if(QTY < 0) THEN
          BEGIN
             amode = 'O';
          END
        /**IF ADJUST FLAG ='I'**/
          if (amode ='C')  then
              BEGIN
               -- TRX_TYPE ='IC';
                  BEGIN
                       UPDATE ic_mat_stk_dt_link
                       SET  UNIT_COST = :UNIT_COST,
                            LAST_PURCHASE_PRICE = :UNIT_COST
                       WHERE LOT_CD = :LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE
                       AND GROUP_ID = :GROUP_ID
                       AND UOM_CD = :UOM_CD
                       AND STOCK_CD = :STOCK_CD
                       AND REF_NO = :grn_no
                       AND REF_DATE = :grn_date;
            
                       /**Calculate new stock value according to new unit cost adjusted*/
                       UPDATE ic_mat_stk_dt_link
                       SET  TOTAL_COST = :UNIT_COST*ONHAND_QTY,
                            STOCK_VALUE = :UNIT_COST*ONHAND_QTY
                       WHERE LOT_CD = :LOT_CD
                       AND ACCT_CODE =:ACCT_CD
                       AND PURCHASE_DATE =:PURCHASE_DATE

                       AND GROUP_ID = :GROUP_ID
                       AND UOM_CD = :UOM_CD
                       AND STOCK_CD = :STOCK_CD
                       AND REF_NO = :grn_no
                       AND REF_DATE = :grn_date;
                       /**ALSO UPDATE BACK TO PURCHASE ORDER**/
                       /**AND MELT SHEET*/
                       BEGIN
                        /*case when cost update not directly update to unit_Cost but update to update
                        price instead 20040318aon*/
                          UPDATE PO_ORDER_DT
                          SET update_price=:unit_cost
                          where  order_no =:lot_cd
                          AND order_date =:PURCHASE_DATE
                          and item_code =:stock_cd;


                          UPDATE PO_ORDER_DT
                          SET total_amt =:unit_cost*qty  ,
                              update_total_amt =:unit_cost*qty
                          where
                           order_no =:lot_cd
                          AND order_date =:PURCHASE_DATE
                          and item_code =:stock_cd
                          and group_id =:group_id
                          and uom = :uom_cd;

                          UPDATE PL_RAWMAT_SHEET_DT
                          SET UNIT_COST =:UNIT_COST
                          WHERE STOCK_CODE =:STOCK_CD
                          and group_id =:group_id
                          AND LOT_NO =:LOT_CD
                          AND UOM =:UOM_CD;

                          UPDATE PL_RAWMAT_SHEET_DT
                          SET  TOTAL_COST = UNIT_COST*CHARGED_WEIGHT
                          WHERE STOCK_CODE =:STOCK_CD
                          and group_id =:group_id
                          AND LOT_NO =:LOT_CD
                          AND UOM =:UOM_CD;
                         /*20080122 update all update cost back to stockcard*/
                          update ic_stockcard
                          set unit_cost = :UNIT_COST,
                              total_cost = unit_cost*qty,
                              stock_value = unit_cost*qty
                             WHERE LOT_CD = :LOT_CD
                           AND PURCHASE_DATE =:PURCHASE_DATE
                           AND GROUP_ID = :GROUP_ID
                           AND UOM_CD = :UOM_CD
                           AND STOCK_CD = :STOCK_CD
                           AND REF_NO = :grn_no
                           AND REF_DATE = :grn_date ;
                         --  and doc_date <=:Adoc_date;
                          /*20080122 update all update cost back to stockcard*/

                       END
                 end
              END/*if mode -C cost adjust*/
        BEGIN
            BEGIN
                UPDATE ic_mat_stk_dt_link
                SET  ONHAND_QTY = ONHAND_QTY +:QTY
                WHERE LOT_CD = :LOT_CD
                AND GROUP_ID = :GROUP_ID
                AND UOM_CD = :UOM_CD
                AND ACCT_CODE =:ACCT_CD
                AND PURCHASE_DATE =:PURCHASE_DATE
                AND STOCK_CD = :STOCK_CD
                AND REF_NO = :grn_no
                AND REF_DATE = :grn_date;
                UPDATE IC_MAT_STK_DT_LINK
                SET ONHAND_QTY =0
                 WHERE LOT_CD = :LOT_CD
                AND GROUP_ID = :GROUP_ID
                AND UOM_CD = :UOM_CD
                AND ACCT_CODE =:ACCT_CD
                AND PURCHASE_DATE =:PURCHASE_DATE
                AND STOCK_CD = :STOCK_CD
                AND REF_NO = :grn_no
                AND REF_DATE = :grn_date
                AND ONHAND_QTY < 0;

            END
            BEGIN
               UPDATE ic_mat_stk_dt_link
               SET  TOTAL_COST =:UNIT_COST*ONHAND_QTY,
                    STOCK_VALUE =:UNIT_COST*ONHAND_QTY
             WHERE LOT_CD =:LOT_CD
             AND ACCT_CODE =:ACCT_CD
             AND PURCHASE_DATE =:PURCHASE_DATE
               AND GROUP_ID =:GROUP_ID
               AND UOM_CD = :UOM_CD
               AND STOCK_CD =:STOCK_CD;
            END
        END
        BEGIN
            BEGIN
                SELECT SUM(UNIT_COST*ONHAND_QTY), SUM(ONHAND_QTY)
                FROM IC_MAT_STK_DT_LINK
                WHERE LOT_CD =:LOT_CD
                AND ACCT_CODE =:ACCT_CD
                AND PURCHASE_DATE =:PURCHASE_DATE
                AND GROUP_ID =:GROUP_ID
                AND UOM_CD = :UOM_CD
                AND STOCK_CD =:STOCK_CD
                INTO :totalvalue,:onhandqty;
            END
            BEGIN
                UPDATE ic_mat_stk_dt
                SET  ONHAND_QTY =ONHAND_QTY +:QTY
                WHERE LOT_CD =:LOT_CD
                AND ACCT_CODE =:ACCT_CD
                AND PURCHASE_DATE =:PURCHASE_DATE
                AND GROUP_ID =:GROUP_ID
                AND UOM_CD = :UOM_CD
                AND STOCK_CD = :STOCK_CD;
            END
               /**Calculate new stock value according to new unit cost adjusted*/
            if (onhandqty > 0) then
            BEGIN
               UPDATE ic_mat_stk_dt
               SET  TOTAL_COST = :totalvalue,
                    STOCK_VALUE = :totalvalue,
                    UNIT_COST = :totalvalue/:onhandqty
               WHERE LOT_CD = :LOT_CD
               AND ACCT_CODE =:ACCT_CD
               AND PURCHASE_DATE =:PURCHASE_DATE
               AND GROUP_ID = :GROUP_ID
               AND UOM_CD = :UOM_CD
               AND STOCK_CD = :STOCK_CD;
            END

        END
        /**BECAUSE ONHAND_QTY THAT UPDATE TO IC_STOCKCARD WAS WRONG*/
              /*BY RIGHT AFTER UPDATE MUST GET FROM IC_MAT_STK_DT_LINK AFTER UPDATE*/
        BEGIN
              if (onhandqty > 0) then
              BEGIN
                 ONHAND_QTY =onhandqty;
                 total_cost = totalvalue;
                 stock_value = totalvalue;
              END
        END
        BEGIN
              INSERT INTO IC_STOCKCARD
              (ACCT_CD,DOC_NO,DOC_DATE,
              REF_NO,REF_DATE,
              UNIT_COST,TOTAL_COST,
              LOT_CD,GROUP_ID,UOM_CD,
              STOCK_VALUE,
              FMONTH,FYEAR,
              MODE,STOCK_CD,
              UPDATE_USER,UPDATE_DATE,
              MODULE,
              ORDER_LINE,
              DESCS,
              ONHAND_QTY,
              QTY,
              RESERVED_QTY,
              TRX_TYPE  ,PURCHASE_DATE ,MELT_NO
              )
              VALUES
              (:ACCT_CD,:ADOC_NO,:ADOC_DATE,
              :grn_no,:grn_date,
              :UNIT_COST,:TOTAL_COST,
              :LOT_CD,:GROUP_ID,:UOM_CD,
              :STOCK_VALUE,
              :FMONTH,:FYEAR,
              :aMODE,:STOCK_CD,
              :AUSERID,:UPDATE_DATE,
              :aMODULE,
              :ORDER_LINE,
              :DESCS,:onhandqty,:QTY,0,:TRX_TYPE,:PURCHASE_DATE,
              :MELT_NO);
              WHEN SQLCODE - 530 DO
              BEGIN
                  EXCEPTION EX_INS_STOCKCARD;
              END
          END

          BEGIN
              UPDATE IC_STOCK_ADJUST_HD
              SET STATUS ='X'
              WHERE DOC_NO =:ADOC_NO
              AND CAST(DOC_DATE AS DATE) =:ADOC_DATE;
          END


     END /**FOR SELEC FROM IC_STOCK_ADJUST_HD*/
    end
    else
     begin
       exception e_no_row;
       exit;
     end
     suspend;
end^


ALTER PROCEDURE X_QUALIFY_STOCK (
    ASTOCK_CODE VARCHAR(15),
    ALOT_CD VARCHAR(15),
    AREF_NO VARCHAR(15),
    AREF_DATE TIMESTAMP)
RETURNS (
    ONHAND_QTY FLOAT,
    RESERVED_QTY FLOAT)
AS
begin
  SELECT SUM(ONHAND_QTY)
  FROM IC_MAT_STK_DT_LINK
  WHERE STOCK_CD =:astock_code
  AND LOT_CD =:alot_cd
  AND REF_NO =:aref_no
  AND REF_DATE =:aref_date
  INTO:onhand_qty;

  SELECT SUM(QTY) FROM IC_STOCK_RESERVED
  WHERE STOCK_CD =:astock_code
  AND LOT_CD =:alot_cd
  AND REF_NO =:aref_no
  AND REF_DATE =:aref_date
  INTO :reserved_qty;
  suspend;
end^


ALTER PROCEDURE X_RE_UPDATE_SO_HD_STATUS
AS
DECLARE VARIABLE ORDER_NO VARCHAR(15);
DECLARE VARIABLE ORDER_DATE TIMESTAMP;
DECLARE VARIABLE CUST_CODE VARCHAR(10);
DECLARE VARIABLE ORDER_ROW SMALLINT;
BEGIN

 FOR SELECT CUST_CODE, ORDER_NO ,ORDER_DATE
 FROM SO_ORDER_HD
 WHERE  STATUS ='O'
 INTO:CUST_CODE ,:ORDER_NO,:order_date
 DO
 BEGIN
         SELECT COUNT(*)
         FROM SO_ORDER_DT
         WHERE ORDER_NO =:ORDER_NO
         AND ORDER_DATE =:ORDER_DATE
         AND CUST_CODE =:CUST_CODE
         AND STATUS ='A'
         INTO:ORDER_ROW;
         /*UPDATE HEADER STATUS if (THERE ARE NO DETAIL ROW ACTIVE AS 'A') then*/
         if (ORDER_ROW =0) then
         BEGIN
           UPDATE SO_ORDER_HD
           SET STATUS ='O'/*Change status from c to o prevoiusly c is wrong*/
            WHERE ORDER_NO =:ORDER_NO
           AND ORDER_DATE =:ORDER_DATE
           AND CUST_CODE =:CUST_CODE;
         END
         ELSE
         BEGIN
            if (ORDER_ROW =0) then
         BEGIN
           UPDATE SO_ORDER_HD
           SET STATUS ='A'/*Change status from c to o prevoiusly c is wrong*/
            WHERE ORDER_NO =:ORDER_NO
           AND ORDER_DATE =:ORDER_DATE
           AND CUST_CODE =:CUST_CODE;
         END
         END
    END
 SUSPEND;
END^


ALTER PROCEDURE X_RECAL_STOCK (
    AFROM_DATE DATE,
    ATO_DATE DATE)
AS
declare variable unit_cost float;
declare variable qty float;
declare variable stock_value float;
declare variable doc_no varchar(15);
declare variable doc_date timestamp;
declare variable lot_cd varchar(15);
declare variable acct_cd varchar(10);
declare variable purchase_date timestamp ;
declare variable stock_cd varchar(15);
declare variable group_id varchar(10);
declare variable uom_cd varchar(4);
declare variable onhand_qty float;
BEGIN
 FOR SELECT ACCT_CD,DOC_NO ,DOC_DATE , LOT_CD,purchase_date ,stock_cd,group_id,uom_cd,QTY,UNIT_COST
 FROM IC_STOCKCARD
 WHERE MODULE ='PO'
 AND MODE ='I'
 order by doc_date
 INTO :acct_cd ,:doc_no,:doc_date,:lot_cd,:purchase_date,:stock_cd,:group_id,:uom_cd,:qty,:unit_cost
 do
 begin
 /**reset onhand qty  both stockcard and ic_mat_stk_dt_link*/
   insert into 
   IC_MAT_STK_DT_LINK_TMP (
    STOCK_CD ,
    GROUP_ID ,
    UOM_CD  ,
    LOT_CD  ,
    PURCHASE_DATE  ,
    ONHAND_QTY ,
    RESERVED_QTY ,
    STOCK_VALUE ,
    REF_NO ,
    REF_DATE )
    values (:stock_cd ,:group_id,:uom_cd,:lot_cd,:purchase_date,:qty,0,(:unit_cost*:qty),:doc_no,:doc_date) ;

   update ic_stockcard
   set onhand_qty =0
   where stock_cd =:stock_cd
   and group_id =:group_id
   and uom_cd =:uom_cd
   and lot_cd =:lot_cd
   and purchase_date =:purchase_date
   and doc_no =:doc_no
   and doc_date =:doc_date ;


   update ic_mat_stk_dt_link
   set onhand_qty =0
   where stock_cd =:stock_cd
   and group_id =:group_id
   and uom_cd =:uom_cd
   and lot_cd =:lot_cd
   and purchase_date =:purchase_date
   and ref_no =:doc_no
   and ref_date =:doc_date ;
  /**reset onhand qty  both stockcard and ic_mat_stk_dt_link*/

 /**1 to update back onhand_qty to ic_mat_stk_dt_link**/
  update ic_mat_stk_dt_link
   set onhand_qty =:qty
   where stock_cd =:stock_cd
   and group_id =:group_id
   and uom_cd =:uom_cd
   and lot_cd =:lot_cd
   and purchase_date =:purchase_date
   and ref_no =:doc_no
   and ref_date =:doc_date ;


   update ic_mat_stk_dt_link
   set  stock_value =onhand_qty * unit_cost,
       total_cost =onhand_qty * unit_cost
   where stock_cd =:stock_cd
   and group_id =:group_id
   and uom_cd =:uom_cd
   and lot_cd =:lot_cd
   and purchase_date =:purchase_date
   and ref_no =:doc_no
   and ref_date =:doc_date ;
   /**1 to update back onhand_qty to ic_mat_stk_dt_link**/

   /**2 get to total onhand_qty and stock value for each update
   then accumulative update to ic_mat_stk_dt*/

   select sum(onhand_qty), sum(stock_value)
   from  IC_MAT_STK_DT_LINK_TMP 
   where stock_cd =:stock_cd
   and group_id =:group_id
   and uom_cd =:uom_cd
   and lot_cd =:lot_cd
   and purchase_date =:purchase_date
   into :onhand_qty ,:stock_value;
   if (onhand_qty > 0 and stock_value >0) then
   begin
       update ic_mat_stk_dt
       set onhand_qty =:onhand_qty,
           stock_value =:stock_value,
           total_cost =:stock_value
       where stock_cd =:stock_cd
       and group_id =:group_id
       and uom_cd =:uom_cd
       and lot_cd =:lot_cd
       and purchase_date =:purchase_date;
   /**2 get to total onhand_qty and stock value for each update
       then accumulative update to ic_mat_stk_dt*/
    
   /**3 when get the right qty update onhand_back to stock card*/
    
       update ic_stockcard
       set onhand_qty =:onhand_qty ,
           stock_value =:stock_value,
           total_cost =:stock_value
       where stock_cd =:stock_cd
       and group_id =:group_id
       and uom_cd =:uom_cd
       and lot_cd =:lot_cd
       and purchase_date =:purchase_date
       and doc_no =:doc_no
       and doc_date =:doc_date ;
   end
   /**3 when get the right qty update onhand_back to stock card*/

 end
 SUSPEND;
END^


ALTER PROCEDURE X_RECAL_STOCK_VALUE (
    LOT_NO VARCHAR(15),
    STOCK_CD VARCHAR(15))
AS
declare variable onhand_qty float;
declare variable total_cost float;
begin
  SELECT SUM(QTY) ,SUM(QTY*UNIT_COST)
  FROM ic_stockcard
  WHERE LOT_CD =:LOT_NO
  AND STOCK_CD =:STOCK_CD
  INTO :ONHAND_QTY,:TOTAL_COST;

  UPDATE ic_mat_stk_dt
  SET ONHAND_QTY =:ONHAND_QTY,
      STOCK_VALUE =:TOTAL_COST,
      TOTAL_COST =:TOTAL_COST
    WHERE LOT_CD =:LOT_NO
     AND STOCK_CD =:STOCK_CD;


  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_RESET_RESERVED (
    ADOC_NO VARCHAR(15))
AS
DECLARE VARIABLE CURRENT_GRN_RESERVED_QTY FLOAT;
DECLARE VARIABLE CURRENT_LOT_RESERVED_QTY FLOAT;
DECLARE VARIABLE STOCK_CD VARCHAR(15);
DECLARE VARIABLE GROUP_ID VARCHAR(10);
DECLARE VARIABLE LOT_CD VARCHAR(15);
DECLARE VARIABLE PURCHASE_DATE TIMESTAMP;
DECLARE VARIABLE GRN_NO VARCHAR(15);
DECLARE VARIABLE GRN_DATE TIMESTAMP;
begin
   FOR SELECT
   STOCK_CD,GROUP_ID,LOT_CD,PURCHASE_DATE,
   REF_NO,REF_DATE
   FROM ic_stock_reserved
   WHERE DOC_NO =:adoc_no
   INTO :STOCK_CD,:GROUP_ID,:LOT_CD,:PURCHASE_DATE,:GRN_NO,:GRN_DATE
   do
   BEGIN

   select sum(qty)
                from ic_stock_reserved
                WHERE STOCK_CD = :STOCK_CD
                  AND GROUP_ID = :GROUP_ID
                  AND LOT_CD = :LOT_CD
                  AND PURCHASE_DATE =:PURCHASE_DATE
                  AND REF_NO = :grn_no
                  AND REF_DATE = :grn_date
                  AND DOC_NO =:ADOC_NO
                  into :current_grn_reserved_qty;
         UPDATE IC_MAT_STK_DT_LINK
         SET RESERVED_QTY =RESERVED_QTY -:current_grn_reserved_qty
          WHERE STOCK_CD = :STOCK_CD
                  AND GROUP_ID = :GROUP_ID
                  AND LOT_CD = :LOT_CD
                  AND PURCHASE_DATE =:PURCHASE_DATE
                   AND REF_NO = :grn_no
                  AND REF_DATE = :grn_date;
                select sum(qty)
                from ic_stock_reserved
                WHERE STOCK_CD = :STOCK_CD
                  AND GROUP_ID = :GROUP_ID
                  AND LOT_CD = :LOT_CD
                  AND PURCHASE_DATE =:PURCHASE_DATE
                  AND DOC_NO =:ADOC_NO
                  into :current_lot_reserved_qty;
                  UPDATE IC_MAT_STK_DT
                  SET RESERVED_QTY =RESERVED_QTY - :current_lot_reserved_qty
                  WHERE STOCK_CD = :STOCK_CD
                  AND GROUP_ID = :GROUP_ID
                  AND LOT_CD = :LOT_CD
                  AND PURCHASE_DATE =:PURCHASE_DATE ;

   END
   delete from ic_stock_reserved where doc_no =:adoc_no;
  suspend;
end^


ALTER PROCEDURE X_SO_CLONE_QUOTATION (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    NEWDOC_NO VARCHAR(15),
    NEWDOC_DATE TIMESTAMP,
    AUSERID VARCHAR(10))
AS
/**
Auther :Tinnarat Aromsuk
Date  : 23 April,2013  11:00 pm
Description :Reuse existing quoutation and generate to new document


***/
begin

insert INTO so_quotation_hd (
    doc_no,
    doc_date,
    ref_no,
    descs,
    cust_code,
    ref_date,
    doc_amt,
    status,
    validity,
    update_user,
    update_date,
    prepare_person,
    delivery_date,
    required_spec_sheet,
    remarks,
    fax_to,
    cc_to,
    no_of_print,
    tax_amt,
    currency_cd,
    currency_descs,
    address1,
    address2,
    address3,
    name,
    term_of_payment)
select :NEWdoc_no,
             :NEWdoc_date,
             ref_no,
             descs,
             cust_code,
             ref_date,
             doc_amt,
             status,
             validity,
             :AUSERID,
             CURRENT_TIMESTAMP,
             prepare_person,
             delivery_date,
             required_spec_sheet,
             remarks,
             fax_to,
             cc_to,
             no_of_print,
             tax_amt,
             currency_cd,
             currency_descs,
             address1,
             address2,
             address3,
             name,
             term_of_payment
             FROM so_quotation_hd
   where doc_no =:adoc_no
   and doc_date =:adoc_date  ;


   insert into so_quotation_dt
(
 doc_no,
             Doc_date,
             item_code,
             item_descs,
             cust_code,
             unit_cost,
             qty,
             total_amt,
             uom,
             remarks,
             discs_amt,
             tax_amt,
             base_amt,
             tax_cd,
             discs_cd,
             tax_rate,
             line_no,
             status,
             mark_up
)
select :NEWdoc_no,
             :NEWdoc_date,
             item_code,
             item_descs,
             cust_code,
             unit_cost,
             qty,
             total_amt,
             uom,
             remarks,
             discs_amt,
             tax_amt,
             base_amt,
             tax_cd,
             discs_cd,
             tax_rate,
             line_no,
             status,
             mark_up
      from so_quotation_dt
      where doc_no =:adoc_no
      and doc_date =:adoc_date  ;




 -- suspend;
end^


ALTER PROCEDURE X_SO_DUPLICATE_SALE_ITEM (
    AOLDITEM VARCHAR(15),
    ANEWITEM VARCHAR(15),
    ACUSTCODE VARCHAR(10))
AS
declare variable rowexists smallint;
begin
  /* Procedure Text */


  select count(*)
  from so_sales_item_req_sheet
  where cust_code = :acustcode
  and item_code = :anewitem
  into :rowexists;

  if (rowexists > 0) then
  begin
    delete from   so_sales_item_req_sheet
     where cust_code = :acustcode
     and item_code = :anewitem    ;

  end


   insert into so_sales_item_req_sheet (
    ITEM_CODE,
    uom_cd,
    cust_code,
    max_ele1,
    max_ele2,
    max_ele3,
    max_ele4,
    max_ele5,
    max_ele6,
    max_ele7,
    max_ele8,
    max_ele9,
    max_ele10,
    max_ele11,
    max_ele12,
    max_ele13,
    max_ele14,
    max_ele15,
    min_ele1,
    min_ele2,
    min_ele3,
    min_ele4,
    min_ele5,
    min_ele6,
    min_ele7,
    min_ele8,
    min_ele9,
    min_ele10,
    min_ele11,
    min_ele12,
    min_ele13,
    min_ele14,
    min_ele15,
    elabel1,
    elabel2,
    elabel3,
    elabel4,
    elabel5,
    elabel6,
    elabel7,
    elabel8,
    elabel9,
    elabel10,
    elabel11,
    elabel12,
    elabel13,
    elabel14,
    elabel15,
    min_float_point1,
    min_float_point2,
    min_float_point3,
    min_float_point4,
    min_float_point5,
    min_float_point6,
    min_float_point7,
    min_float_point8,
    min_float_point9,
    min_float_point10,
    min_float_point11,
    min_float_point12,
    min_float_point13,
    max_float_point1,
    max_float_point2,
    max_float_point3,
    max_float_point4,
    max_float_point5,
    max_float_point6,
    max_float_point7,
    max_float_point8,
    max_float_point9,
    max_float_point10,
    max_float_point11,
    max_float_point12,
    max_float_point13,
    min_mask1,
    min_mask2,
    min_mask3,
    min_mask4,
    min_mask5,
    min_mask6,
    min_mask7,
    min_mask8,
    min_mask9,
    min_mask10,
    min_mask11,
    min_mask12,
    min_mask13,
    max_mask1,
    max_mask2,
    max_mask3,
    max_mask4,
    max_mask5,
    max_mask6,
    max_mask7,
    max_mask8,
    max_mask9,
    max_mask10,
    max_mask11,
    max_mask12,
    max_mask13,
    cust_name,
    min_ele16,
    min_ele17,
    min_ele18,
    min_ele19,
    min_ele20,
    min_ele21,
    min_ele22,
    min_ele23,
    min_ele24,
    min_ele25,
    max_ele16,
    max_ele17,
    max_ele18,
    max_ele19,
    max_ele20,
    max_ele21,
    max_ele22,
    max_ele23,
    max_ele24,
    max_ele25,
    elabel16,
    elabel17,
    elabel18,
    elabel19,
    elabel20,
    elabel21,
    elabel22,
    elabel23,
    elabel24,
    elabel25,
    ele1_active,
    ele2_active,
    ele3_active,
    ele4_active,
    ele5_active,
    ele6_active,
    ele7_active,
    ele8_active,
    ele9_active,
    ele10_active,
    ele11_active,
    ele12_active,
    ele13_active,
    ele14_active,
    ele15_active,
    ele16_active,
    ele17_active,
    ele18_active,
    ele19_active,
    ele20_active,
    ele21_active,
    ele22_active,
    ele23_active,
    ele24_active,
    ele25_active,
    min_float_point14,
    min_float_point15,
    min_float_point16,
    min_float_point17,
    min_float_point18,
    min_float_point19,
    min_float_point20,
    min_float_point21,
    min_float_point22,
    min_float_point23,
    min_float_point24,
    min_float_point25,
    max_float_point14,
    max_float_point15,
    max_float_point16,
    max_float_point17,
    max_float_point18,
    max_float_point19,
    max_float_point20,
    max_float_point21,
    max_float_point22,
    max_float_point23,
    max_float_point24,
    max_float_point25,
    min_mask14,
    min_mask15,
    min_mask16,
    min_mask17,
    min_mask18,
    min_mask19,
    min_mask20,
    min_mask21,
    min_mask22,
    min_mask23,
    min_mask24,
    min_mask25,
    max_mask14,
    max_mask15,
    max_mask16,
    max_mask17,
    max_mask18,
    max_mask19,
    max_mask20,
    max_mask21,
    max_mask22,
    max_mask23,
    max_mask24,
    max_mask25,
    pele1_active,
    pele2_active,
    pele3_active,
    pele4_active,
    pele5_active,
    pele6_active,
    pele7_active,
    pele8_active,
    pele9_active,
    pele10_active,
    pele11_active,
    pele12_active,
    pele13_active,
    pele14_active,
    pele15_active,
    pele16_active,
    pele17_active,
    pele18_active,
    pele19_active,
    pele20_active,
    pele21_active,
    pele22_active,
    pele23_active,
    pele24_active,
    pele25_active)
  SELECT
    :ANEWITEM,
    uom_cd,
    cust_code,
    max_ele1,
    max_ele2,
    max_ele3,
    max_ele4,
    max_ele5,
    max_ele6,
    max_ele7,
    max_ele8,
    max_ele9,
    max_ele10,
    max_ele11,
    max_ele12,
    max_ele13,
    max_ele14,
    max_ele15,
    min_ele1,
    min_ele2,
    min_ele3,
    min_ele4,
    min_ele5,
    min_ele6,
    min_ele7,
    min_ele8,
    min_ele9,
    min_ele10,
    min_ele11,
    min_ele12,
    min_ele13,
    min_ele14,
    min_ele15,
    elabel1,
    elabel2,
    elabel3,
    elabel4,
    elabel5,
    elabel6,
    elabel7,
    elabel8,
    elabel9,
    elabel10,
    elabel11,
    elabel12,
    elabel13,
    elabel14,
    elabel15,
    min_float_point1,
    min_float_point2,
    min_float_point3,
    min_float_point4,
    min_float_point5,
    min_float_point6,
    min_float_point7,
    min_float_point8,
    min_float_point9,
    min_float_point10,
    min_float_point11,
    min_float_point12,
    min_float_point13,
    max_float_point1,
    max_float_point2,
    max_float_point3,
    max_float_point4,
    max_float_point5,
    max_float_point6,
    max_float_point7,
    max_float_point8,
    max_float_point9,
    max_float_point10,
    max_float_point11,
    max_float_point12,
    max_float_point13,
    min_mask1,
    min_mask2,
    min_mask3,
    min_mask4,
    min_mask5,
    min_mask6,
    min_mask7,
    min_mask8,
    min_mask9,
    min_mask10,
    min_mask11,
    min_mask12,
    min_mask13,
    max_mask1,
    max_mask2,
    max_mask3,
    max_mask4,
    max_mask5,
    max_mask6,
    max_mask7,
    max_mask8,
    max_mask9,
    max_mask10,
    max_mask11,
    max_mask12,
    max_mask13,
    cust_name,
    min_ele16,
    min_ele17,
    min_ele18,
    min_ele19,
    min_ele20,
    min_ele21,
    min_ele22,
    min_ele23,
    min_ele24,
    min_ele25,
    max_ele16,
    max_ele17,
    max_ele18,
    max_ele19,
    max_ele20,
    max_ele21,
    max_ele22,
    max_ele23,
    max_ele24,
    max_ele25,
    elabel16,
    elabel17,
    elabel18,
    elabel19,
    elabel20,
    elabel21,
    elabel22,
    elabel23,
    elabel24,
    elabel25,
    ele1_active,
    ele2_active,
    ele3_active,
    ele4_active,
    ele5_active,
    ele6_active,
    ele7_active,
    ele8_active,
    ele9_active,
    ele10_active,
    ele11_active,
    ele12_active,
    ele13_active,
    ele14_active,
    ele15_active,
    ele16_active,
    ele17_active,
    ele18_active,
    ele19_active,
    ele20_active,
    ele21_active,
    ele22_active,
    ele23_active,
    ele24_active,
    ele25_active,
    min_float_point14,
    min_float_point15,
    min_float_point16,
    min_float_point17,
    min_float_point18,
    min_float_point19,
    min_float_point20,
    min_float_point21,
    min_float_point22,
    min_float_point23,
    min_float_point24,
    min_float_point25,
    max_float_point14,
    max_float_point15,
    max_float_point16,
    max_float_point17,
    max_float_point18,
    max_float_point19,
    max_float_point20,
    max_float_point21,
    max_float_point22,
    max_float_point23,
    max_float_point24,
    max_float_point25,
    min_mask14,
    min_mask15,
    min_mask16,
    min_mask17,
    min_mask18,
    min_mask19,
    min_mask20,
    min_mask21,
    min_mask22,
    min_mask23,
    min_mask24,
    min_mask25,
    max_mask14,
    max_mask15,
    max_mask16,
    max_mask17,
    max_mask18,
    max_mask19,
    max_mask20,
    max_mask21,
    max_mask22,
    max_mask23,
    max_mask24,
    max_mask25,
    pele1_active,
    pele2_active,
    pele3_active,
    pele4_active,
    pele5_active,
    pele6_active,
    pele7_active,
    pele8_active,
    pele9_active,
    pele10_active,
    pele11_active,
    pele12_active,
    pele13_active,
    pele14_active,
    pele15_active,
    pele16_active,
    pele17_active,
    pele18_active,
    pele19_active,
    pele20_active,
    pele21_active,
    pele22_active,
    pele23_active,
    pele24_active,
    pele25_active
    FROM    so_sales_item_req_sheet
    WHERE CUST_CODE =:ACUSTCODE
    AND   ITEM_CODE=:aolditem     ;

 
 
  suspend;
end^


ALTER PROCEDURE X_SO_GEN_REVISION_DT (
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AFROM_DATE TIMESTAMP)
AS
begin
  delete from SO_ORDER_REVISION_DT 
  where doc_no =:adoc_no
  and doc_date =:adoc_date;

  INSERT INTO SO_ORDER_REVISION_DT (
    ORDER_NO,
    ORDER_DATE,
    ITEM_CODE,
    CUST_CODE,
    DOC_DATE,
    DOC_NO,
    LINE_NO,
    UOM,
    UNIT_COST,
    TOTAL_AMT,
    NEW_ORDER_FLAG,
    QTY,
    REMARKS,
    REF_NO,
    REF_DATE)
    select
    dt.order_no,
    dt.order_date,
    dt.item_code,
    dt.cust_code,
    :adoc_date,
    :adoc_no,
     dt.line_no,
    dt.uom,
    dt.unit_cost,
    dt.total_amt,
    'N',
    DT.qty,
    DT.remarks,
    '',
    current_date from so_order_dt  dt
    where order_date >=:afrom_date
    and status ='A';
end^


ALTER PROCEDURE X_SO_ORDER_STATUS (
    CUST_CODE VARCHAR(10),
    ORDER_NO VARCHAR(15),
    ORDER_DATE TIMESTAMP,
    STATUS VARCHAR(1))
AS
DECLARE VARIABLE ROWSNUM SMALLINT;
DECLARE VARIABLE DELIVERY_EXISTS SMALLINT;
begin
  if ((STATUS ='C') or (STATUS = 'O')) then
  BEGIN
  select count(*)
  from so_order_hd , so_order_dt
  where so_order_dt.cust_code = so_order_dt.cust_code
  and so_order_dt.order_no = so_order_hd.order_no
  and so_order_dt.order_date = so_order_hd.order_date
  and so_order_hd.cust_code =:cust_code
  and so_order_hd.order_no =:order_no
  and so_order_hd.order_date=:order_date
  and so_order_hd.status='A'
  and so_order_dt.status='A'
  into :ROWSNUM;
  if (ROWSNUM >0) then
  BEGIN
        if (STATUS ='C') then
        BEGIN
         select count(*)
          from so_order_hd , so_order_dt
          where so_order_dt.cust_code = so_order_dt.cust_code
          and so_order_dt.order_no = so_order_hd.order_no
          and so_order_dt.order_date = so_order_hd.order_date
          and so_order_dt.status='A'
          and so_order_dt.det_qty > 0
            and so_order_hd.cust_code =:cust_code
          and so_order_hd.order_no =:order_no
          and so_order_hd.order_date=:order_date
          into : DELIVERY_EXISTS;
          if (DELIVERY_EXISTS >0) then
          begin
             exception e_so_delivery_exist;
            exit;
          end
           UPDATE SO_ORDER_HD
           SET STATUS =:STATUS
           WHERE CUST_CODE =:CUST_CODE
           AND ORDER_NO =:ORDER_NO
           AND ORDER_DATE =:ORDER_DATE;

        END
        
        BEGIN
           UPDATE SO_ORDER_HD
           SET STATUS =:STATUS
           WHERE CUST_CODE =:CUST_CODE
           AND ORDER_NO =:ORDER_NO
           AND ORDER_DATE =:ORDER_DATE
           AND STATUS ='A';
           UPDATE SO_ORDER_DT
           SET STATUS =:STATUS
           WHERE CUST_CODE =:CUST_CODE
           AND ORDER_NO =:ORDER_NO
           AND ORDER_DATE =:ORDER_DATE
           AND STATUS ='A';
  
        END




 /*   UPDATE SO_ORDER_DT
    SET STATUS =:STATUS
    WHERE CUST_CODE =:CUST_CODE
    AND ORDER_NO =:ORDER_NO
    AND ORDER_DATE =:ORDER_DATE;*/
   END /*IF ROWSNUM > 0*/
   ELSE  begin
     exception e_no_row;
     exit;
   end
  END
  ELSE
  if (STATUS ='A') then
  BEGIN
   select count(*)
   from so_order_hd , so_order_dt
  where so_order_dt.cust_code = so_order_dt.cust_code
  and so_order_dt.order_no = so_order_hd.order_no
  and so_order_dt.order_date = so_order_hd.order_date
  and so_order_hd.cust_code =:cust_code
  and so_order_hd.order_no =:order_no
  and so_order_hd.order_date=:order_date
  and so_order_hd.status='N'
  and so_order_dt.status='N'
  into:ROWSNUM;
  if (ROWSNUM >0) then
  begin
            UPDATE SO_ORDER_HD
           SET STATUS =:STATUS
           WHERE CUST_CODE =:CUST_CODE
           AND ORDER_NO =:ORDER_NO
           AND ORDER_DATE =:ORDER_DATE;

           UPDATE SO_ORDER_DT
           SET STATUS =:STATUS
           WHERE CUST_CODE =:CUST_CODE
           AND ORDER_NO =:ORDER_NO
           AND ORDER_DATE =:ORDER_DATE;

  end
  ELSE
  begin
     exception e_no_row;
     exit;
   end


  END

  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_SO_QUO_STATUS (
    CUST_CODE VARCHAR(10),
    DOC_NO VARCHAR(15),
    DOC_DATE TIMESTAMP,
    STATUS VARCHAR(1))
AS
declare variable ROWSNUM smallint;
begin
  select count(*)
  from so_quotation_hd , so_quotation_dt
  where so_quotation_dt.doc_no = so_quotation_hd.doc_no
  and
  so_quotation_dt.doc_date = so_quotation_hd.doc_date
  and
  so_quotation_dt.cust_code = so_quotation_hd.cust_code
  into :ROWSNUM;
  if (ROWSNUM <= 0) then
  begin
     exception e_no_row;
  end
  else
  BEGIN
     UPDATE SO_QUOTATION_HD
      SET STATUS =:STATUS
      WHERE CUST_CODE =:CUST_CODE
      AND DOC_NO =:DOC_NO
      AND DOC_DATE =:DOC_DATE;



      UPDATE SO_QUOTATION_DT
      SET STATUS =:STATUS
      WHERE CUST_CODE =:CUST_CODE
      AND DOC_NO =:DOC_NO
      AND DOC_DATE =:DOC_DATE;
  END
    suspend;
  /* Procedure Text */
end^


ALTER PROCEDURE X_SO_QUOTATION_HD_VALIDATE (
    VNOW DATE)
AS
declare variable ROWSNUM integer;
begin
  /* Procedure Text */
  select count(*)
  from so_quotation_hd
  where status IN('N','A')
  and validity < :VNOW
  into :ROWSNUM;

  if(:ROWSNUM <= 0) then
   begin
       exit;
   end
  else
   begin
      update so_quotation_hd
      set status = 'C'
      where status in ( 'N','A')
       and validity < :VNOW;
   end
  suspend;
end^


ALTER PROCEDURE X_SO_UPD_ITEM_STATUS (
    AORDER_NO VARCHAR(15),
    AORDER_DATE DATE,
    ACUST_CODE VARCHAR(10),
    AITEM_CODE VARCHAR(15),
    ASTATUS VARCHAR(1))
AS
declare variable delivered_qty smallint;
begin
  delivered_qty =0;
  SELECT sum(det_qty)
  from so_order_dt
  where order_no =:AORDER_NO
  and order_date =:aorder_date
  and cust_code =:acust_code
  and item_code =:aitem_code
  and status='A'
  into :delivered_qty;
  if (delivered_qty > 0) then
  begin
     exception E_SO_ORDER_ITEM_STATUS;
     exit;

  end
  else
  if (delivered_qty=0) then
  begin
    update so_order_dt
    set status =:ASTATUS
     where order_no =:AORDER_NO
    and order_date =:aorder_date
    and cust_code =:acust_code
    and item_code =:aitem_code
    and status ='A' ;
  end


  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_SO_UPD_RESERVED (
    AMELT_NO VARCHAR(10),
    AITEM_CODE VARCHAR(15),
    ADOC_NO VARCHAR(15),
    ADOC_DATE DATE)
AS
DECLARE VARIABLE I_UPD_QTY SMALLINT;
begin
   i_upd_qty =0;
   select sum(dt.det_qty)
   from so_det_dt dt , so_det_hd h
   where h.delivery_no = dt.delivery_no
   and h.delivery_date =dt.delivery_date
   and h.cust_code =dt.cust_code
   and h.status <>'X'
   and dt.melt_no =:amelt_no
   and dt.item_code =:aitem_code
   and dt.ref_no =:adoc_no
   and dt.ref_date =:adoc_date
   into :i_upd_qty;
   if (i_upd_qty is null) then i_upd_qty=0;
   if (i_upd_qty >= 0) then
   begin
     update so_sales_item_stock
     set reserved_qty =:i_upd_qty
     where doc_no =:adoc_no
     and doc_date =:adoc_date
     and item_code =:aitem_code
     and melt_no =:amelt_no;
   end


  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_SYS_IMPORT_MENUS (
    AUSERID VARCHAR(10),
    AMODULEID VARCHAR(4))
AS
begin
 INSERT INTO SYS_USER_MENUS (
    MODULE_ID,       MENU_INDEX,    MENU_ITEM_INDEX,    FORM_NAME,
    GROUP_ID,    USER_ID,    EDIT_FLAG,    DELETE_FLAG,    INSERT_FLAG,
    EXECUTE_FLAG,    POST_FLAG,    FORM_CAPTION,    MAIN_MENU_NAME)

    SELECT MODULE_ID,                               MENU_INDEX,    MENU_ITEM_INDEX,
    FORM_NAME  ,    '001',   :AUSERID,    'Y',    'Y',    'Y',    'Y',    'Y',
    FORM_CAPTION,
    MAIN_MENU_NAME
from sys_menus
where update_user <>'jrx'
and enabled ='Y'
AND MENU_INDEX <=1
and module_id =:AMODULEID
ORDER BY MODULE_ID,MENU_INDEX,MENU_ITEM_INDEX;
  suspend;
end^


ALTER PROCEDURE X_U_SALE_REQ_CUST_SHEET
AS
declare variable cust_name varchar(60);
declare variable cust_code varchar(10);
declare variable item_code varchar(15);

begin
  for select item_code ,cust_code
  from so_sales_item_req_sheet
  into :item_code,:cust_code
  do
  begin
     SELECT NAME FROM SO_CUSTOMERS
     WHERE CUSTOMER_CD =:CUST_CODE
     INTO :CUST_NAME;

     UPDATE SO_SALES_ITEM_REQ_SHEET
     SET CUST_NAME =:CUST_NAME
     WHERE ITEM_CODE =:ITEM_CODE
     AND CUST_CODE =:CUST_CODE;
  end

  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_UPD_PL_STIME (
    PLAN_DOC VARCHAR(15),
    PLAN_DATE TIMESTAMP,
    LINE_NO SMALLINT,
    UPD_TIME TIMESTAMP)
AS
begin
  update pl_pro_plan_dt
  set stime =cast(:upd_time as timestamp   )
  where plan_doc =:plan_doc
  and plan_date =:plan_date
  and line_no =:line_no ;
  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_UPD_PURCHASE_DATE
AS
declare variable STOCK_CD VARCHAR(15);
declare variable uom_cd varchar(4);
declare variable GROUP_ID varchar(10);
declare variable lot_cd varchar(15);
declare variable purchase_date timestamp;
declare variable acct_cd varchar(10);
begin
      FOR SELECT STOCK_CD,GROUP_ID,UOM_CD,LOT_CD,PURCHASE_DATE,ACCT_CODE
      FROM IC_MAT_STK_DT
      INTO :STOCK_CD,:GROUP_ID,:UOM_CD,:LOT_CD,:purchase_date ,:acct_cd
      do
      BEGIN
         UPDATE IC_MAT_ELEMENT
         SET PURCHASE_DATE =:PURCHASE_DATE  ,
             ACCT_CD =:ACCT_CD
         WHERE STOCK_CD = :STOCK_CD
         AND GROUP_ID =:GROUP_ID
         AND UOM_CD =:UOM_CD
         AND LOT_CD =:LOT_CD
         AND PURCHASE_DATE IS NULL
         AND ACCT_CD IS NULL  ;



      END
  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_UPD_REMELT_COST
AS
declare variable lot_cd varchar(15);
declare variable purchase_date timestamp;
declare variable stock_cd varchar(15);
declare variable upd_cost decimal(12,2);
begin

  for select ic.lot_cd ,ic.purchase_date,ic.stock_cd,ic.unit_cost
  from ic_mat_stk_dt_link ic, po_order_dt po
  where po.order_no = ic.lot_cd
  and po.order_date = ic.purchase_date
    and po.item_code = ic.stock_cd
    and (ic.lot_cd like '%fg%'
    or ic.lot_cd like '%FG%')
    and (ic.unit_cost>0)
    into :lot_cd,:purchase_date,:stock_cd,:upd_cost
    do
    begin
      update po_order_dt
      set update_price =:upd_cost,
          unit_cost=:upd_cost ,
          total_amt=:upd_cost*qty
      where order_no =:lot_cd
      and order_date =:purchase_date
      and item_code =:stock_cd  ;
    end
    suspend;
end^


ALTER PROCEDURE X_UPD_STOCK_RESERVED (
    STOCK_CODE VARCHAR(15),
    GROUP_ID VARCHAR(10),
    UOM_CD VARCHAR(4),
    LOT_CD VARCHAR(15),
    PURCHASE_DATE DATE,
    GRN_NO VARCHAR(15),
    GRN_DATE DATE,
    SUPP_CODE VARCHAR(10),
    QTY FLOAT)
AS
declare variable upd_qty float;
declare variable new_reserved_qty float;
begin
  SELECT SUM(QTY)
  FROM PL_REQ_HD H , PL_REQ_DT D
  WHERE H.DOC_NO = D.DOC_NO
  AND H.DOC_DATE =D.DOC_DATE
  AND H.trx_type = D.TRX_TYPE
  AND H.STATUS ='N'
  AND D.item_code =:STOCK_CODE
  AND D.group_id =:GROUP_ID
  AND D.uom =:UOM_CD
  AND D.lot_no = :LOT_CD
  AND D.purchase_date  =:purchase_date
  and d.ref_no =:grn_no
  and d.ref_date =:grn_date
  into :upd_qty;
  if (upd_qty is null) then upd_qty =0;
  if (upd_qty > 0 and upd_qty >=  qty) then
  begin
     begin
         upd_qty = upd_qty -:qty;
         update ic_mat_stk_dt_link
         set reserved_qty =:upd_qty
         where stock_cd =:STOCK_CODE
         AND group_id =:GROUP_ID
         AND uom_cd =:UOM_CD
         AND lot_cd = :LOT_CD
         AND purchase_date  =:purchase_date
         and ref_no =:grn_no
         and ref_date =:grn_date;
     end /*update ic_mat_stk_dt_link*/
     begin
         select sum(reserved_qty)
         from  ic_mat_stk_dt_link
         where stock_cd =:STOCK_CODE
         AND group_id =:GROUP_ID
         AND uom_cd =:UOM_CD
         AND lot_cd = :LOT_CD
         AND purchase_date  =:purchase_date
         AND ACCT_CODE =:SUPP_CODE
         and ref_no =:grn_no
         and ref_date =:grn_date
         into :new_reserved_qty;
         if (new_reserved_qty is null ) then new_reserved_qty =0;
         if (new_reserved_qty >= 0) then
         begin
            update ic_mat_stk_dt
            set reserved_qty =:new_reserved_qty
            where stock_cd =:STOCK_CODE
            AND group_id =:GROUP_ID
             AND uom_cd =:UOM_CD
             AND lot_cd = :LOT_CD
             AND ACCT_CODE =:SUPP_CODE
             AND purchase_date  =:purchase_date;
         end
     end
  end


  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE X_UPD_STOCKCARD_PURCHASE_DATE
AS
declare variable lot_cd varchar(15);
declare variable purchase_date timestamp ;
declare variable acct_cd varchar(10);
BEGIN

    FOR SELECT acct_cd ,lot_cd
    FROM IC_STOCKCARD
    WHERE purchase_date is null
    order by doc_date
    into :acct_cd ,:lot_cd
    do
    begin
      select max(order_date)
      from po_order_hd
      where supp_code =:acct_cd
      and order_no =:lot_cd
      into :purchase_date;

      update IC_STOCKCARD
      set purchase_date =:purchase_date
      where acct_cd =:acct_cd
      and lot_cd =:lot_cd
      and purchase_date is null  ;
    end

    suspend;
end^


ALTER PROCEDURE X_UPD_STOCKRESERVE (
    ASTOCK_CD VARCHAR(15),
    ALOT_CD VARCHAR(15),
    APURCHAE_DATE TIMESTAMP,
    AREF_NO VARCHAR(15),
    AREF_DATE TIMESTAMP,
    ADOC_NO VARCHAR(15),
    ADOC_DATE TIMESTAMP,
    AUSER_ID VARCHAR(10),
    AQTY FLOAT,
    AMODE VARCHAR(10))
AS
DECLARE VARIABLE RECORDFOUND SMALLINT;
DECLARE VARIABLE PURCHASE_DATE TIMESTAMP;
DECLARE VARIABLE GROUP_ID VARCHAR(10);
DECLARE VARIABLE UOM_CD VARCHAR(4);
DECLARE VARIABLE RESERVEDDETAILQTY FLOAT;
DECLARE VARIABLE RESERVEDLINKQTY FLOAT;
DECLARE VARIABLE AASTOCK_CD VARCHAR(15);
DECLARE VARIABLE AALOT_CD VARCHAR(15);
DECLARE VARIABLE AAPURCHAE_DATE TIMESTAMP;
DECLARE VARIABLE AAREF_NO VARCHAR(15);
DECLARE VARIABLE AAREF_DATE TIMESTAMP;
DECLARE VARIABLE AADOC_DATE TIMESTAMP;
begin
  /* Procedure Text */
  RECORDFOUND =0;
  if (amode='DEL_ALL') then
  BEGIN
     FOR
     SELECT
     DOC_DATE,
     STOCK_CD,
     LOT_CD,
     PURCHASE_DATE,
     REF_NO,
     REF_DATE
     FROM ic_stock_reserved
     WHERE DOC_NO =:ADOC_NO
     into :AADOC_DATE,:AASTOCK_CD,
     :Aalot_cd,:Aapurchae_date,:Aaref_no,:AAREF_DATE
     DO
     BEGIN
         update ic_stock_reserved
          set qty =0
          where stock_cd =:Aastock_cd
          and lot_cd =:Aalot_cd
          and ref_no =:Aaref_no
          and ref_date =:Aaref_date
          and doc_no =:adoc_no
          and doc_date =:Aadoc_date;



     select sum (qty)
     from  ic_stock_reserved
     where stock_cd =:Aastock_cd
          and lot_cd =:Aalot_cd
          and purchase_date =:Aapurchae_date
          into :reservedDetailQty;
     if (reservedDetailQty IS NULL) then reservedDetailQty=0;
        if (reservedDetailQty >=0) then
        begin
            update ic_mat_stk_dt
            set reserved_qty =: reservedDetailQty
             where stock_cd =:Aastock_cd
               and lot_cd =:Aalot_cd
               and purchase_date =:Aapurchae_date ;
        end

      select sum (qty)
     from ic_stock_reserved
     where stock_cd =:Aastock_cd
          and lot_cd =:Aalot_cd
          and purchase_date =:Aapurchae_date
          and ref_no =:Aaref_no
           and ref_date =:Aaref_date
          into :reservedLinkQty;
          if (reservedLinkQty IS NULL) then reservedLinkQty=0;
          if (reservedLinkQty >=0) then
          begin
            update ic_mat_stk_dt_link
            set reserved_qty =:reservedLinkQty
            where stock_cd =:Aastock_cd
          and lot_cd =:Aalot_cd
          and purchase_date =:Aapurchae_date
          and ref_no =:Aaref_no
           and ref_date =:Aaref_date;

          end
    END /*END FOR*/
       DELETE
         from ic_stock_reserved
      where  doc_no =:adoc_no;

  END
  else
  BEGIN
  select count(*)
  from ic_stock_reserved
  where stock_cd =:astock_cd
  and lot_cd =:alot_cd
  and ref_no =:aref_no
  and ref_date =:aref_date
  and doc_no =:adoc_no
  and doc_date =:adoc_date
  into :recordfound;
  if (recordfound >0) then
  begin
          update ic_stock_reserved
          set qty =:aqty
          where stock_cd =:astock_cd
          and lot_cd =:alot_cd
          and ref_no =:aref_no
          and ref_date =:aref_date
          and doc_no =:adoc_no
          and doc_date =:adoc_date;

  end
  else if (recordfound=0) then
  begin
    SELECT MAX(PURCHASE_DATE), MAX(GROUP_ID),
    MAX(UOM_CD)
    FROM IC_MAT_STK_DT_LINK
    WHERE STOCK_CD =:astock_cd
    AND LOT_CD =:alot_cd
    AND PURCHASE_DATE =:apurchae_date
    AND REF_NO =:aref_no
    AND REF_DATE =:aref_date
    INTO :PURCHASE_DATE,:GROUP_ID,:UOM_CD;

    INSERT INTO IC_STOCK_RESERVED (
    DOC_NO,
    DOC_DATE,
    LOT_CD,
    PURCHASE_DATE,
    REF_NO,
    REF_DATE,
    STOCK_CD,
    GROUP_ID,
    UOM_CD,
    QTY,
    UPDATE_USER,
    UPDATE_DATE)
    VALUES(:ADOC_NO,:ADOC_DATE,:alot_cd,:apurchae_date,:AREF_NO,
    :AREF_DATE,:astock_cd,:GROUP_ID,:UOM_CD,
    :aqty, :auser_id,current_timestamp);
  end
  if (AMODE ='D') then
  BEGIN
      DELETE
         from ic_stock_reserved
      where stock_cd =:astock_cd
      and lot_cd =:alot_cd
      and ref_no =:aref_no
      and ref_date =:aref_date
      and doc_no =:adoc_no
      and doc_date =:adoc_date;


  END

  
     select sum (qty)
     from  ic_stock_reserved
     where stock_cd =:astock_cd
          and lot_cd =:alot_cd
          and purchase_date =:apurchae_date
          into :reservedDetailQty;
     if (reservedDetailQty IS NULL) then reservedDetailQty=0;
        if (reservedDetailQty >=0) then
        begin
            update ic_mat_stk_dt
            set reserved_qty =: reservedDetailQty
             where stock_cd =:astock_cd
               and lot_cd =:alot_cd
               and purchase_date =:apurchae_date ;
        end

      select sum (qty)
     from ic_stock_reserved
     where stock_cd =:astock_cd
          and lot_cd =:alot_cd
          and purchase_date =:apurchae_date
          and ref_no =:aref_no
           and ref_date =:aref_date
          into :reservedLinkQty;
          if (reservedLinkQty IS NULL) then reservedLinkQty=0;
          if (reservedLinkQty >=0) then
          begin
            update ic_mat_stk_dt_link
            set reserved_qty =:reservedLinkQty
            where stock_cd =:astock_cd
          and lot_cd =:alot_cd
          and purchase_date =:apurchae_date
          and ref_no =:aref_no
           and ref_date =:aref_date;

          end
  
  END
  suspend;
end^


ALTER PROCEDURE X_UPDATE_ELEMENT_LABEL (
    ACUSTCODE VARCHAR(10),
    AITEMCODE VARCHAR(15),
    ALABELONLY VARCHAR(1))
AS
begin

if (ALABELONLY ='Y'  ) then
BEGIN
update  ic_element_label
set elabel1  = (select element_code from ic_element where run_no =1)  ,
   elabel2  = (select element_code from ic_element where run_no =2) ,
   elabel3  = (select element_code from ic_element where run_no =3) ,
   elabel4  = (select element_code from ic_element where run_no =4) ,
   elabel5  = (select element_code from ic_element where run_no =5) ,
   elabel6  = (select element_code from ic_element where run_no =6) ,
   elabel7  = (select element_code from ic_element where run_no =7) ,
   elabel8  = (select element_code from ic_element where run_no =8) ,
   elabel9  = (select element_code from ic_element where run_no =9) ,
   elabel10  = (select element_code from ic_element where run_no =10) ,
   elabel11  = (select element_code from ic_element where run_no =11) ,
   elabel12  = (select element_code from ic_element where run_no =12) ,
   elabel13  = (select element_code from ic_element where run_no =13),
   elabel14  = (select element_code from ic_element where run_no =14),
   elabel15  = (select element_code from ic_element where run_no =15),
   elabel16  = (select element_code from ic_element where run_no =16),
   elabel17  = (select element_code from ic_element where run_no =17),
   elabel18  = (select element_code from ic_element where run_no =18),
   elabel19  = (select element_code from ic_element where run_no =19),
   elabel20  = (select element_code from ic_element where run_no =20),
   elabel21  = (select element_code from ic_element where run_no =21),
   elabel22  = (select element_code from ic_element where run_no =22),
   elabel23  = (select element_code from ic_element where run_no =23),
   elabel24  = (select element_code from ic_element where run_no =24),
   elabel25  = (select element_code from ic_element where run_no =25);



END
 
if ((ACUSTCODE ='*') AND (AITEMCODE='*')) then
BEGIN
update  ic_element_label
set elabel1  = (select element_code from ic_element where run_no =1)  ,
   elabel2  = (select element_code from ic_element where run_no =2) ,
   elabel3  = (select element_code from ic_element where run_no =3) ,
   elabel4  = (select element_code from ic_element where run_no =4) ,
   elabel5  = (select element_code from ic_element where run_no =5) ,
   elabel6  = (select element_code from ic_element where run_no =6) ,
   elabel7  = (select element_code from ic_element where run_no =7) ,
   elabel8  = (select element_code from ic_element where run_no =8) ,
   elabel9  = (select element_code from ic_element where run_no =9) ,
   elabel10  = (select element_code from ic_element where run_no =10) ,
   elabel11  = (select element_code from ic_element where run_no =11) ,
   elabel12  = (select element_code from ic_element where run_no =12) ,
   elabel13  = (select element_code from ic_element where run_no =13),
   elabel14  = (select element_code from ic_element where run_no =14),
   elabel15  = (select element_code from ic_element where run_no =15),
   elabel16  = (select element_code from ic_element where run_no =16),
   elabel17  = (select element_code from ic_element where run_no =17),
   elabel18  = (select element_code from ic_element where run_no =18),
   elabel19  = (select element_code from ic_element where run_no =19),
   elabel20  = (select element_code from ic_element where run_no =20),
   elabel21  = (select element_code from ic_element where run_no =21),
   elabel22  = (select element_code from ic_element where run_no =22),
   elabel23  = (select element_code from ic_element where run_no =23),
   elabel24  = (select element_code from ic_element where run_no =24),
   elabel25  = (select element_code from ic_element where run_no =25);





update  so_sales_item_req_sheet
set elabel1  = (select element_code from ic_element where run_no =1)  ,
   ELE1_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =1) ,
   PELE1_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =1) ,

   elabel2  = (select element_code from ic_element where run_no =2) ,
   ELE2_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =2) ,
   PELE2_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =2) ,


   elabel3  = (select element_code from ic_element where run_no =3) ,
   ELE3_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =3) ,
   PELE3_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =3) ,

   elabel4  = (select element_code from ic_element where run_no =4) ,
   ELE4_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =4) ,
   PELE4_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =4) ,


   elabel5  = (select element_code from ic_element where run_no =5) ,
   ELE5_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =5) ,
   PELE5_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =5) ,

   elabel6  = (select element_code from ic_element where run_no =6) ,
   ELE6_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =6) ,
   PELE6_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =6) ,


   elabel7  = (select element_code from ic_element where run_no =7) ,
   ELE7_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =7) ,
   PELE7_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =7) ,

   elabel8  = (select element_code from ic_element where run_no =8) ,
   ELE8_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =8) ,
   PELE8_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =8) ,

   elabel9  = (select element_code from ic_element where run_no =9) ,
   ELE9_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =9) ,
   PELE9_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =9) ,

   elabel10  = (select element_code from ic_element where run_no =10) ,
   ELE10_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =10) ,
   PELE10_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =10) ,

   elabel11  = (select element_code from ic_element where run_no =11) ,
   ELE11_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =11) ,
   PELE11_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =11) ,

   elabel12  = (select element_code from ic_element where run_no =12) ,
   ELE12_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =12) ,
   PELE12_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =12) ,

   elabel13  = (select element_code from ic_element where run_no =13),
   ELE13_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =13) ,
   PELE13_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =13) ,

   elabel14  = (select element_code from ic_element where run_no =14),
   ELE14_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =14) ,
   PELE14_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =14) ,

   elabel15  = (select element_code from ic_element where run_no =15),
   ELE15_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =15) ,
   PELE15_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =15) ,

   elabel16  = (select element_code from ic_element where run_no =16),
   ELE16_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =16) ,
   PELE16_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =16) ,

   elabel17  = (select element_code from ic_element where run_no =17),
   ELE17_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =17) ,
   PELE17_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =17) ,

   elabel18  = (select element_code from ic_element where run_no =18),
   ELE18_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =18) ,
   PELE18_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =18) ,

   elabel19  = (select element_code from ic_element where run_no =19),
   ELE19_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =19) ,
   PELE19_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =19) ,

   elabel20  = (select element_code from ic_element where run_no =20),
   ELE20_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =20) ,
   PELE20_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =20) ,

   elabel21  = (select element_code from ic_element where run_no =21),
   ELE21_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =21) ,
   PELE21_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =21) ,

   elabel22  = (select element_code from ic_element where run_no =22),
   ELE22_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =22) ,
   PELE22_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =22) ,

   elabel23  = (select element_code from ic_element where run_no =23),
   ELE23_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =23) ,
   PELE23_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =23) ,

   elabel24  = (select element_code from ic_element where run_no =24),
   ELE24_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =24) ,
   PELE24_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =24) ,

   elabel25  = (select element_code from ic_element where run_no =25)  ,
   ELE25_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =25) ,
   PELE25_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =25)  ;

  suspend;
  END
  ELSE
  BEGIN

  



update  so_sales_item_req_sheet
set elabel1  = (select element_code from ic_element where run_no =1)  ,
   ELE1_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =1) ,
   PELE1_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =1) ,

   elabel2  = (select element_code from ic_element where run_no =2) ,
   ELE2_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =2) ,
   PELE2_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =2) ,


   elabel3  = (select element_code from ic_element where run_no =3) ,
   ELE3_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =3) ,
   PELE3_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =3) ,

   elabel4  = (select element_code from ic_element where run_no =4) ,
   ELE4_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =4) ,
   PELE4_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =4) ,


   elabel5  = (select element_code from ic_element where run_no =5) ,
   ELE5_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =5) ,
   PELE5_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =5) ,

   elabel6  = (select element_code from ic_element where run_no =6) ,
   ELE6_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =6) ,
   PELE6_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =6) ,


   elabel7  = (select element_code from ic_element where run_no =7) ,
   ELE7_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =7) ,
   PELE7_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =7) ,

   elabel8  = (select element_code from ic_element where run_no =8) ,
   ELE8_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =8) ,
   PELE8_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =8) ,

   elabel9  = (select element_code from ic_element where run_no =9) ,
   ELE9_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =9) ,
   PELE9_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =9) ,

   elabel10  = (select element_code from ic_element where run_no =10) ,
   ELE10_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =10) ,
   PELE10_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =10) ,

   elabel11  = (select element_code from ic_element where run_no =11) ,
   ELE11_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =11) ,
   PELE11_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =11) ,

   elabel12  = (select element_code from ic_element where run_no =12) ,
   ELE12_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =12) ,
   PELE12_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =12) ,

   elabel13  = (select element_code from ic_element where run_no =13),
   ELE13_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =13) ,
   PELE13_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =13) ,

   elabel14  = (select element_code from ic_element where run_no =14),
   ELE14_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =14) ,
   PELE14_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =14) ,

   elabel15  = (select element_code from ic_element where run_no =15),
   ELE15_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =15) ,
   PELE15_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =15) ,

   elabel16  = (select element_code from ic_element where run_no =16),
   ELE16_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =16) ,
   PELE16_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =16) ,

   elabel17  = (select element_code from ic_element where run_no =17),
   ELE17_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =17) ,
   PELE17_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =17) ,

   elabel18  = (select element_code from ic_element where run_no =18),
   ELE18_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =18) ,
   PELE18_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =18) ,

   elabel19  = (select element_code from ic_element where run_no =19),
   ELE19_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =19) ,
   PELE19_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =19) ,

   elabel20  = (select element_code from ic_element where run_no =20),
   ELE20_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =20) ,
   PELE20_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =20) ,

   elabel21  = (select element_code from ic_element where run_no =21),
   ELE21_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =21) ,
   PELE21_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =21) ,

   elabel22  = (select element_code from ic_element where run_no =22),
   ELE22_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =22) ,
   PELE22_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =22) ,

   elabel23  = (select element_code from ic_element where run_no =23),
   ELE23_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =23) ,
   PELE23_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =23) ,

   elabel24  = (select element_code from ic_element where run_no =24),
   ELE24_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =24) ,
   PELE24_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =24) ,

   elabel25  = (select element_code from ic_element where run_no =25)  ,
   ELE25_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =25) ,
   PELE25_ACTIVE =(select ELEMENT_ACTIVE from ic_element where run_no =25)
   WHERE CUST_CODE =:acustcode
   AND ITEM_CODE =:aitemcode;

  suspend;

  END
end^


ALTER PROCEDURE X_UPDATE_OLD_PC_DATE
AS
DECLARE VARIABLE STOCK_CD VARCHAR(25);
DECLARE VARIABLE LOT_CD VARCHAR(15);
DECLARE VARIABLE PURCHASE_DATE TIMESTAMP;
DECLARE VARIABLE REF_NO VARCHAR(15);
DECLARE VARIABLE REF_DATE TIMESTAMP;
begin
  /* Procedure Text */
  for select  stock_cd,lot_cd,purchase_date,
  ref_no,ref_date
  from ic_mat_stk_dt_link
  where ref_no in (
'GRNFAPC0084/04','GRNFAPC0680/04','GRNFAPC216/05',
'GRNFAPC0840/05','69/3527','GRNFAPC0083/04',
'GRNFAPC0681/04','GRNFAPC0438/05','GRNFAPC0065/05','GRNFAPC0216/05','GRNFAPC0541/05')
  into :stock_cd, :lot_cd ,:purchase_date,:ref_no,:ref_date
  do
  begin
   /*update purchase order*/
   update po_order_hd
   set order_date = '01/01/2006'
   where order_no = :lot_cd
   and order_date = :purchase_date;
   /*update grn*/
   update po_grn_dt
   set order_date  =  '01/01/2006'
   where order_no  = :lot_cd
   and order_date = :purchase_date
   and grn_no = :ref_no
   and grn_date = :ref_date  ;

   /*update stock dt*/
    update ic_mat_stk_dt
    set purchase_date = '01/01/2006'
    where lot_cd = :lot_cd
    and purchase_date = :purchase_date;

   /*update stock dt link*/
   update ic_mat_stk_dt_link
    set purchase_date = '01/01/2006'
    where lot_cd = :lot_cd
    and purchase_date = :purchase_date
    and ref_no = :ref_no
    and ref_date = :ref_date;
   /*update stock card*/
   update ic_stockcard
   set purchase_date = '01/01/2006',
   ref_date = '01/01/2006'
   where lot_cd = :lot_cd
    and purchase_date = :purchase_date
    and ref_no = :ref_no
    and ref_date = :ref_date   ;


  end
  suspend;
end^



SET TERM ; ^
